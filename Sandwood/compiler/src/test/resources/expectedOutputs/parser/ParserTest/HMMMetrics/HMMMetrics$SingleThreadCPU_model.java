package org.sandwood.compiler.tests.parser;

import org.sandwood.runtime.internal.numericTools.Conjugates;
import org.sandwood.runtime.internal.numericTools.DistributionSampling;
import org.sandwood.runtime.model.ExecutionTarget;

class HMMMetrics$SingleThreadCPU extends org.sandwood.runtime.internal.model.CoreModelSingleThreadCPU implements HMMMetrics$CoreInterface {
	
	// Declare the variables for the model.
	private double[] cpu;
	private double[] cpuMean;
	private double[] cpuVar;
	private double[] cpu_measured;
	private double[] cv$distributionAccumulator$var39;
	private double[] cv$var22$countGlobal;
	private double[] cv$var27$countGlobal;
	private double[] cv$var30$stateProbabilityGlobal;
	private double[] cv$var40$stateProbabilityGlobal;
	private double[] distribution$sample35;
	private double[][] distribution$sample45;
	private boolean fixedFlag$sample100 = false;
	private boolean fixedFlag$sample110 = false;
	private boolean fixedFlag$sample119 = false;
	private boolean fixedFlag$sample124 = false;
	private boolean fixedFlag$sample129 = false;
	private boolean fixedFlag$sample25 = false;
	private boolean fixedFlag$sample32 = false;
	private boolean fixedFlag$sample35 = false;
	private boolean fixedFlag$sample45 = false;
	private boolean fixedFlag$sample58 = false;
	private boolean fixedFlag$sample69 = false;
	private boolean fixedFlag$sample80 = false;
	private boolean fixedFlag$sample90 = false;
	private boolean fixedProbFlag$sample100 = false;
	private boolean fixedProbFlag$sample110 = false;
	private boolean fixedProbFlag$sample119 = false;
	private boolean fixedProbFlag$sample124 = false;
	private boolean fixedProbFlag$sample129 = false;
	private boolean fixedProbFlag$sample25 = false;
	private boolean fixedProbFlag$sample32 = false;
	private boolean fixedProbFlag$sample35 = false;
	private boolean fixedProbFlag$sample45 = false;
	private boolean fixedProbFlag$sample58 = false;
	private boolean fixedProbFlag$sample69 = false;
	private boolean fixedProbFlag$sample80 = false;
	private boolean fixedProbFlag$sample90 = false;
	private boolean[] guard$sample35gaussian118$global;
	private boolean[] guard$sample35gaussian123$global;
	private boolean[] guard$sample35gaussian128$global;
	private boolean[] guard$sample45gaussian118$global;
	private boolean[] guard$sample45gaussian123$global;
	private boolean[] guard$sample45gaussian128$global;
	private double[] initialStateDistribution;
	private int length$cpu_measured;
	private double logProbability$$evidence;
	private double logProbability$$model;
	private double logProbability$cpu;
	private double logProbability$cpuMean;
	private double logProbability$cpuVar;
	private double logProbability$initialStateDistribution;
	private double logProbability$m;
	private double logProbability$mem;
	private double logProbability$memMean;
	private double logProbability$memVar;
	private double logProbability$pageFaults;
	private double logProbability$pageFaultsMean;
	private double logProbability$pageFaultsVar;
	private double[] logProbability$sample119;
	private double[] logProbability$sample124;
	private double[] logProbability$sample129;
	private double[] logProbability$sample45;
	private double logProbability$st;
	private double logProbability$var100;
	private double logProbability$var105;
	private double[] logProbability$var113;
	private double[] logProbability$var118;
	private double[] logProbability$var123;
	private double logProbability$var17;
	private double logProbability$var22;
	private double logProbability$var26;
	private double logProbability$var29;
	private double logProbability$var30;
	private double[] logProbability$var39;
	private double logProbability$var48;
	private double logProbability$var53;
	private double logProbability$var59;
	private double logProbability$var64;
	private double logProbability$var70;
	private double logProbability$var75;
	private double logProbability$var80;
	private double logProbability$var85;
	private double logProbability$var90;
	private double logProbability$var95;
	private double[][] m;
	private double[] mem;
	private double[] memMean;
	private double[] memVar;
	private double[] mem_measured;
	private int noStates;
	private double[] pageFaults;
	private double[] pageFaultsMean;
	private double[] pageFaultsVar;
	private double[] pageFaults_measured;
	private int samples;
	private boolean setFlag$cpu = false;
	private boolean setFlag$cpuMean = false;
	private boolean setFlag$cpuVar = false;
	private boolean setFlag$initialStateDistribution = false;
	private boolean setFlag$m = false;
	private boolean setFlag$mem = false;
	private boolean setFlag$memMean = false;
	private boolean setFlag$memVar = false;
	private boolean setFlag$pageFaults = false;
	private boolean setFlag$pageFaultsMean = false;
	private boolean setFlag$pageFaultsVar = false;
	private boolean setFlag$st = false;
	private int[] st;
	private boolean system$gibbsForward = true;
	private double[] v;

	public HMMMetrics$SingleThreadCPU(ExecutionTarget target) {
		super(target);
	}

	// Getter for cpu.
	@Override
	public final double[] get$cpu() {
		return cpu;
	}

	// Setter for cpu.
	@Override
	public final void set$cpu(double[] cv$value) {
		// Set flags for all the side effects of cpu including if probabilities need to be
		// updated.
		// Set cpu with flag to mark that it has been set so another array doesn't need to
		// be constructed
		cpu = cv$value;
		setFlag$cpu = true;
		
		// Unset the fixed probability flag for sample 119 as it depends on cpu.
		fixedProbFlag$sample119 = false;
	}

	// Getter for cpuMean.
	@Override
	public final double[] get$cpuMean() {
		return cpuMean;
	}

	// Setter for cpuMean.
	@Override
	public final void set$cpuMean(double[] cv$value) {
		// Set flags for all the side effects of cpuMean including if probabilities need to
		// be updated.
		// Set cpuMean with flag to mark that it has been set so another array doesn't need
		// to be constructed
		cpuMean = cv$value;
		setFlag$cpuMean = true;
		
		// Unset the fixed probability flag for sample 58 as it depends on cpuMean.
		fixedProbFlag$sample58 = false;
		
		// Unset the fixed probability flag for sample 119 as it depends on cpuMean.
		fixedProbFlag$sample119 = false;
	}

	// Getter for cpuVar.
	@Override
	public final double[] get$cpuVar() {
		return cpuVar;
	}

	// Setter for cpuVar.
	@Override
	public final void set$cpuVar(double[] cv$value) {
		// Set flags for all the side effects of cpuVar including if probabilities need to
		// be updated.
		// Set cpuVar with flag to mark that it has been set so another array doesn't need
		// to be constructed
		cpuVar = cv$value;
		setFlag$cpuVar = true;
		
		// Unset the fixed probability flag for sample 90 as it depends on cpuVar.
		fixedProbFlag$sample90 = false;
		
		// Unset the fixed probability flag for sample 119 as it depends on cpuVar.
		fixedProbFlag$sample119 = false;
	}

	// Getter for cpu_measured.
	@Override
	public final double[] get$cpu_measured() {
		return cpu_measured;
	}

	// Setter for cpu_measured.
	@Override
	public final void set$cpu_measured(double[] cv$value) {
		// Set cpu_measured with flag to mark that it has been set so another array doesn't
		// need to be constructed
		cpu_measured = cv$value;
	}

	// Getter for fixedFlag$sample100.
	@Override
	public final boolean get$fixedFlag$sample100() {
		return fixedFlag$sample100;
	}

	// Setter for fixedFlag$sample100.
	@Override
	public final void set$fixedFlag$sample100(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample100 including if probabilities
		// need to be updated.
		fixedFlag$sample100 = cv$value;
		
		// Should the probability of sample 100 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample100 = (fixedFlag$sample100 && fixedProbFlag$sample100);
		
		// Should the probability of sample 124 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample124 = (fixedFlag$sample100 && fixedProbFlag$sample124);
	}

	// Getter for fixedFlag$sample110.
	@Override
	public final boolean get$fixedFlag$sample110() {
		return fixedFlag$sample110;
	}

	// Setter for fixedFlag$sample110.
	@Override
	public final void set$fixedFlag$sample110(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample110 including if probabilities
		// need to be updated.
		fixedFlag$sample110 = cv$value;
		
		// Should the probability of sample 110 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample110 = (fixedFlag$sample110 && fixedProbFlag$sample110);
		
		// Should the probability of sample 129 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample129 = (fixedFlag$sample110 && fixedProbFlag$sample129);
	}

	// Getter for fixedFlag$sample119.
	@Override
	public final boolean get$fixedFlag$sample119() {
		return fixedFlag$sample119;
	}

	// Setter for fixedFlag$sample119.
	@Override
	public final void set$fixedFlag$sample119(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample119 including if probabilities
		// need to be updated.
		fixedFlag$sample119 = cv$value;
		
		// Should the probability of sample 119 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample119 = (fixedFlag$sample119 && fixedProbFlag$sample119);
	}

	// Getter for fixedFlag$sample124.
	@Override
	public final boolean get$fixedFlag$sample124() {
		return fixedFlag$sample124;
	}

	// Setter for fixedFlag$sample124.
	@Override
	public final void set$fixedFlag$sample124(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample124 including if probabilities
		// need to be updated.
		fixedFlag$sample124 = cv$value;
		
		// Should the probability of sample 124 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample124 = (fixedFlag$sample124 && fixedProbFlag$sample124);
	}

	// Getter for fixedFlag$sample129.
	@Override
	public final boolean get$fixedFlag$sample129() {
		return fixedFlag$sample129;
	}

	// Setter for fixedFlag$sample129.
	@Override
	public final void set$fixedFlag$sample129(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample129 including if probabilities
		// need to be updated.
		fixedFlag$sample129 = cv$value;
		
		// Should the probability of sample 129 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample129 = (fixedFlag$sample129 && fixedProbFlag$sample129);
	}

	// Getter for fixedFlag$sample25.
	@Override
	public final boolean get$fixedFlag$sample25() {
		return fixedFlag$sample25;
	}

	// Setter for fixedFlag$sample25.
	@Override
	public final void set$fixedFlag$sample25(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample25 including if probabilities
		// need to be updated.
		fixedFlag$sample25 = cv$value;
		
		// Should the probability of sample 25 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample25 = (fixedFlag$sample25 && fixedProbFlag$sample25);
		
		// Should the probability of sample 45 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample45 = (fixedFlag$sample25 && fixedProbFlag$sample45);
	}

	// Getter for fixedFlag$sample32.
	@Override
	public final boolean get$fixedFlag$sample32() {
		return fixedFlag$sample32;
	}

	// Setter for fixedFlag$sample32.
	@Override
	public final void set$fixedFlag$sample32(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample32 including if probabilities
		// need to be updated.
		fixedFlag$sample32 = cv$value;
		
		// Should the probability of sample 32 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample32 = (fixedFlag$sample32 && fixedProbFlag$sample32);
		
		// Should the probability of sample 35 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample35 = (fixedFlag$sample32 && fixedProbFlag$sample35);
	}

	// Getter for fixedFlag$sample35.
	@Override
	public final boolean get$fixedFlag$sample35() {
		return fixedFlag$sample35;
	}

	// Setter for fixedFlag$sample35.
	@Override
	public final void set$fixedFlag$sample35(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample35 including if probabilities
		// need to be updated.
		fixedFlag$sample35 = cv$value;
		
		// Should the probability of sample 35 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample35 = (fixedFlag$sample35 && fixedProbFlag$sample35);
		
		// Should the probability of sample 45 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample45 = (fixedFlag$sample35 && fixedProbFlag$sample45);
		
		// Should the probability of sample 119 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample119 = (fixedFlag$sample35 && fixedProbFlag$sample119);
		
		// Should the probability of sample 124 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample124 = (fixedFlag$sample35 && fixedProbFlag$sample124);
		
		// Should the probability of sample 129 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample129 = (fixedFlag$sample35 && fixedProbFlag$sample129);
	}

	// Getter for fixedFlag$sample45.
	@Override
	public final boolean get$fixedFlag$sample45() {
		return fixedFlag$sample45;
	}

	// Setter for fixedFlag$sample45.
	@Override
	public final void set$fixedFlag$sample45(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample45 including if probabilities
		// need to be updated.
		fixedFlag$sample45 = cv$value;
		
		// Should the probability of sample 45 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample45 = (fixedFlag$sample45 && fixedProbFlag$sample45);
		
		// Should the probability of sample 119 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample119 = (fixedFlag$sample45 && fixedProbFlag$sample119);
		
		// Should the probability of sample 124 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample124 = (fixedFlag$sample45 && fixedProbFlag$sample124);
		
		// Should the probability of sample 129 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample129 = (fixedFlag$sample45 && fixedProbFlag$sample129);
	}

	// Getter for fixedFlag$sample58.
	@Override
	public final boolean get$fixedFlag$sample58() {
		return fixedFlag$sample58;
	}

	// Setter for fixedFlag$sample58.
	@Override
	public final void set$fixedFlag$sample58(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample58 including if probabilities
		// need to be updated.
		fixedFlag$sample58 = cv$value;
		
		// Should the probability of sample 58 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample58 = (fixedFlag$sample58 && fixedProbFlag$sample58);
		
		// Should the probability of sample 119 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample119 = (fixedFlag$sample58 && fixedProbFlag$sample119);
	}

	// Getter for fixedFlag$sample69.
	@Override
	public final boolean get$fixedFlag$sample69() {
		return fixedFlag$sample69;
	}

	// Setter for fixedFlag$sample69.
	@Override
	public final void set$fixedFlag$sample69(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample69 including if probabilities
		// need to be updated.
		fixedFlag$sample69 = cv$value;
		
		// Should the probability of sample 69 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample69 = (fixedFlag$sample69 && fixedProbFlag$sample69);
		
		// Should the probability of sample 124 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample124 = (fixedFlag$sample69 && fixedProbFlag$sample124);
	}

	// Getter for fixedFlag$sample80.
	@Override
	public final boolean get$fixedFlag$sample80() {
		return fixedFlag$sample80;
	}

	// Setter for fixedFlag$sample80.
	@Override
	public final void set$fixedFlag$sample80(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample80 including if probabilities
		// need to be updated.
		fixedFlag$sample80 = cv$value;
		
		// Should the probability of sample 80 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample80 = (fixedFlag$sample80 && fixedProbFlag$sample80);
		
		// Should the probability of sample 129 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample129 = (fixedFlag$sample80 && fixedProbFlag$sample129);
	}

	// Getter for fixedFlag$sample90.
	@Override
	public final boolean get$fixedFlag$sample90() {
		return fixedFlag$sample90;
	}

	// Setter for fixedFlag$sample90.
	@Override
	public final void set$fixedFlag$sample90(boolean cv$value) {
		// Set flags for all the side effects of fixedFlag$sample90 including if probabilities
		// need to be updated.
		fixedFlag$sample90 = cv$value;
		
		// Should the probability of sample 90 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample90 = (fixedFlag$sample90 && fixedProbFlag$sample90);
		
		// Should the probability of sample 119 be set to fixed. This will only every change
		// the flag to false.
		fixedProbFlag$sample119 = (fixedFlag$sample90 && fixedProbFlag$sample119);
	}

	// Getter for initialStateDistribution.
	@Override
	public final double[] get$initialStateDistribution() {
		return initialStateDistribution;
	}

	// Setter for initialStateDistribution.
	@Override
	public final void set$initialStateDistribution(double[] cv$value) {
		// Set flags for all the side effects of initialStateDistribution including if probabilities
		// need to be updated.
		// Set initialStateDistribution with flag to mark that it has been set so another
		// array doesn't need to be constructed
		initialStateDistribution = cv$value;
		setFlag$initialStateDistribution = true;
		
		// Unset the fixed probability flag for sample 32 as it depends on initialStateDistribution.
		fixedProbFlag$sample32 = false;
		
		// Unset the fixed probability flag for sample 35 as it depends on initialStateDistribution.
		fixedProbFlag$sample35 = false;
	}

	// Getter for length$cpu_measured.
	@Override
	public final int get$length$cpu_measured() {
		return length$cpu_measured;
	}

	// Setter for length$cpu_measured.
	@Override
	public final void set$length$cpu_measured(int cv$value) {
		length$cpu_measured = cv$value;
	}

	// Getter for logProbability$$evidence.
	@Override
	public final double get$logProbability$$evidence() {
		return logProbability$$evidence;
	}

	// Getter for the probability of logProbability$$model.
	@Override
	public final double getCurrentLogProbability() {
		return logProbability$$model;
	}

	// Getter for logProbability$cpu.
	@Override
	public final double get$logProbability$cpu() {
		return logProbability$cpu;
	}

	// Getter for logProbability$cpuMean.
	@Override
	public final double get$logProbability$cpuMean() {
		return logProbability$cpuMean;
	}

	// Getter for logProbability$cpuVar.
	@Override
	public final double get$logProbability$cpuVar() {
		return logProbability$cpuVar;
	}

	// Getter for logProbability$initialStateDistribution.
	@Override
	public final double get$logProbability$initialStateDistribution() {
		return logProbability$initialStateDistribution;
	}

	// Getter for logProbability$m.
	@Override
	public final double get$logProbability$m() {
		return logProbability$m;
	}

	// Getter for logProbability$mem.
	@Override
	public final double get$logProbability$mem() {
		return logProbability$mem;
	}

	// Getter for logProbability$memMean.
	@Override
	public final double get$logProbability$memMean() {
		return logProbability$memMean;
	}

	// Getter for logProbability$memVar.
	@Override
	public final double get$logProbability$memVar() {
		return logProbability$memVar;
	}

	// Getter for logProbability$pageFaults.
	@Override
	public final double get$logProbability$pageFaults() {
		return logProbability$pageFaults;
	}

	// Getter for logProbability$pageFaultsMean.
	@Override
	public final double get$logProbability$pageFaultsMean() {
		return logProbability$pageFaultsMean;
	}

	// Getter for logProbability$pageFaultsVar.
	@Override
	public final double get$logProbability$pageFaultsVar() {
		return logProbability$pageFaultsVar;
	}

	// Getter for logProbability$st.
	@Override
	public final double get$logProbability$st() {
		return logProbability$st;
	}

	// Getter for m.
	@Override
	public final double[][] get$m() {
		return m;
	}

	// Setter for m.
	@Override
	public final void set$m(double[][] cv$value) {
		// Set flags for all the side effects of m including if probabilities need to be updated.
		// Set m with flag to mark that it has been set so another array doesn't need to be
		// constructed
		m = cv$value;
		setFlag$m = true;
		
		// Unset the fixed probability flag for sample 25 as it depends on m.
		fixedProbFlag$sample25 = false;
		
		// Unset the fixed probability flag for sample 45 as it depends on m.
		fixedProbFlag$sample45 = false;
	}

	// Getter for mem.
	@Override
	public final double[] get$mem() {
		return mem;
	}

	// Setter for mem.
	@Override
	public final void set$mem(double[] cv$value) {
		// Set flags for all the side effects of mem including if probabilities need to be
		// updated.
		// Set mem with flag to mark that it has been set so another array doesn't need to
		// be constructed
		mem = cv$value;
		setFlag$mem = true;
		
		// Unset the fixed probability flag for sample 124 as it depends on mem.
		fixedProbFlag$sample124 = false;
	}

	// Getter for memMean.
	@Override
	public final double[] get$memMean() {
		return memMean;
	}

	// Setter for memMean.
	@Override
	public final void set$memMean(double[] cv$value) {
		// Set flags for all the side effects of memMean including if probabilities need to
		// be updated.
		// Set memMean with flag to mark that it has been set so another array doesn't need
		// to be constructed
		memMean = cv$value;
		setFlag$memMean = true;
		
		// Unset the fixed probability flag for sample 69 as it depends on memMean.
		fixedProbFlag$sample69 = false;
		
		// Unset the fixed probability flag for sample 124 as it depends on memMean.
		fixedProbFlag$sample124 = false;
	}

	// Getter for memVar.
	@Override
	public final double[] get$memVar() {
		return memVar;
	}

	// Setter for memVar.
	@Override
	public final void set$memVar(double[] cv$value) {
		// Set flags for all the side effects of memVar including if probabilities need to
		// be updated.
		// Set memVar with flag to mark that it has been set so another array doesn't need
		// to be constructed
		memVar = cv$value;
		setFlag$memVar = true;
		
		// Unset the fixed probability flag for sample 100 as it depends on memVar.
		fixedProbFlag$sample100 = false;
		
		// Unset the fixed probability flag for sample 124 as it depends on memVar.
		fixedProbFlag$sample124 = false;
	}

	// Getter for mem_measured.
	@Override
	public final double[] get$mem_measured() {
		return mem_measured;
	}

	// Setter for mem_measured.
	@Override
	public final void set$mem_measured(double[] cv$value) {
		// Set mem_measured with flag to mark that it has been set so another array doesn't
		// need to be constructed
		mem_measured = cv$value;
	}

	// Getter for noStates.
	@Override
	public final int get$noStates() {
		return noStates;
	}

	// Setter for noStates.
	@Override
	public final void set$noStates(int cv$value) {
		noStates = cv$value;
	}

	// Getter for pageFaults.
	@Override
	public final double[] get$pageFaults() {
		return pageFaults;
	}

	// Setter for pageFaults.
	@Override
	public final void set$pageFaults(double[] cv$value) {
		// Set flags for all the side effects of pageFaults including if probabilities need
		// to be updated.
		// Set pageFaults with flag to mark that it has been set so another array doesn't
		// need to be constructed
		pageFaults = cv$value;
		setFlag$pageFaults = true;
		
		// Unset the fixed probability flag for sample 129 as it depends on pageFaults.
		fixedProbFlag$sample129 = false;
	}

	// Getter for pageFaultsMean.
	@Override
	public final double[] get$pageFaultsMean() {
		return pageFaultsMean;
	}

	// Setter for pageFaultsMean.
	@Override
	public final void set$pageFaultsMean(double[] cv$value) {
		// Set flags for all the side effects of pageFaultsMean including if probabilities
		// need to be updated.
		// Set pageFaultsMean with flag to mark that it has been set so another array doesn't
		// need to be constructed
		pageFaultsMean = cv$value;
		setFlag$pageFaultsMean = true;
		
		// Unset the fixed probability flag for sample 80 as it depends on pageFaultsMean.
		fixedProbFlag$sample80 = false;
		
		// Unset the fixed probability flag for sample 129 as it depends on pageFaultsMean.
		fixedProbFlag$sample129 = false;
	}

	// Getter for pageFaultsVar.
	@Override
	public final double[] get$pageFaultsVar() {
		return pageFaultsVar;
	}

	// Setter for pageFaultsVar.
	@Override
	public final void set$pageFaultsVar(double[] cv$value) {
		// Set flags for all the side effects of pageFaultsVar including if probabilities
		// need to be updated.
		// Set pageFaultsVar with flag to mark that it has been set so another array doesn't
		// need to be constructed
		pageFaultsVar = cv$value;
		setFlag$pageFaultsVar = true;
		
		// Unset the fixed probability flag for sample 110 as it depends on pageFaultsVar.
		fixedProbFlag$sample110 = false;
		
		// Unset the fixed probability flag for sample 129 as it depends on pageFaultsVar.
		fixedProbFlag$sample129 = false;
	}

	// Getter for pageFaults_measured.
	@Override
	public final double[] get$pageFaults_measured() {
		return pageFaults_measured;
	}

	// Setter for pageFaults_measured.
	@Override
	public final void set$pageFaults_measured(double[] cv$value) {
		// Set pageFaults_measured with flag to mark that it has been set so another array
		// doesn't need to be constructed
		pageFaults_measured = cv$value;
	}

	// Getter for samples.
	@Override
	public final int get$samples() {
		return samples;
	}

	// Getter for st.
	@Override
	public final int[] get$st() {
		return st;
	}

	// Setter for st.
	@Override
	public final void set$st(int[] cv$value) {
		// Set flags for all the side effects of st including if probabilities need to be
		// updated.
		// Set st with flag to mark that it has been set so another array doesn't need to
		// be constructed
		st = cv$value;
		setFlag$st = true;
		
		// Unset the fixed probability flag for sample 35 as it depends on st.
		fixedProbFlag$sample35 = false;
		
		// Unset the fixed probability flag for sample 45 as it depends on st.
		fixedProbFlag$sample45 = false;
		
		// Unset the fixed probability flag for sample 119 as it depends on st.
		fixedProbFlag$sample119 = false;
		
		// Unset the fixed probability flag for sample 124 as it depends on st.
		fixedProbFlag$sample124 = false;
		
		// Unset the fixed probability flag for sample 129 as it depends on st.
		fixedProbFlag$sample129 = false;
	}

	// Getter for v.
	@Override
	public final double[] get$v() {
		return v;
	}

	// Calculate the probability of the samples represented by sample119 using probability
	// distributions.
	private final void logProbabilityDistribution$sample119() {
		// Determine if we need to calculate the values for sample task 119 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample119) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				
				// Look for paths between the variable and the sample task 119 including any distribution
				// values.
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = cpu[i$var109];
					
					// Enumerating the possible arguments for Gaussian 113.
					if(fixedFlag$sample35) {
						if((0 == i$var109)) {
							for(int var52 = 0; var52 < noStates; var52 += 1) {
								if((var52 == st[i$var109])) {
									if((0 == i$var109)) {
										for(int var84 = 0; var84 < noStates; var84 += 1) {
											if((var84 == st[i$var109])) {
												{
													double var111 = cpuMean[st[i$var109]];
													double var112 = cpuVar[st[i$var109]];
													
													// Store the value of the function call, so the function call is only made once.
													double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
													
													// Add the probability of this sample task to the distribution accumulator.
													if((cv$weightedProbability < cv$distributionAccumulator))
														cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
													else {
														// If the second value is -infinity.
														if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
															cv$distributionAccumulator = cv$weightedProbability;
														else
															cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
													}
													
													// Add the probability of this distribution configuration to the accumulator.
													cv$probabilityReached = (cv$probabilityReached + 1.0);
												}
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
								int distributionTempVariable$var30$5 = index$sample35$3;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
								int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
								if((0 == i$var109)) {
									for(int var52 = 0; var52 < noStates; var52 += 1) {
										if((var52 == traceTempVariable$s$6_1)) {
											int traceTempVariable$s$10_1 = distributionTempVariable$var30$5;
											if((0 == i$var109)) {
												for(int var84 = 0; var84 < noStates; var84 += 1) {
													if((var84 == traceTempVariable$s$10_1)) {
														{
															double var111 = cpuMean[traceTempVariable$s$10_1];
															double var112 = cpuVar[traceTempVariable$s$10_1];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value4);
														}
													}
												}
											}
											if(!true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$11 = 0; index$sample35$11 < noStates; index$sample35$11 += 1) {
													int distributionTempVariable$var30$13 = index$sample35$11;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value12 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$11]);
													int traceTempVariable$s$14_1 = distributionTempVariable$var30$13;
													if((0 == i$var109)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$14_1)) {
																{
																	double var111 = cpuMean[traceTempVariable$s$14_1];
																	double var112 = cpuVar[traceTempVariable$s$14_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value12) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value12);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 113.
					if(fixedFlag$sample35) {
						if((0 == i$var109)) {
							for(int var52 = 0; var52 < noStates; var52 += 1) {
								if((var52 == st[i$var109])) {
									if(fixedFlag$sample45) {
										for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
											if((i$var34 == i$var109)) {
												for(int var84 = 0; var84 < noStates; var84 += 1) {
													if((var84 == st[i$var109])) {
														{
															double var111 = cpuMean[st[i$var109]];
															double var112 = cpuVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										}
									} else {
										for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
											if(true) {
												// Enumerating the possible outputs of Categorical 39.
												for(int index$sample45$27 = 0; index$sample45$27 < noStates; index$sample45$27 += 1) {
													int distributionTempVariable$var40$29 = index$sample45$27;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample45Value28 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$27]);
													int traceTempVariable$s$30_1 = distributionTempVariable$var40$29;
													if((i$var34 == i$var109)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$30_1)) {
																{
																	double var111 = cpuMean[traceTempVariable$s$30_1];
																	double var112 = cpuVar[traceTempVariable$s$30_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample45Value28) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value28);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$19 = 0; index$sample35$19 < noStates; index$sample35$19 += 1) {
								int distributionTempVariable$var30$21 = index$sample35$19;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value20 = (1.0 * distribution$sample35[index$sample35$19]);
								int traceTempVariable$s$22_1 = distributionTempVariable$var30$21;
								if((0 == i$var109)) {
									for(int var52 = 0; var52 < noStates; var52 += 1) {
										if((var52 == traceTempVariable$s$22_1)) {
											if(fixedFlag$sample45) {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if((i$var34 == i$var109)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$22_1)) {
																{
																	double var111 = cpuMean[traceTempVariable$s$22_1];
																	double var112 = cpuVar[traceTempVariable$s$22_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value20) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value20);
																}
															}
														}
													}
												}
											} else {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if(true) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$33 = 0; index$sample45$33 < noStates; index$sample45$33 += 1) {
															int distributionTempVariable$var40$35 = index$sample45$33;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value34 = (cv$probabilitySample35Value20 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$33]);
															int traceTempVariable$s$36_1 = distributionTempVariable$var40$35;
															if((i$var34 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$36_1)) {
																		{
																			double var111 = cpuMean[traceTempVariable$s$36_1];
																			double var112 = cpuVar[traceTempVariable$s$36_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample45Value34) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value34);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 113.
					if(fixedFlag$sample45) {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((i$var34 == i$var109)) {
								for(int var52 = 0; var52 < noStates; var52 += 1) {
									if((var52 == st[i$var109])) {
										for(int index$i$49_1 = 1; index$i$49_1 < samples; index$i$49_1 += 1) {
											if((index$i$49_1 == i$var109)) {
												for(int var84 = 0; var84 < noStates; var84 += 1) {
													if((var84 == st[i$var109])) {
														{
															double var111 = cpuMean[st[i$var109]];
															double var112 = cpuVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$43 = 0; index$sample45$43 < noStates; index$sample45$43 += 1) {
									int distributionTempVariable$var40$45 = index$sample45$43;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value44 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$43]);
									int traceTempVariable$s$46_1 = distributionTempVariable$var40$45;
									if((i$var34 == i$var109)) {
										for(int var52 = 0; var52 < noStates; var52 += 1) {
											if((var52 == traceTempVariable$s$46_1)) {
												int traceTempVariable$s$50_1 = distributionTempVariable$var40$45;
												if((i$var34 == i$var109)) {
													for(int var84 = 0; var84 < noStates; var84 += 1) {
														if((var84 == traceTempVariable$s$50_1)) {
															{
																double var111 = cpuMean[traceTempVariable$s$50_1];
																double var112 = cpuVar[traceTempVariable$s$50_1];
																
																// Store the value of the function call, so the function call is only made once.
																double cv$weightedProbability = (Math.log(cv$probabilitySample45Value44) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																
																// Add the probability of this sample task to the distribution accumulator.
																if((cv$weightedProbability < cv$distributionAccumulator))
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																else {
																	// If the second value is -infinity.
																	if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																		cv$distributionAccumulator = cv$weightedProbability;
																	else
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																}
																
																// Add the probability of this distribution configuration to the accumulator.
																cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value44);
															}
														}
													}
												}
												for(int index$i$51 = 1; index$i$51 < samples; index$i$51 += 1) {
													if(!(index$i$51 == i$var34)) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$52 = 0; index$sample45$52 < noStates; index$sample45$52 += 1) {
															int distributionTempVariable$var40$54 = index$sample45$52;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value53 = (cv$probabilitySample45Value44 * distribution$sample45[((index$i$51 - 1) / 1)][index$sample45$52]);
															int traceTempVariable$s$55_1 = distributionTempVariable$var40$54;
															if((index$i$51 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$55_1)) {
																		{
																			double var111 = cpuMean[traceTempVariable$s$55_1];
																			double var112 = cpuVar[traceTempVariable$s$55_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample45Value53) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value53);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 113.
					if(fixedFlag$sample45) {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((i$var34 == i$var109)) {
								for(int var52 = 0; var52 < noStates; var52 += 1) {
									if((var52 == st[i$var109])) {
										if(fixedFlag$sample35) {
											if((0 == i$var109)) {
												for(int var84 = 0; var84 < noStates; var84 += 1) {
													if((var84 == st[i$var109])) {
														{
															double var111 = cpuMean[st[i$var109]];
															double var112 = cpuVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										} else {
											if(true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$68 = 0; index$sample35$68 < noStates; index$sample35$68 += 1) {
													int distributionTempVariable$var30$70 = index$sample35$68;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value69 = (1.0 * distribution$sample35[index$sample35$68]);
													int traceTempVariable$s$71_1 = distributionTempVariable$var30$70;
													if((0 == i$var109)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$71_1)) {
																{
																	double var111 = cpuMean[traceTempVariable$s$71_1];
																	double var112 = cpuVar[traceTempVariable$s$71_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value69) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value69);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$61 = 0; index$sample45$61 < noStates; index$sample45$61 += 1) {
									int distributionTempVariable$var40$63 = index$sample45$61;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value62 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$61]);
									int traceTempVariable$s$64_1 = distributionTempVariable$var40$63;
									if((i$var34 == i$var109)) {
										for(int var52 = 0; var52 < noStates; var52 += 1) {
											if((var52 == traceTempVariable$s$64_1)) {
												if(fixedFlag$sample35) {
													if((0 == i$var109)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$64_1)) {
																{
																	double var111 = cpuMean[traceTempVariable$s$64_1];
																	double var112 = cpuVar[traceTempVariable$s$64_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample45Value62) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value62);
																}
															}
														}
													}
												} else {
													if(true) {
														// Enumerating the possible outputs of Categorical 29.
														for(int index$sample35$73 = 0; index$sample35$73 < noStates; index$sample35$73 += 1) {
															int distributionTempVariable$var30$75 = index$sample35$73;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample35Value74 = (cv$probabilitySample45Value62 * distribution$sample35[index$sample35$73]);
															int traceTempVariable$s$76_1 = distributionTempVariable$var30$75;
															if((0 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$76_1)) {
																		{
																			double var111 = cpuMean[traceTempVariable$s$76_1];
																			double var112 = cpuVar[traceTempVariable$s$76_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample35Value74) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value74);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var113[((i$var109 - 0) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample119[((i$var109 - 0) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$cpu = (logProbability$cpu + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample119 = ((((fixedFlag$sample119 && fixedFlag$sample35) && fixedFlag$sample45) && fixedFlag$sample58) && fixedFlag$sample90);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample119[((i$var109 - 0) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var113[((i$var109 - 0) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$cpu = (logProbability$cpu + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample124 using probability
	// distributions.
	private final void logProbabilityDistribution$sample124() {
		// Determine if we need to calculate the values for sample task 124 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample124) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				
				// Look for paths between the variable and the sample task 124 including any distribution
				// values.
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = mem[i$var109];
					
					// Enumerating the possible arguments for Gaussian 118.
					if(fixedFlag$sample35) {
						if((0 == i$var109)) {
							for(int var63 = 0; var63 < noStates; var63 += 1) {
								if((var63 == st[i$var109])) {
									if((0 == i$var109)) {
										for(int var94 = 0; var94 < noStates; var94 += 1) {
											if((var94 == st[i$var109])) {
												{
													double var116 = memMean[st[i$var109]];
													double var117 = memVar[st[i$var109]];
													
													// Store the value of the function call, so the function call is only made once.
													double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
													
													// Add the probability of this sample task to the distribution accumulator.
													if((cv$weightedProbability < cv$distributionAccumulator))
														cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
													else {
														// If the second value is -infinity.
														if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
															cv$distributionAccumulator = cv$weightedProbability;
														else
															cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
													}
													
													// Add the probability of this distribution configuration to the accumulator.
													cv$probabilityReached = (cv$probabilityReached + 1.0);
												}
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
								int distributionTempVariable$var30$5 = index$sample35$3;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
								int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
								if((0 == i$var109)) {
									for(int var63 = 0; var63 < noStates; var63 += 1) {
										if((var63 == traceTempVariable$s$6_1)) {
											int traceTempVariable$s$10_1 = distributionTempVariable$var30$5;
											if((0 == i$var109)) {
												for(int var94 = 0; var94 < noStates; var94 += 1) {
													if((var94 == traceTempVariable$s$10_1)) {
														{
															double var116 = memMean[traceTempVariable$s$10_1];
															double var117 = memVar[traceTempVariable$s$10_1];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value4);
														}
													}
												}
											}
											if(!true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$11 = 0; index$sample35$11 < noStates; index$sample35$11 += 1) {
													int distributionTempVariable$var30$13 = index$sample35$11;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value12 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$11]);
													int traceTempVariable$s$14_1 = distributionTempVariable$var30$13;
													if((0 == i$var109)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$14_1)) {
																{
																	double var116 = memMean[traceTempVariable$s$14_1];
																	double var117 = memVar[traceTempVariable$s$14_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value12) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value12);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 118.
					if(fixedFlag$sample35) {
						if((0 == i$var109)) {
							for(int var63 = 0; var63 < noStates; var63 += 1) {
								if((var63 == st[i$var109])) {
									if(fixedFlag$sample45) {
										for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
											if((i$var34 == i$var109)) {
												for(int var94 = 0; var94 < noStates; var94 += 1) {
													if((var94 == st[i$var109])) {
														{
															double var116 = memMean[st[i$var109]];
															double var117 = memVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										}
									} else {
										for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
											if(true) {
												// Enumerating the possible outputs of Categorical 39.
												for(int index$sample45$27 = 0; index$sample45$27 < noStates; index$sample45$27 += 1) {
													int distributionTempVariable$var40$29 = index$sample45$27;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample45Value28 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$27]);
													int traceTempVariable$s$30_1 = distributionTempVariable$var40$29;
													if((i$var34 == i$var109)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$30_1)) {
																{
																	double var116 = memMean[traceTempVariable$s$30_1];
																	double var117 = memVar[traceTempVariable$s$30_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample45Value28) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value28);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$19 = 0; index$sample35$19 < noStates; index$sample35$19 += 1) {
								int distributionTempVariable$var30$21 = index$sample35$19;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value20 = (1.0 * distribution$sample35[index$sample35$19]);
								int traceTempVariable$s$22_1 = distributionTempVariable$var30$21;
								if((0 == i$var109)) {
									for(int var63 = 0; var63 < noStates; var63 += 1) {
										if((var63 == traceTempVariable$s$22_1)) {
											if(fixedFlag$sample45) {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if((i$var34 == i$var109)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$22_1)) {
																{
																	double var116 = memMean[traceTempVariable$s$22_1];
																	double var117 = memVar[traceTempVariable$s$22_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value20) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value20);
																}
															}
														}
													}
												}
											} else {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if(true) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$33 = 0; index$sample45$33 < noStates; index$sample45$33 += 1) {
															int distributionTempVariable$var40$35 = index$sample45$33;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value34 = (cv$probabilitySample35Value20 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$33]);
															int traceTempVariable$s$36_1 = distributionTempVariable$var40$35;
															if((i$var34 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$36_1)) {
																		{
																			double var116 = memMean[traceTempVariable$s$36_1];
																			double var117 = memVar[traceTempVariable$s$36_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample45Value34) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value34);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 118.
					if(fixedFlag$sample45) {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((i$var34 == i$var109)) {
								for(int var63 = 0; var63 < noStates; var63 += 1) {
									if((var63 == st[i$var109])) {
										for(int index$i$49_1 = 1; index$i$49_1 < samples; index$i$49_1 += 1) {
											if((index$i$49_1 == i$var109)) {
												for(int var94 = 0; var94 < noStates; var94 += 1) {
													if((var94 == st[i$var109])) {
														{
															double var116 = memMean[st[i$var109]];
															double var117 = memVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$43 = 0; index$sample45$43 < noStates; index$sample45$43 += 1) {
									int distributionTempVariable$var40$45 = index$sample45$43;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value44 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$43]);
									int traceTempVariable$s$46_1 = distributionTempVariable$var40$45;
									if((i$var34 == i$var109)) {
										for(int var63 = 0; var63 < noStates; var63 += 1) {
											if((var63 == traceTempVariable$s$46_1)) {
												int traceTempVariable$s$50_1 = distributionTempVariable$var40$45;
												if((i$var34 == i$var109)) {
													for(int var94 = 0; var94 < noStates; var94 += 1) {
														if((var94 == traceTempVariable$s$50_1)) {
															{
																double var116 = memMean[traceTempVariable$s$50_1];
																double var117 = memVar[traceTempVariable$s$50_1];
																
																// Store the value of the function call, so the function call is only made once.
																double cv$weightedProbability = (Math.log(cv$probabilitySample45Value44) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																
																// Add the probability of this sample task to the distribution accumulator.
																if((cv$weightedProbability < cv$distributionAccumulator))
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																else {
																	// If the second value is -infinity.
																	if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																		cv$distributionAccumulator = cv$weightedProbability;
																	else
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																}
																
																// Add the probability of this distribution configuration to the accumulator.
																cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value44);
															}
														}
													}
												}
												for(int index$i$51 = 1; index$i$51 < samples; index$i$51 += 1) {
													if(!(index$i$51 == i$var34)) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$52 = 0; index$sample45$52 < noStates; index$sample45$52 += 1) {
															int distributionTempVariable$var40$54 = index$sample45$52;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value53 = (cv$probabilitySample45Value44 * distribution$sample45[((index$i$51 - 1) / 1)][index$sample45$52]);
															int traceTempVariable$s$55_1 = distributionTempVariable$var40$54;
															if((index$i$51 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$55_1)) {
																		{
																			double var116 = memMean[traceTempVariable$s$55_1];
																			double var117 = memVar[traceTempVariable$s$55_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample45Value53) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value53);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 118.
					if(fixedFlag$sample45) {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((i$var34 == i$var109)) {
								for(int var63 = 0; var63 < noStates; var63 += 1) {
									if((var63 == st[i$var109])) {
										if(fixedFlag$sample35) {
											if((0 == i$var109)) {
												for(int var94 = 0; var94 < noStates; var94 += 1) {
													if((var94 == st[i$var109])) {
														{
															double var116 = memMean[st[i$var109]];
															double var117 = memVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										} else {
											if(true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$68 = 0; index$sample35$68 < noStates; index$sample35$68 += 1) {
													int distributionTempVariable$var30$70 = index$sample35$68;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value69 = (1.0 * distribution$sample35[index$sample35$68]);
													int traceTempVariable$s$71_1 = distributionTempVariable$var30$70;
													if((0 == i$var109)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$71_1)) {
																{
																	double var116 = memMean[traceTempVariable$s$71_1];
																	double var117 = memVar[traceTempVariable$s$71_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value69) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value69);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$61 = 0; index$sample45$61 < noStates; index$sample45$61 += 1) {
									int distributionTempVariable$var40$63 = index$sample45$61;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value62 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$61]);
									int traceTempVariable$s$64_1 = distributionTempVariable$var40$63;
									if((i$var34 == i$var109)) {
										for(int var63 = 0; var63 < noStates; var63 += 1) {
											if((var63 == traceTempVariable$s$64_1)) {
												if(fixedFlag$sample35) {
													if((0 == i$var109)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$64_1)) {
																{
																	double var116 = memMean[traceTempVariable$s$64_1];
																	double var117 = memVar[traceTempVariable$s$64_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample45Value62) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value62);
																}
															}
														}
													}
												} else {
													if(true) {
														// Enumerating the possible outputs of Categorical 29.
														for(int index$sample35$73 = 0; index$sample35$73 < noStates; index$sample35$73 += 1) {
															int distributionTempVariable$var30$75 = index$sample35$73;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample35Value74 = (cv$probabilitySample45Value62 * distribution$sample35[index$sample35$73]);
															int traceTempVariable$s$76_1 = distributionTempVariable$var30$75;
															if((0 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$76_1)) {
																		{
																			double var116 = memMean[traceTempVariable$s$76_1];
																			double var117 = memVar[traceTempVariable$s$76_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample35Value74) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value74);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var118[((i$var109 - 0) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample124[((i$var109 - 0) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$mem = (logProbability$mem + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample124 = ((((fixedFlag$sample124 && fixedFlag$sample35) && fixedFlag$sample45) && fixedFlag$sample69) && fixedFlag$sample100);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample124[((i$var109 - 0) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var118[((i$var109 - 0) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$mem = (logProbability$mem + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample129 using probability
	// distributions.
	private final void logProbabilityDistribution$sample129() {
		// Determine if we need to calculate the values for sample task 129 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample129) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				
				// Look for paths between the variable and the sample task 129 including any distribution
				// values.
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = pageFaults[i$var109];
					
					// Enumerating the possible arguments for Gaussian 123.
					if(fixedFlag$sample35) {
						if((0 == i$var109)) {
							for(int var74 = 0; var74 < noStates; var74 += 1) {
								if((var74 == st[i$var109])) {
									if((0 == i$var109)) {
										for(int var104 = 0; var104 < noStates; var104 += 1) {
											if((var104 == st[i$var109])) {
												{
													double var121 = pageFaultsMean[st[i$var109]];
													double var122 = pageFaultsVar[st[i$var109]];
													
													// Store the value of the function call, so the function call is only made once.
													double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
													
													// Add the probability of this sample task to the distribution accumulator.
													if((cv$weightedProbability < cv$distributionAccumulator))
														cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
													else {
														// If the second value is -infinity.
														if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
															cv$distributionAccumulator = cv$weightedProbability;
														else
															cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
													}
													
													// Add the probability of this distribution configuration to the accumulator.
													cv$probabilityReached = (cv$probabilityReached + 1.0);
												}
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
								int distributionTempVariable$var30$5 = index$sample35$3;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
								int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
								if((0 == i$var109)) {
									for(int var74 = 0; var74 < noStates; var74 += 1) {
										if((var74 == traceTempVariable$s$6_1)) {
											int traceTempVariable$s$10_1 = distributionTempVariable$var30$5;
											if((0 == i$var109)) {
												for(int var104 = 0; var104 < noStates; var104 += 1) {
													if((var104 == traceTempVariable$s$10_1)) {
														{
															double var121 = pageFaultsMean[traceTempVariable$s$10_1];
															double var122 = pageFaultsVar[traceTempVariable$s$10_1];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value4);
														}
													}
												}
											}
											if(!true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$11 = 0; index$sample35$11 < noStates; index$sample35$11 += 1) {
													int distributionTempVariable$var30$13 = index$sample35$11;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value12 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$11]);
													int traceTempVariable$s$14_1 = distributionTempVariable$var30$13;
													if((0 == i$var109)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$14_1)) {
																{
																	double var121 = pageFaultsMean[traceTempVariable$s$14_1];
																	double var122 = pageFaultsVar[traceTempVariable$s$14_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value12) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value12);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 123.
					if(fixedFlag$sample35) {
						if((0 == i$var109)) {
							for(int var74 = 0; var74 < noStates; var74 += 1) {
								if((var74 == st[i$var109])) {
									if(fixedFlag$sample45) {
										for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
											if((i$var34 == i$var109)) {
												for(int var104 = 0; var104 < noStates; var104 += 1) {
													if((var104 == st[i$var109])) {
														{
															double var121 = pageFaultsMean[st[i$var109]];
															double var122 = pageFaultsVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										}
									} else {
										for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
											if(true) {
												// Enumerating the possible outputs of Categorical 39.
												for(int index$sample45$27 = 0; index$sample45$27 < noStates; index$sample45$27 += 1) {
													int distributionTempVariable$var40$29 = index$sample45$27;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample45Value28 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$27]);
													int traceTempVariable$s$30_1 = distributionTempVariable$var40$29;
													if((i$var34 == i$var109)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$30_1)) {
																{
																	double var121 = pageFaultsMean[traceTempVariable$s$30_1];
																	double var122 = pageFaultsVar[traceTempVariable$s$30_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample45Value28) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value28);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$19 = 0; index$sample35$19 < noStates; index$sample35$19 += 1) {
								int distributionTempVariable$var30$21 = index$sample35$19;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value20 = (1.0 * distribution$sample35[index$sample35$19]);
								int traceTempVariable$s$22_1 = distributionTempVariable$var30$21;
								if((0 == i$var109)) {
									for(int var74 = 0; var74 < noStates; var74 += 1) {
										if((var74 == traceTempVariable$s$22_1)) {
											if(fixedFlag$sample45) {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if((i$var34 == i$var109)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$22_1)) {
																{
																	double var121 = pageFaultsMean[traceTempVariable$s$22_1];
																	double var122 = pageFaultsVar[traceTempVariable$s$22_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value20) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value20);
																}
															}
														}
													}
												}
											} else {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if(true) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$33 = 0; index$sample45$33 < noStates; index$sample45$33 += 1) {
															int distributionTempVariable$var40$35 = index$sample45$33;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value34 = (cv$probabilitySample35Value20 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$33]);
															int traceTempVariable$s$36_1 = distributionTempVariable$var40$35;
															if((i$var34 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$36_1)) {
																		{
																			double var121 = pageFaultsMean[traceTempVariable$s$36_1];
																			double var122 = pageFaultsVar[traceTempVariable$s$36_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample45Value34) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value34);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 123.
					if(fixedFlag$sample45) {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((i$var34 == i$var109)) {
								for(int var74 = 0; var74 < noStates; var74 += 1) {
									if((var74 == st[i$var109])) {
										for(int index$i$49_1 = 1; index$i$49_1 < samples; index$i$49_1 += 1) {
											if((index$i$49_1 == i$var109)) {
												for(int var104 = 0; var104 < noStates; var104 += 1) {
													if((var104 == st[i$var109])) {
														{
															double var121 = pageFaultsMean[st[i$var109]];
															double var122 = pageFaultsVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$43 = 0; index$sample45$43 < noStates; index$sample45$43 += 1) {
									int distributionTempVariable$var40$45 = index$sample45$43;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value44 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$43]);
									int traceTempVariable$s$46_1 = distributionTempVariable$var40$45;
									if((i$var34 == i$var109)) {
										for(int var74 = 0; var74 < noStates; var74 += 1) {
											if((var74 == traceTempVariable$s$46_1)) {
												int traceTempVariable$s$50_1 = distributionTempVariable$var40$45;
												if((i$var34 == i$var109)) {
													for(int var104 = 0; var104 < noStates; var104 += 1) {
														if((var104 == traceTempVariable$s$50_1)) {
															{
																double var121 = pageFaultsMean[traceTempVariable$s$50_1];
																double var122 = pageFaultsVar[traceTempVariable$s$50_1];
																
																// Store the value of the function call, so the function call is only made once.
																double cv$weightedProbability = (Math.log(cv$probabilitySample45Value44) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																
																// Add the probability of this sample task to the distribution accumulator.
																if((cv$weightedProbability < cv$distributionAccumulator))
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																else {
																	// If the second value is -infinity.
																	if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																		cv$distributionAccumulator = cv$weightedProbability;
																	else
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																}
																
																// Add the probability of this distribution configuration to the accumulator.
																cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value44);
															}
														}
													}
												}
												for(int index$i$51 = 1; index$i$51 < samples; index$i$51 += 1) {
													if(!(index$i$51 == i$var34)) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$52 = 0; index$sample45$52 < noStates; index$sample45$52 += 1) {
															int distributionTempVariable$var40$54 = index$sample45$52;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value53 = (cv$probabilitySample45Value44 * distribution$sample45[((index$i$51 - 1) / 1)][index$sample45$52]);
															int traceTempVariable$s$55_1 = distributionTempVariable$var40$54;
															if((index$i$51 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$55_1)) {
																		{
																			double var121 = pageFaultsMean[traceTempVariable$s$55_1];
																			double var122 = pageFaultsVar[traceTempVariable$s$55_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample45Value53) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value53);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					
					// Enumerating the possible arguments for Gaussian 123.
					if(fixedFlag$sample45) {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((i$var34 == i$var109)) {
								for(int var74 = 0; var74 < noStates; var74 += 1) {
									if((var74 == st[i$var109])) {
										if(fixedFlag$sample35) {
											if((0 == i$var109)) {
												for(int var104 = 0; var104 < noStates; var104 += 1) {
													if((var104 == st[i$var109])) {
														{
															double var121 = pageFaultsMean[st[i$var109]];
															double var122 = pageFaultsVar[st[i$var109]];
															
															// Store the value of the function call, so the function call is only made once.
															double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
															
															// Add the probability of this sample task to the distribution accumulator.
															if((cv$weightedProbability < cv$distributionAccumulator))
																cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
															else {
																// If the second value is -infinity.
																if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																	cv$distributionAccumulator = cv$weightedProbability;
																else
																	cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
															}
															
															// Add the probability of this distribution configuration to the accumulator.
															cv$probabilityReached = (cv$probabilityReached + 1.0);
														}
													}
												}
											}
										} else {
											if(true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$68 = 0; index$sample35$68 < noStates; index$sample35$68 += 1) {
													int distributionTempVariable$var30$70 = index$sample35$68;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value69 = (1.0 * distribution$sample35[index$sample35$68]);
													int traceTempVariable$s$71_1 = distributionTempVariable$var30$70;
													if((0 == i$var109)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$71_1)) {
																{
																	double var121 = pageFaultsMean[traceTempVariable$s$71_1];
																	double var122 = pageFaultsVar[traceTempVariable$s$71_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample35Value69) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value69);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$61 = 0; index$sample45$61 < noStates; index$sample45$61 += 1) {
									int distributionTempVariable$var40$63 = index$sample45$61;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value62 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$61]);
									int traceTempVariable$s$64_1 = distributionTempVariable$var40$63;
									if((i$var34 == i$var109)) {
										for(int var74 = 0; var74 < noStates; var74 += 1) {
											if((var74 == traceTempVariable$s$64_1)) {
												if(fixedFlag$sample35) {
													if((0 == i$var109)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$64_1)) {
																{
																	double var121 = pageFaultsMean[traceTempVariable$s$64_1];
																	double var122 = pageFaultsVar[traceTempVariable$s$64_1];
																	
																	// Store the value of the function call, so the function call is only made once.
																	double cv$weightedProbability = (Math.log(cv$probabilitySample45Value62) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																	
																	// Add the probability of this sample task to the distribution accumulator.
																	if((cv$weightedProbability < cv$distributionAccumulator))
																		cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																	else {
																		// If the second value is -infinity.
																		if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																			cv$distributionAccumulator = cv$weightedProbability;
																		else
																			cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																	}
																	
																	// Add the probability of this distribution configuration to the accumulator.
																	cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value62);
																}
															}
														}
													}
												} else {
													if(true) {
														// Enumerating the possible outputs of Categorical 29.
														for(int index$sample35$73 = 0; index$sample35$73 < noStates; index$sample35$73 += 1) {
															int distributionTempVariable$var30$75 = index$sample35$73;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample35Value74 = (cv$probabilitySample45Value62 * distribution$sample35[index$sample35$73]);
															int traceTempVariable$s$76_1 = distributionTempVariable$var30$75;
															if((0 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$76_1)) {
																		{
																			double var121 = pageFaultsMean[traceTempVariable$s$76_1];
																			double var122 = pageFaultsVar[traceTempVariable$s$76_1];
																			
																			// Store the value of the function call, so the function call is only made once.
																			double cv$weightedProbability = (Math.log(cv$probabilitySample35Value74) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
																			
																			// Add the probability of this sample task to the distribution accumulator.
																			if((cv$weightedProbability < cv$distributionAccumulator))
																				cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
																			else {
																				// If the second value is -infinity.
																				if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																					cv$distributionAccumulator = cv$weightedProbability;
																				else
																					cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
																			}
																			
																			// Add the probability of this distribution configuration to the accumulator.
																			cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value74);
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var123[((i$var109 - 0) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample129[((i$var109 - 0) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$pageFaults = (logProbability$pageFaults + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample129 = ((((fixedFlag$sample129 && fixedFlag$sample35) && fixedFlag$sample45) && fixedFlag$sample80) && fixedFlag$sample110);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample129[((i$var109 - 0) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var123[((i$var109 - 0) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$pageFaults = (logProbability$pageFaults + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample35 using probability
	// distributions.
	private final void logProbabilityDistribution$sample35() {
		// Determine if we need to calculate the values for sample task 35 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample35) {
			// Update the probability if the distribution is fixed to a specific value. If it
			// is not the value is implicitly log(1.0) so has no effect.
			if(fixedFlag$sample35) {
				// Generating probabilities for sample task
				// Accumulator for probabilities of instances of the random variable
				double cv$accumulator = 0.0;
				
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					int cv$sampleValue = st[0];
					{
						{
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < initialStateDistribution.length))?Math.log(initialStateDistribution[cv$sampleValue]):Double.NEGATIVE_INFINITY));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var29 = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$var30 = cv$sampleProbability;
				
				// Make sure all the inputs have been fixed so the variable is not a distribution.
				if(fixedFlag$sample35)
					// Update the variable probability
					logProbability$st = (logProbability$st + cv$accumulator);
				
				// Add probability to model
				logProbability$$model = (logProbability$$model + cv$accumulator);
				
				// If this value is fixed, add it to the probability of this model producing the fixed
				// values
				if(fixedFlag$sample35)
					logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
				
				// Now the probability is calculated store if it can be cached or if it needs to be
				// recalculated next time.
				fixedProbFlag$sample35 = (fixedFlag$sample35 && fixedFlag$sample32);
			}
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var30;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var29 = cv$rvAccumulator;
			
			// Make sure all the inputs have been fixed so the variable is not a distribution.
			if(fixedFlag$sample35)
				// Update the variable probability
				logProbability$st = (logProbability$st + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample35)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample45 using probability
	// distributions.
	private final void logProbabilityDistribution$sample45() {
		// Determine if we need to calculate the values for sample task 45 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample45) {
			// Update the probability if the distribution is fixed to a specific value. If it
			// is not the value is implicitly log(1.0) so has no effect.
			if(fixedFlag$sample45) {
				// Generating probabilities for sample task
				// Accumulator for probabilities of instances of the random variable
				double cv$accumulator = 0.0;
				for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
					// Accumulator for sample probabilities for a specific instance of the random variable.
					double cv$sampleAccumulator = 0.0;
					
					// An accumulator for log probabilities.
					double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
					
					// An accumulator for the distributed probability space covered.
					double cv$probabilityReached = 0.0;
					
					// Look for paths between the variable and the sample task 45 including any distribution
					// values.
					// 
					// Copy of index so that its values can be safely substituted
					int index$i$1 = i$var34;
					{
						// The sample value to calculate the probability of generating
						int cv$sampleValue = st[i$var34];
						
						// Enumerating the possible arguments for Categorical 39.
						if(fixedFlag$sample35) {
							if((0 == (i$var34 - 1))) {
								for(int var21 = 0; var21 < noStates; var21 += 1) {
									if((var21 == st[(i$var34 - 1)])) {
										{
											double[] var38 = m[st[(i$var34 - 1)]];
											
											// Store the value of the function call, so the function call is only made once.
											double cv$weightedProbability = (Math.log(1.0) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < var38.length))?Math.log(var38[cv$sampleValue]):Double.NEGATIVE_INFINITY));
											
											// Add the probability of this sample task to the distribution accumulator.
											if((cv$weightedProbability < cv$distributionAccumulator))
												cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
											else {
												// If the second value is -infinity.
												if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
													cv$distributionAccumulator = cv$weightedProbability;
												else
													cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
											}
											
											// Add the probability of this distribution configuration to the accumulator.
											cv$probabilityReached = (cv$probabilityReached + 1.0);
										}
									}
								}
							}
						} else {
							if(true) {
								// Enumerating the possible outputs of Categorical 29.
								for(int index$sample35$4 = 0; index$sample35$4 < noStates; index$sample35$4 += 1) {
									int distributionTempVariable$var30$6 = index$sample35$4;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample35Value5 = (1.0 * distribution$sample35[index$sample35$4]);
									int traceTempVariable$var37$7_1 = distributionTempVariable$var30$6;
									if((0 == (i$var34 - 1))) {
										for(int var21 = 0; var21 < noStates; var21 += 1) {
											if((var21 == traceTempVariable$var37$7_1)) {
												{
													double[] var38 = m[traceTempVariable$var37$7_1];
													
													// Store the value of the function call, so the function call is only made once.
													double cv$weightedProbability = (Math.log(cv$probabilitySample35Value5) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < var38.length))?Math.log(var38[cv$sampleValue]):Double.NEGATIVE_INFINITY));
													
													// Add the probability of this sample task to the distribution accumulator.
													if((cv$weightedProbability < cv$distributionAccumulator))
														cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
													else {
														// If the second value is -infinity.
														if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
															cv$distributionAccumulator = cv$weightedProbability;
														else
															cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
													}
													
													// Add the probability of this distribution configuration to the accumulator.
													cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample35Value5);
												}
											}
										}
									}
								}
							}
						}
						
						// Enumerating the possible arguments for Categorical 39.
						int traceTempVariable$var37$10_1 = DistributionSampling.sampleCategorical(RNG$, m[st[(index$i$1 - 1)]]);
						if((index$i$1 == (i$var34 - 1))) {
							for(int var21 = 0; var21 < noStates; var21 += 1) {
								if((var21 == traceTempVariable$var37$10_1)) {
									{
										double[] var38 = m[traceTempVariable$var37$10_1];
										
										// Store the value of the function call, so the function call is only made once.
										double cv$weightedProbability = (Math.log(1.0) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < var38.length))?Math.log(var38[cv$sampleValue]):Double.NEGATIVE_INFINITY));
										
										// Add the probability of this sample task to the distribution accumulator.
										if((cv$weightedProbability < cv$distributionAccumulator))
											cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
										else {
											// If the second value is -infinity.
											if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
												cv$distributionAccumulator = cv$weightedProbability;
											else
												cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
										}
										
										// Add the probability of this distribution configuration to the accumulator.
										cv$probabilityReached = (cv$probabilityReached + 1.0);
									}
								}
							}
						}
						if(fixedFlag$sample45) {
							for(int index$i$11_1 = 1; index$i$11_1 < samples; index$i$11_1 += 1) {
								if((index$i$11_1 == (i$var34 - 1))) {
									for(int var21 = 0; var21 < noStates; var21 += 1) {
										if((var21 == st[(i$var34 - 1)])) {
											{
												double[] var38 = m[st[(i$var34 - 1)]];
												
												// Store the value of the function call, so the function call is only made once.
												double cv$weightedProbability = (Math.log(1.0) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < var38.length))?Math.log(var38[cv$sampleValue]):Double.NEGATIVE_INFINITY));
												
												// Add the probability of this sample task to the distribution accumulator.
												if((cv$weightedProbability < cv$distributionAccumulator))
													cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
												else {
													// If the second value is -infinity.
													if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
														cv$distributionAccumulator = cv$weightedProbability;
													else
														cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
												}
												
												// Add the probability of this distribution configuration to the accumulator.
												cv$probabilityReached = (cv$probabilityReached + 1.0);
											}
										}
									}
								}
							}
						} else {
							for(int index$i$12 = 1; index$i$12 < samples; index$i$12 += 1) {
								if(!(index$i$12 == index$i$1)) {
									// Enumerating the possible outputs of Categorical 39.
									for(int index$sample45$13 = 0; index$sample45$13 < noStates; index$sample45$13 += 1) {
										int distributionTempVariable$var40$15 = index$sample45$13;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample45Value14 = (1.0 * distribution$sample45[((index$i$12 - 1) / 1)][index$sample45$13]);
										int traceTempVariable$var37$16_1 = distributionTempVariable$var40$15;
										if((index$i$12 == (i$var34 - 1))) {
											for(int var21 = 0; var21 < noStates; var21 += 1) {
												if((var21 == traceTempVariable$var37$16_1)) {
													{
														double[] var38 = m[traceTempVariable$var37$16_1];
														
														// Store the value of the function call, so the function call is only made once.
														double cv$weightedProbability = (Math.log(cv$probabilitySample45Value14) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < var38.length))?Math.log(var38[cv$sampleValue]):Double.NEGATIVE_INFINITY));
														
														// Add the probability of this sample task to the distribution accumulator.
														if((cv$weightedProbability < cv$distributionAccumulator))
															cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
														else {
															// If the second value is -infinity.
															if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
																cv$distributionAccumulator = cv$weightedProbability;
															else
																cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
														}
														
														// Add the probability of this distribution configuration to the accumulator.
														cv$probabilityReached = (cv$probabilityReached + cv$probabilitySample45Value14);
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if((cv$probabilityReached == 0.0))
						// Return negative infinity if no distribution probability space is reached.
						cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
					else
						// Scale the probability relative to the observed distribution space.
						cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
					double cv$sampleProbability = cv$distributionAccumulator;
					
					// Add the probability of this sample task to the sample task accumulator.
					cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
					
					// Add the probability of this instance of the random variable to the probability
					// of all instances of the random variable.
					cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
					logProbability$var39[((i$var34 - 1) / 1)] = cv$sampleAccumulator;
					
					// Store the sample task probability
					logProbability$sample45[((i$var34 - 1) / 1)] = cv$sampleProbability;
				}
				
				// Make sure all the inputs have been fixed so the variable is not a distribution.
				if(fixedFlag$sample45)
					// Update the variable probability
					logProbability$st = (logProbability$st + cv$accumulator);
				
				// Add probability to model
				logProbability$$model = (logProbability$$model + cv$accumulator);
				
				// If this value is fixed, add it to the probability of this model producing the fixed
				// values
				if(fixedFlag$sample45)
					logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
				
				// Now the probability is calculated store if it can be cached or if it needs to be
				// recalculated next time.
				fixedProbFlag$sample45 = ((fixedFlag$sample45 && fixedFlag$sample25) && fixedFlag$sample35);
			}
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample45[((i$var34 - 1) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var39[((i$var34 - 1) / 1)] = cv$rvAccumulator;
			}
			
			// Make sure all the inputs have been fixed so the variable is not a distribution.
			if(fixedFlag$sample45)
				// Update the variable probability
				logProbability$st = (logProbability$st + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample45)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample100 using sampled
	// values.
	private final void logProbabilityValue$sample100() {
		// Determine if we need to calculate the values for sample task 100 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample100) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var94 = 0; var94 < noStates; var94 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = memVar[var94];
					{
						{
							double var89 = 5.0;
							double var88 = 0.5;
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + DistributionSampling.logProbabilityInverseGamma(cv$sampleValue, var89, var88));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var90 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var95 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$memVar = (logProbability$memVar + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample100)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample100 = fixedFlag$sample100;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var95;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var90 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$memVar = (logProbability$memVar + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample100)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample110 using sampled
	// values.
	private final void logProbabilityValue$sample110() {
		// Determine if we need to calculate the values for sample task 110 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample110) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var104 = 0; var104 < noStates; var104 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = pageFaultsVar[var104];
					{
						{
							double var99 = 5.0;
							double var98 = 0.5;
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + DistributionSampling.logProbabilityInverseGamma(cv$sampleValue, var99, var98));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var100 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var105 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$pageFaultsVar = (logProbability$pageFaultsVar + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample110)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample110 = fixedFlag$sample110;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var105;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var100 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$pageFaultsVar = (logProbability$pageFaultsVar + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample110)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample119 using sampled
	// values.
	private final void logProbabilityValue$sample119() {
		// Determine if we need to calculate the values for sample task 119 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample119) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = cpu[i$var109];
					{
						{
							double var111 = cpuMean[st[i$var109]];
							double var112 = cpuVar[st[i$var109]];
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var111) / Math.sqrt(var112))) - (0.5 * Math.log(var112))));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var113[((i$var109 - 0) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample119[((i$var109 - 0) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$cpu = (logProbability$cpu + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample119 = ((((fixedFlag$sample119 && fixedFlag$sample35) && fixedFlag$sample45) && fixedFlag$sample58) && fixedFlag$sample90);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample119[((i$var109 - 0) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var113[((i$var109 - 0) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$cpu = (logProbability$cpu + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample124 using sampled
	// values.
	private final void logProbabilityValue$sample124() {
		// Determine if we need to calculate the values for sample task 124 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample124) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = mem[i$var109];
					{
						{
							double var116 = memMean[st[i$var109]];
							double var117 = memVar[st[i$var109]];
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var116) / Math.sqrt(var117))) - (0.5 * Math.log(var117))));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var118[((i$var109 - 0) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample124[((i$var109 - 0) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$mem = (logProbability$mem + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample124 = ((((fixedFlag$sample124 && fixedFlag$sample35) && fixedFlag$sample45) && fixedFlag$sample69) && fixedFlag$sample100);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample124[((i$var109 - 0) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var118[((i$var109 - 0) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$mem = (logProbability$mem + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample129 using sampled
	// values.
	private final void logProbabilityValue$sample129() {
		// Determine if we need to calculate the values for sample task 129 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample129) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = pageFaults[i$var109];
					{
						{
							double var121 = pageFaultsMean[st[i$var109]];
							double var122 = pageFaultsVar[st[i$var109]];
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var121) / Math.sqrt(var122))) - (0.5 * Math.log(var122))));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var123[((i$var109 - 0) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample129[((i$var109 - 0) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$pageFaults = (logProbability$pageFaults + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample129 = ((((fixedFlag$sample129 && fixedFlag$sample35) && fixedFlag$sample45) && fixedFlag$sample80) && fixedFlag$sample110);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample129[((i$var109 - 0) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var123[((i$var109 - 0) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$pageFaults = (logProbability$pageFaults + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample25 using sampled
	// values.
	private final void logProbabilityValue$sample25() {
		// Determine if we need to calculate the values for sample task 25 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample25) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var21 = 0; var21 < noStates; var21 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double[] cv$sampleValue = m[var21];
					{
						{
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + DistributionSampling.logProbabilityDirichlet(cv$sampleValue, v));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var17 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var22 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$m = (logProbability$m + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample25)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample25 = fixedFlag$sample25;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var22;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var17 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$m = (logProbability$m + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample25)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample32 using sampled
	// values.
	private final void logProbabilityValue$sample32() {
		// Determine if we need to calculate the values for sample task 32 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample32) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			
			// An accumulator for log probabilities.
			double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
			
			// An accumulator for the distributed probability space covered.
			double cv$probabilityReached = 0.0;
			{
				// The sample value to calculate the probability of generating
				double[] cv$sampleValue = initialStateDistribution;
				{
					{
						// Store the value of the function call, so the function call is only made once.
						double cv$weightedProbability = (Math.log(1.0) + DistributionSampling.logProbabilityDirichlet(cv$sampleValue, v));
						
						// Add the probability of this sample task to the distribution accumulator.
						if((cv$weightedProbability < cv$distributionAccumulator))
							cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
						else {
							// If the second value is -infinity.
							if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
								cv$distributionAccumulator = cv$weightedProbability;
							else
								cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
						}
						
						// Add the probability of this distribution configuration to the accumulator.
						cv$probabilityReached = (cv$probabilityReached + 1.0);
					}
				}
			}
			if((cv$probabilityReached == 0.0))
				// Return negative infinity if no distribution probability space is reached.
				cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
			else
				// Scale the probability relative to the observed distribution space.
				cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
			double cv$sampleProbability = cv$distributionAccumulator;
			
			// Add the probability of this sample task to the sample task accumulator.
			cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var26 = cv$sampleAccumulator;
			
			// Store the sample task probability
			logProbability$initialStateDistribution = cv$sampleProbability;
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample32)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample32 = fixedFlag$sample32;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$initialStateDistribution;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var26 = cv$rvAccumulator;
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample32)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample35 using sampled
	// values.
	private final void logProbabilityValue$sample35() {
		// Determine if we need to calculate the values for sample task 35 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample35) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			
			// An accumulator for log probabilities.
			double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
			
			// An accumulator for the distributed probability space covered.
			double cv$probabilityReached = 0.0;
			{
				// The sample value to calculate the probability of generating
				int cv$sampleValue = st[0];
				{
					{
						// Store the value of the function call, so the function call is only made once.
						double cv$weightedProbability = (Math.log(1.0) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < initialStateDistribution.length))?Math.log(initialStateDistribution[cv$sampleValue]):Double.NEGATIVE_INFINITY));
						
						// Add the probability of this sample task to the distribution accumulator.
						if((cv$weightedProbability < cv$distributionAccumulator))
							cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
						else {
							// If the second value is -infinity.
							if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
								cv$distributionAccumulator = cv$weightedProbability;
							else
								cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
						}
						
						// Add the probability of this distribution configuration to the accumulator.
						cv$probabilityReached = (cv$probabilityReached + 1.0);
					}
				}
			}
			if((cv$probabilityReached == 0.0))
				// Return negative infinity if no distribution probability space is reached.
				cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
			else
				// Scale the probability relative to the observed distribution space.
				cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
			double cv$sampleProbability = cv$distributionAccumulator;
			
			// Add the probability of this sample task to the sample task accumulator.
			cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var29 = cv$sampleAccumulator;
			
			// Store the sample task probability
			logProbability$var30 = cv$sampleProbability;
			
			// Update the variable probability
			logProbability$st = (logProbability$st + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample35)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample35 = (fixedFlag$sample35 && fixedFlag$sample32);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var30;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var29 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$st = (logProbability$st + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample35)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample45 using sampled
	// values.
	private final void logProbabilityValue$sample45() {
		// Determine if we need to calculate the values for sample task 45 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample45) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
				// Accumulator for sample probabilities for a specific instance of the random variable.
				double cv$sampleAccumulator = 0.0;
				
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				
				// Copy of index so that its values can be safely substituted
				int index$i$1 = i$var34;
				{
					// The sample value to calculate the probability of generating
					int cv$sampleValue = st[i$var34];
					{
						{
							double[] var38 = m[st[(i$var34 - 1)]];
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (((0.0 <= cv$sampleValue) && (cv$sampleValue < var38.length))?Math.log(var38[cv$sampleValue]):Double.NEGATIVE_INFINITY));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
				
				// Add the probability of this instance of the random variable to the probability
				// of all instances of the random variable.
				cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
				logProbability$var39[((i$var34 - 1) / 1)] = cv$sampleAccumulator;
				
				// Store the sample task probability
				logProbability$sample45[((i$var34 - 1) / 1)] = cv$sampleProbability;
			}
			
			// Update the variable probability
			logProbability$st = (logProbability$st + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample45)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample45 = ((fixedFlag$sample45 && fixedFlag$sample25) && fixedFlag$sample35);
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
				double cv$rvAccumulator = 0.0;
				double cv$sampleValue = logProbability$sample45[((i$var34 - 1) / 1)];
				cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
				cv$accumulator = (cv$accumulator + cv$rvAccumulator);
				logProbability$var39[((i$var34 - 1) / 1)] = cv$rvAccumulator;
			}
			
			// Update the variable probability
			logProbability$st = (logProbability$st + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample45)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample58 using sampled
	// values.
	private final void logProbabilityValue$sample58() {
		// Determine if we need to calculate the values for sample task 58 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample58) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var52 = 0; var52 < noStates; var52 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = cpuMean[var52];
					{
						{
							double var47 = 16.0;
							double var46 = 8.6;
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var47) / Math.sqrt(var46))) - (0.5 * Math.log(var46))));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var48 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var53 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$cpuMean = (logProbability$cpuMean + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample58)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample58 = fixedFlag$sample58;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var53;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var48 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$cpuMean = (logProbability$cpuMean + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample58)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample69 using sampled
	// values.
	private final void logProbabilityValue$sample69() {
		// Determine if we need to calculate the values for sample task 69 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample69) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var63 = 0; var63 < noStates; var63 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = memMean[var63];
					{
						{
							double var57 = 94.0;
							double var58 = 1.0;
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var57) / Math.sqrt(var58))) - (0.5 * Math.log(var58))));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var59 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var64 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$memMean = (logProbability$memMean + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample69)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample69 = fixedFlag$sample69;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var64;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var59 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$memMean = (logProbability$memMean + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample69)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample80 using sampled
	// values.
	private final void logProbabilityValue$sample80() {
		// Determine if we need to calculate the values for sample task 80 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample80) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var74 = 0; var74 < noStates; var74 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = pageFaultsMean[var74];
					{
						{
							double var68 = 814.0;
							double var69 = 335550.0;
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$sampleValue - var68) / Math.sqrt(var69))) - (0.5 * Math.log(var69))));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var70 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var75 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$pageFaultsMean = (logProbability$pageFaultsMean + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample80)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample80 = fixedFlag$sample80;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var75;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var70 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$pageFaultsMean = (logProbability$pageFaultsMean + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample80)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Calculate the probability of the samples represented by sample90 using sampled
	// values.
	private final void logProbabilityValue$sample90() {
		// Determine if we need to calculate the values for sample task 90 or if we should
		// just use cached values.
		if(!fixedProbFlag$sample90) {
			// Generating probabilities for sample task
			// Accumulator for probabilities of instances of the random variable
			double cv$accumulator = 0.0;
			
			// Accumulator for sample probabilities for a specific instance of the random variable.
			double cv$sampleAccumulator = 0.0;
			for(int var84 = 0; var84 < noStates; var84 += 1) {
				// An accumulator for log probabilities.
				double cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				
				// An accumulator for the distributed probability space covered.
				double cv$probabilityReached = 0.0;
				{
					// The sample value to calculate the probability of generating
					double cv$sampleValue = cpuVar[var84];
					{
						{
							double var79 = 5.0;
							double var78 = 0.5;
							
							// Store the value of the function call, so the function call is only made once.
							double cv$weightedProbability = (Math.log(1.0) + DistributionSampling.logProbabilityInverseGamma(cv$sampleValue, var79, var78));
							
							// Add the probability of this sample task to the distribution accumulator.
							if((cv$weightedProbability < cv$distributionAccumulator))
								cv$distributionAccumulator = (Math.log((Math.exp((cv$weightedProbability - cv$distributionAccumulator)) + 1)) + cv$distributionAccumulator);
							else {
								// If the second value is -infinity.
								if((cv$distributionAccumulator == Double.NEGATIVE_INFINITY))
									cv$distributionAccumulator = cv$weightedProbability;
								else
									cv$distributionAccumulator = (Math.log((Math.exp((cv$distributionAccumulator - cv$weightedProbability)) + 1)) + cv$weightedProbability);
							}
							
							// Add the probability of this distribution configuration to the accumulator.
							cv$probabilityReached = (cv$probabilityReached + 1.0);
						}
					}
				}
				if((cv$probabilityReached == 0.0))
					// Return negative infinity if no distribution probability space is reached.
					cv$distributionAccumulator = Double.NEGATIVE_INFINITY;
				else
					// Scale the probability relative to the observed distribution space.
					cv$distributionAccumulator = (cv$distributionAccumulator - Math.log(cv$probabilityReached));
				double cv$sampleProbability = cv$distributionAccumulator;
				
				// Add the probability of this sample task to the sample task accumulator.
				cv$sampleAccumulator = (cv$sampleAccumulator + cv$sampleProbability);
			}
			
			// Add the probability of this instance of the random variable to the probability
			// of all instances of the random variable.
			cv$accumulator = (cv$accumulator + cv$sampleAccumulator);
			logProbability$var80 = cv$sampleAccumulator;
			
			// Store the random variable instance probability
			logProbability$var85 = cv$sampleAccumulator;
			
			// Update the variable probability
			logProbability$cpuVar = (logProbability$cpuVar + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample90)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
			
			// Now the probability is calculated store if it can be cached or if it needs to be
			// recalculated next time.
			fixedProbFlag$sample90 = fixedFlag$sample90;
		}
		// Using cached values.
		else {
			// Updating random variable and model probabilities using cached probabilities for
			// this sample
			double cv$accumulator = 0.0;
			double cv$rvAccumulator = 0.0;
			double cv$sampleValue = logProbability$var85;
			cv$rvAccumulator = (cv$rvAccumulator + cv$sampleValue);
			cv$accumulator = (cv$accumulator + cv$rvAccumulator);
			logProbability$var80 = cv$rvAccumulator;
			
			// Update the variable probability
			logProbability$cpuVar = (logProbability$cpuVar + cv$accumulator);
			
			// Add probability to model
			logProbability$$model = (logProbability$$model + cv$accumulator);
			
			// If this value is fixed, add it to the probability of this model producing the fixed
			// values
			if(fixedFlag$sample90)
				logProbability$$evidence = (logProbability$$evidence + cv$accumulator);
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 100 drawn from InverseGamma 90. Inference was performed using Metropolis-Hastings.
	private final void sample100(int var94) {
		// The original value of the sample
		double cv$originalValue = memVar[var94];
		
		// The probability of the random variable generating the originally sampled value
		double cv$originalProbability = 0.0;
		
		// Calculate a proposed variance.
		double cv$var = ((cv$originalValue * cv$originalValue) * (0.1 * 0.1));
		
		// Ensure the variance is at least 0.01
		if((cv$var < (0.1 * 0.1)))
			cv$var = (0.1 * 0.1);
		
		// The proposed new value for the sample
		double cv$proposedValue = ((Math.sqrt(cv$var) * DistributionSampling.sampleGaussian(RNG$)) + cv$originalValue);
		
		// The probability of the random variable generating the new sample value.
		double cv$proposedProbability = 0.0;
		for(int cv$valuePos = 0; cv$valuePos < 2; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			double cv$currentValue;
			if((cv$valuePos == 0))
				// Set the current value to the current state of the tree.
				cv$currentValue = cv$originalValue;
			else {
				cv$currentValue = cv$proposedValue;
				
				// Update Sample and intermediate values
				{
					// Write out the value of the sample to a temporary variable prior to updating the
					// intermediate variables.
					double var95 = cv$proposedValue;
					memVar[var94] = cv$currentValue;
				}
			}
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double cv$temp$0$var89;
				{
					cv$temp$0$var89 = 5.0;
				}
				double cv$temp$1$var88;
				{
					cv$temp$1$var88 = 0.5;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + DistributionSampling.logProbabilityInverseGamma(cv$currentValue, cv$temp$0$var89, cv$temp$1$var88));
				
				// Processing random variable 118.
				{
					// Looking for a path between Sample 100 and consumer Gaussian 118.
					{
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample35) {
								if((0 == i$var109)) {
									double traceTempVariable$var117$7_1 = cv$currentValue;
									if((var94 == st[i$var109])) {
										// Processing sample task 124 of consumer random variable null.
										{
											// Set an accumulator to sum the probabilities for each possible configuration of
											// inputs.
											double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
											
											// Set an accumulator to record the consumer distributions not seen. Initially set
											// to 1 as seen values will be deducted from this value.
											double cv$consumerDistributionProbabilityAccumulator = 1.0;
											{
												// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
												// the output of Sample task 100.
												if((0 == i$var109)) {
													for(int var63 = 0; var63 < noStates; var63 += 1) {
														if((var63 == st[i$var109])) {
															{
																{
																	double cv$temp$2$var116;
																	{
																		// Constructing a random variable input for use later.
																		double var116 = memMean[st[i$var109]];
																		cv$temp$2$var116 = var116;
																	}
																	double cv$temp$3$var117;
																	{
																		// Constructing a random variable input for use later.
																		double var117 = traceTempVariable$var117$7_1;
																		cv$temp$3$var117 = var117;
																	}
																	
																	// Record the probability of sample task 124 generating output with current configuration.
																	if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))) < cv$accumulatedConsumerProbabilities))
																		cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																	else {
																		// If the second value is -infinity.
																		if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																			cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117))));
																		else
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))));
																	}
																	
																	// Recorded the probability of reaching sample task 124 with the current configuration.
																	cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																}
															}
														}
													}
												}
												
												// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
												// the output of Sample task 100.
												if(fixedFlag$sample45) {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if((i$var34 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == st[i$var109])) {
																	{
																		{
																			double cv$temp$4$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = memMean[st[i$var109]];
																				cv$temp$4$var116 = var116;
																			}
																			double cv$temp$5$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = traceTempVariable$var117$7_1;
																				cv$temp$5$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												} else {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if(true) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$26 = 0; index$sample45$26 < noStates; index$sample45$26 += 1) {
																int distributionTempVariable$var40$28 = index$sample45$26;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value27 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$26]);
																int traceTempVariable$s$29_1 = distributionTempVariable$var40$28;
																if((i$var34 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$6$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$29_1];
																						cv$temp$6$var116 = var116;
																					}
																					double cv$temp$7$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = traceTempVariable$var117$7_1;
																						cv$temp$7$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value27);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// A check to ensure rounding of floating point values can never result in a negative
											// value.
											cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
											
											// Multiply (log space add) in the probability of the sample task to the overall probability
											// for this configuration of the source random variable.
											if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
												cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
											else {
												// If the second value is -infinity.
												if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
													cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
												else
													cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
											}
										}
									}
								}
							} else {
								if(true) {
									// Enumerating the possible outputs of Categorical 29.
									for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
										int distributionTempVariable$var30$5 = index$sample35$3;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
										int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
										if((0 == i$var109)) {
											double traceTempVariable$var117$8_1 = cv$currentValue;
											if((var94 == traceTempVariable$s$6_1)) {
												// Processing sample task 124 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 100.
														int traceTempVariable$s$32_1 = distributionTempVariable$var30$5;
														if((0 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == traceTempVariable$s$32_1)) {
																	{
																		{
																			double cv$temp$8$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = memMean[traceTempVariable$s$32_1];
																				cv$temp$8$var116 = var116;
																			}
																			double cv$temp$9$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = traceTempVariable$var117$8_1;
																				cv$temp$9$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																		}
																	}
																}
															}
														}
														if(!true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$33 = 0; index$sample35$33 < noStates; index$sample35$33 += 1) {
																int distributionTempVariable$var30$35 = index$sample35$33;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value34 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$33]);
																int traceTempVariable$s$36_1 = distributionTempVariable$var30$35;
																if((0 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$36_1)) {
																			{
																				{
																					double cv$temp$10$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$36_1];
																						cv$temp$10$var116 = var116;
																					}
																					double cv$temp$11$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = traceTempVariable$var117$8_1;
																						cv$temp$11$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value34);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 100.
														if(fixedFlag$sample45) {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if((i$var34 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$6_1)) {
																			{
																				{
																					double cv$temp$12$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$6_1];
																						cv$temp$12$var116 = var116;
																					}
																					double cv$temp$13$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = traceTempVariable$var117$8_1;
																						cv$temp$13$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																				}
																			}
																		}
																	}
																}
															}
														} else {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if(true) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
																		int distributionTempVariable$var40$43 = index$sample45$41;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value42 = (cv$probabilitySample35Value4 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$41]);
																		int traceTempVariable$s$44_1 = distributionTempVariable$var40$43;
																		if((i$var34 == i$var109)) {
																			for(int var63 = 0; var63 < noStates; var63 += 1) {
																				if((var63 == traceTempVariable$s$44_1)) {
																					{
																						{
																							double cv$temp$14$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$44_1];
																								cv$temp$14$var116 = var116;
																							}
																							double cv$temp$15$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = traceTempVariable$var117$8_1;
																								cv$temp$15$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value42);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample45) {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if((i$var34 == i$var109)) {
										double traceTempVariable$var117$16_1 = cv$currentValue;
										if((var94 == st[i$var109])) {
											// Processing sample task 124 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 100.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == st[i$var109])) {
																	{
																		{
																			double cv$temp$16$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = memMean[st[i$var109]];
																				cv$temp$16$var116 = var116;
																			}
																			double cv$temp$17$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = traceTempVariable$var117$16_1;
																				cv$temp$17$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$48 = 0; index$sample35$48 < noStates; index$sample35$48 += 1) {
																int distributionTempVariable$var30$50 = index$sample35$48;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value49 = (1.0 * distribution$sample35[index$sample35$48]);
																int traceTempVariable$s$51_1 = distributionTempVariable$var30$50;
																if((0 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$51_1)) {
																			{
																				{
																					double cv$temp$18$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$51_1];
																						cv$temp$18$var116 = var116;
																					}
																					double cv$temp$19$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = traceTempVariable$var117$16_1;
																						cv$temp$19$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value49);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 100.
													for(int index$i$54_1 = 1; index$i$54_1 < samples; index$i$54_1 += 1) {
														if((index$i$54_1 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == st[i$var109])) {
																	{
																		{
																			double cv$temp$20$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = memMean[st[i$var109]];
																				cv$temp$20$var116 = var116;
																			}
																			double cv$temp$21$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = traceTempVariable$var117$16_1;
																				cv$temp$21$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							} else {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if(true) {
										// Enumerating the possible outputs of Categorical 39.
										for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
											int distributionTempVariable$var40$14 = index$sample45$12;
											
											// Update the probability of sampling this value from the distribution value.
											double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$12]);
											int traceTempVariable$s$15_1 = distributionTempVariable$var40$14;
											if((i$var34 == i$var109)) {
												double traceTempVariable$var117$17_1 = cv$currentValue;
												if((var94 == traceTempVariable$s$15_1)) {
													// Processing sample task 124 of consumer random variable null.
													{
														// Set an accumulator to sum the probabilities for each possible configuration of
														// inputs.
														double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
														
														// Set an accumulator to record the consumer distributions not seen. Initially set
														// to 1 as seen values will be deducted from this value.
														double cv$consumerDistributionProbabilityAccumulator = 1.0;
														{
															// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
															// the output of Sample task 100.
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$15_1)) {
																			{
																				{
																					double cv$temp$22$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$15_1];
																						cv$temp$22$var116 = var116;
																					}
																					double cv$temp$23$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = traceTempVariable$var117$17_1;
																						cv$temp$23$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$57 = 0; index$sample35$57 < noStates; index$sample35$57 += 1) {
																		int distributionTempVariable$var30$59 = index$sample35$57;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value58 = (cv$probabilitySample45Value13 * distribution$sample35[index$sample35$57]);
																		int traceTempVariable$s$60_1 = distributionTempVariable$var30$59;
																		if((0 == i$var109)) {
																			for(int var63 = 0; var63 < noStates; var63 += 1) {
																				if((var63 == traceTempVariable$s$60_1)) {
																					{
																						{
																							double cv$temp$24$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$60_1];
																								cv$temp$24$var116 = var116;
																							}
																							double cv$temp$25$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = traceTempVariable$var117$17_1;
																								cv$temp$25$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value58);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
															// the output of Sample task 100.
															int traceTempVariable$s$63_1 = distributionTempVariable$var40$14;
															if((i$var34 == i$var109)) {
																for(int var63 = 0; var63 < noStates; var63 += 1) {
																	if((var63 == traceTempVariable$s$63_1)) {
																		{
																			{
																				double cv$temp$26$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$63_1];
																					cv$temp$26$var116 = var116;
																				}
																				double cv$temp$27$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = traceTempVariable$var117$17_1;
																					cv$temp$27$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																			}
																		}
																	}
																}
															}
															for(int index$i$64 = 1; index$i$64 < samples; index$i$64 += 1) {
																if(!(index$i$64 == i$var34)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$65 = 0; index$sample45$65 < noStates; index$sample45$65 += 1) {
																		int distributionTempVariable$var40$67 = index$sample45$65;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value66 = (cv$probabilitySample45Value13 * distribution$sample45[((index$i$64 - 1) / 1)][index$sample45$65]);
																		int traceTempVariable$s$68_1 = distributionTempVariable$var40$67;
																		if((index$i$64 == i$var109)) {
																			for(int var63 = 0; var63 < noStates; var63 += 1) {
																				if((var63 == traceTempVariable$s$68_1)) {
																					{
																						{
																							double cv$temp$28$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$68_1];
																								cv$temp$28$var116 = var116;
																							}
																							double cv$temp$29$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = traceTempVariable$var117$17_1;
																								cv$temp$29$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value66);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// A check to ensure rounding of floating point values can never result in a negative
														// value.
														cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
														
														// Multiply (log space add) in the probability of the sample task to the overall probability
														// for this configuration of the source random variable.
														if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
															cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
														else {
															// If the second value is -infinity.
															if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
															else
																cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Save the probability of the original value.
			if((cv$valuePos == 0))
				cv$originalProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
			
			// Save the probability of the proposed value.
			else
				cv$proposedProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// The probability ration for the proposed value and the current value.
		double cv$ratio = (cv$proposedProbability - cv$originalProbability);
		
		// Test if the probability of the sample is sufficient to keep the value. This needs
		// to be less than or equal as otherwise if the proposed value is not possible and
		// the random value is 0 an impossible value will be accepted.
		if((((cv$proposedProbability - cv$originalProbability) <= Math.log((0.0 + ((1.0 - 0.0) * DistributionSampling.sampleUniform(RNG$))))) || Double.isNaN(cv$ratio))) {
			// If it is not revert the changes.
			// 
			// Set the sample value
			// Write out the value of the sample to a temporary variable prior to updating the
			// intermediate variables.
			double var95 = cv$originalValue;
			memVar[var94] = var95;
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 110 drawn from InverseGamma 100. Inference was performed using Metropolis-Hastings.
	private final void sample110(int var104) {
		// The original value of the sample
		double cv$originalValue = pageFaultsVar[var104];
		
		// The probability of the random variable generating the originally sampled value
		double cv$originalProbability = 0.0;
		
		// Calculate a proposed variance.
		double cv$var = ((cv$originalValue * cv$originalValue) * (0.1 * 0.1));
		
		// Ensure the variance is at least 0.01
		if((cv$var < (0.1 * 0.1)))
			cv$var = (0.1 * 0.1);
		
		// The proposed new value for the sample
		double cv$proposedValue = ((Math.sqrt(cv$var) * DistributionSampling.sampleGaussian(RNG$)) + cv$originalValue);
		
		// The probability of the random variable generating the new sample value.
		double cv$proposedProbability = 0.0;
		for(int cv$valuePos = 0; cv$valuePos < 2; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			double cv$currentValue;
			if((cv$valuePos == 0))
				// Set the current value to the current state of the tree.
				cv$currentValue = cv$originalValue;
			else {
				cv$currentValue = cv$proposedValue;
				
				// Update Sample and intermediate values
				{
					// Write out the value of the sample to a temporary variable prior to updating the
					// intermediate variables.
					double var105 = cv$proposedValue;
					pageFaultsVar[var104] = cv$currentValue;
				}
			}
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double cv$temp$0$var99;
				{
					cv$temp$0$var99 = 5.0;
				}
				double cv$temp$1$var98;
				{
					cv$temp$1$var98 = 0.5;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + DistributionSampling.logProbabilityInverseGamma(cv$currentValue, cv$temp$0$var99, cv$temp$1$var98));
				
				// Processing random variable 123.
				{
					// Looking for a path between Sample 110 and consumer Gaussian 123.
					{
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample35) {
								if((0 == i$var109)) {
									double traceTempVariable$var122$7_1 = cv$currentValue;
									if((var104 == st[i$var109])) {
										// Processing sample task 129 of consumer random variable null.
										{
											// Set an accumulator to sum the probabilities for each possible configuration of
											// inputs.
											double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
											
											// Set an accumulator to record the consumer distributions not seen. Initially set
											// to 1 as seen values will be deducted from this value.
											double cv$consumerDistributionProbabilityAccumulator = 1.0;
											{
												// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
												// the output of Sample task 110.
												if((0 == i$var109)) {
													for(int var74 = 0; var74 < noStates; var74 += 1) {
														if((var74 == st[i$var109])) {
															{
																{
																	double cv$temp$2$var121;
																	{
																		// Constructing a random variable input for use later.
																		double var121 = pageFaultsMean[st[i$var109]];
																		cv$temp$2$var121 = var121;
																	}
																	double cv$temp$3$var122;
																	{
																		// Constructing a random variable input for use later.
																		double var122 = traceTempVariable$var122$7_1;
																		cv$temp$3$var122 = var122;
																	}
																	
																	// Record the probability of sample task 129 generating output with current configuration.
																	if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))) < cv$accumulatedConsumerProbabilities))
																		cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																	else {
																		// If the second value is -infinity.
																		if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																			cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122))));
																		else
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))));
																	}
																	
																	// Recorded the probability of reaching sample task 129 with the current configuration.
																	cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																}
															}
														}
													}
												}
												
												// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
												// the output of Sample task 110.
												if(fixedFlag$sample45) {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if((i$var34 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == st[i$var109])) {
																	{
																		{
																			double cv$temp$4$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = pageFaultsMean[st[i$var109]];
																				cv$temp$4$var121 = var121;
																			}
																			double cv$temp$5$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = traceTempVariable$var122$7_1;
																				cv$temp$5$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												} else {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if(true) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$26 = 0; index$sample45$26 < noStates; index$sample45$26 += 1) {
																int distributionTempVariable$var40$28 = index$sample45$26;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value27 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$26]);
																int traceTempVariable$s$29_1 = distributionTempVariable$var40$28;
																if((i$var34 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$6$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$29_1];
																						cv$temp$6$var121 = var121;
																					}
																					double cv$temp$7$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = traceTempVariable$var122$7_1;
																						cv$temp$7$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value27);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// A check to ensure rounding of floating point values can never result in a negative
											// value.
											cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
											
											// Multiply (log space add) in the probability of the sample task to the overall probability
											// for this configuration of the source random variable.
											if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
												cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
											else {
												// If the second value is -infinity.
												if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
													cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
												else
													cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
											}
										}
									}
								}
							} else {
								if(true) {
									// Enumerating the possible outputs of Categorical 29.
									for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
										int distributionTempVariable$var30$5 = index$sample35$3;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
										int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
										if((0 == i$var109)) {
											double traceTempVariable$var122$8_1 = cv$currentValue;
											if((var104 == traceTempVariable$s$6_1)) {
												// Processing sample task 129 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 110.
														int traceTempVariable$s$32_1 = distributionTempVariable$var30$5;
														if((0 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == traceTempVariable$s$32_1)) {
																	{
																		{
																			double cv$temp$8$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = pageFaultsMean[traceTempVariable$s$32_1];
																				cv$temp$8$var121 = var121;
																			}
																			double cv$temp$9$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = traceTempVariable$var122$8_1;
																				cv$temp$9$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																		}
																	}
																}
															}
														}
														if(!true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$33 = 0; index$sample35$33 < noStates; index$sample35$33 += 1) {
																int distributionTempVariable$var30$35 = index$sample35$33;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value34 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$33]);
																int traceTempVariable$s$36_1 = distributionTempVariable$var30$35;
																if((0 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$36_1)) {
																			{
																				{
																					double cv$temp$10$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$36_1];
																						cv$temp$10$var121 = var121;
																					}
																					double cv$temp$11$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = traceTempVariable$var122$8_1;
																						cv$temp$11$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value34);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 110.
														if(fixedFlag$sample45) {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if((i$var34 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$6_1)) {
																			{
																				{
																					double cv$temp$12$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$6_1];
																						cv$temp$12$var121 = var121;
																					}
																					double cv$temp$13$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = traceTempVariable$var122$8_1;
																						cv$temp$13$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																				}
																			}
																		}
																	}
																}
															}
														} else {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if(true) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
																		int distributionTempVariable$var40$43 = index$sample45$41;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value42 = (cv$probabilitySample35Value4 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$41]);
																		int traceTempVariable$s$44_1 = distributionTempVariable$var40$43;
																		if((i$var34 == i$var109)) {
																			for(int var74 = 0; var74 < noStates; var74 += 1) {
																				if((var74 == traceTempVariable$s$44_1)) {
																					{
																						{
																							double cv$temp$14$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$44_1];
																								cv$temp$14$var121 = var121;
																							}
																							double cv$temp$15$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = traceTempVariable$var122$8_1;
																								cv$temp$15$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value42);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample45) {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if((i$var34 == i$var109)) {
										double traceTempVariable$var122$16_1 = cv$currentValue;
										if((var104 == st[i$var109])) {
											// Processing sample task 129 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 110.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == st[i$var109])) {
																	{
																		{
																			double cv$temp$16$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = pageFaultsMean[st[i$var109]];
																				cv$temp$16$var121 = var121;
																			}
																			double cv$temp$17$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = traceTempVariable$var122$16_1;
																				cv$temp$17$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$48 = 0; index$sample35$48 < noStates; index$sample35$48 += 1) {
																int distributionTempVariable$var30$50 = index$sample35$48;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value49 = (1.0 * distribution$sample35[index$sample35$48]);
																int traceTempVariable$s$51_1 = distributionTempVariable$var30$50;
																if((0 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$51_1)) {
																			{
																				{
																					double cv$temp$18$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$51_1];
																						cv$temp$18$var121 = var121;
																					}
																					double cv$temp$19$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = traceTempVariable$var122$16_1;
																						cv$temp$19$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value49);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 110.
													for(int index$i$54_1 = 1; index$i$54_1 < samples; index$i$54_1 += 1) {
														if((index$i$54_1 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == st[i$var109])) {
																	{
																		{
																			double cv$temp$20$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = pageFaultsMean[st[i$var109]];
																				cv$temp$20$var121 = var121;
																			}
																			double cv$temp$21$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = traceTempVariable$var122$16_1;
																				cv$temp$21$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							} else {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if(true) {
										// Enumerating the possible outputs of Categorical 39.
										for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
											int distributionTempVariable$var40$14 = index$sample45$12;
											
											// Update the probability of sampling this value from the distribution value.
											double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$12]);
											int traceTempVariable$s$15_1 = distributionTempVariable$var40$14;
											if((i$var34 == i$var109)) {
												double traceTempVariable$var122$17_1 = cv$currentValue;
												if((var104 == traceTempVariable$s$15_1)) {
													// Processing sample task 129 of consumer random variable null.
													{
														// Set an accumulator to sum the probabilities for each possible configuration of
														// inputs.
														double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
														
														// Set an accumulator to record the consumer distributions not seen. Initially set
														// to 1 as seen values will be deducted from this value.
														double cv$consumerDistributionProbabilityAccumulator = 1.0;
														{
															// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
															// the output of Sample task 110.
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$15_1)) {
																			{
																				{
																					double cv$temp$22$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$15_1];
																						cv$temp$22$var121 = var121;
																					}
																					double cv$temp$23$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = traceTempVariable$var122$17_1;
																						cv$temp$23$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$57 = 0; index$sample35$57 < noStates; index$sample35$57 += 1) {
																		int distributionTempVariable$var30$59 = index$sample35$57;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value58 = (cv$probabilitySample45Value13 * distribution$sample35[index$sample35$57]);
																		int traceTempVariable$s$60_1 = distributionTempVariable$var30$59;
																		if((0 == i$var109)) {
																			for(int var74 = 0; var74 < noStates; var74 += 1) {
																				if((var74 == traceTempVariable$s$60_1)) {
																					{
																						{
																							double cv$temp$24$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$60_1];
																								cv$temp$24$var121 = var121;
																							}
																							double cv$temp$25$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = traceTempVariable$var122$17_1;
																								cv$temp$25$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value58);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
															// the output of Sample task 110.
															int traceTempVariable$s$63_1 = distributionTempVariable$var40$14;
															if((i$var34 == i$var109)) {
																for(int var74 = 0; var74 < noStates; var74 += 1) {
																	if((var74 == traceTempVariable$s$63_1)) {
																		{
																			{
																				double cv$temp$26$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$63_1];
																					cv$temp$26$var121 = var121;
																				}
																				double cv$temp$27$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = traceTempVariable$var122$17_1;
																					cv$temp$27$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																			}
																		}
																	}
																}
															}
															for(int index$i$64 = 1; index$i$64 < samples; index$i$64 += 1) {
																if(!(index$i$64 == i$var34)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$65 = 0; index$sample45$65 < noStates; index$sample45$65 += 1) {
																		int distributionTempVariable$var40$67 = index$sample45$65;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value66 = (cv$probabilitySample45Value13 * distribution$sample45[((index$i$64 - 1) / 1)][index$sample45$65]);
																		int traceTempVariable$s$68_1 = distributionTempVariable$var40$67;
																		if((index$i$64 == i$var109)) {
																			for(int var74 = 0; var74 < noStates; var74 += 1) {
																				if((var74 == traceTempVariable$s$68_1)) {
																					{
																						{
																							double cv$temp$28$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$68_1];
																								cv$temp$28$var121 = var121;
																							}
																							double cv$temp$29$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = traceTempVariable$var122$17_1;
																								cv$temp$29$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value66);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// A check to ensure rounding of floating point values can never result in a negative
														// value.
														cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
														
														// Multiply (log space add) in the probability of the sample task to the overall probability
														// for this configuration of the source random variable.
														if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
															cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
														else {
															// If the second value is -infinity.
															if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
															else
																cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Save the probability of the original value.
			if((cv$valuePos == 0))
				cv$originalProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
			
			// Save the probability of the proposed value.
			else
				cv$proposedProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// The probability ration for the proposed value and the current value.
		double cv$ratio = (cv$proposedProbability - cv$originalProbability);
		
		// Test if the probability of the sample is sufficient to keep the value. This needs
		// to be less than or equal as otherwise if the proposed value is not possible and
		// the random value is 0 an impossible value will be accepted.
		if((((cv$proposedProbability - cv$originalProbability) <= Math.log((0.0 + ((1.0 - 0.0) * DistributionSampling.sampleUniform(RNG$))))) || Double.isNaN(cv$ratio))) {
			// If it is not revert the changes.
			// 
			// Set the sample value
			// Write out the value of the sample to a temporary variable prior to updating the
			// intermediate variables.
			double var105 = cv$originalValue;
			pageFaultsVar[var104] = var105;
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 25 drawn from Dirichlet 17. Inference was performed using a Dirichlet
	// to Categorical conjugate prior.
	private final void sample25(int var21) {
		// A reference local to the function for the sample variable.
		double[] cv$targetLocal = m[var21];
		
		// A local reference to the scratch space.
		double[] cv$countLocal = cv$var22$countGlobal;
		
		// Get the length of the array
		int cv$arrayLength = noStates;
		
		// Initialize the array values to 0.
		for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
			cv$countLocal[cv$loopIndex] = 0.0;
		{
			// Processing random variable 39.
			{
				// Looking for a path between Sample 25 and consumer Categorical 39.
				{
					for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
						if(fixedFlag$sample35) {
							if((0 == (i$var34 - 1))) {
								if((var21 == st[(i$var34 - 1)])) {
									if(fixedFlag$sample45) {
										// Processing sample task 45 of consumer random variable null.
										{
											// Copy of index so that its values can be safely substituted
											int index$i$19 = i$var34;
											{
												{
													{
														{
															// Increment the sample counter with the value sampled by sample task 45 of random
															// variable var39
															cv$countLocal[st[i$var34]] = (cv$countLocal[st[i$var34]] + 1.0);
														}
													}
												}
											}
										}
									}
								}
							}
						} else {
							if(true) {
								// Enumerating the possible outputs of Categorical 29.
								for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
									int distributionTempVariable$var30$5 = index$sample35$3;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
									int traceTempVariable$var37$6_1 = distributionTempVariable$var30$5;
									if((0 == (i$var34 - 1))) {
										if((var21 == traceTempVariable$var37$6_1)) {
											if(fixedFlag$sample45) {
												// Processing sample task 45 of consumer random variable null.
												{
													// Copy of index so that its values can be safely substituted
													int index$i$21 = i$var34;
													{
														{
															{
																{
																	// Increment the sample counter with the value sampled by sample task 45 of random
																	// variable var39
																	cv$countLocal[st[i$var34]] = (cv$countLocal[st[i$var34]] + cv$probabilitySample35Value4);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
						if(fixedFlag$sample45) {
							for(int index$i$10_1 = 1; index$i$10_1 < samples; index$i$10_1 += 1) {
								if((index$i$10_1 == (i$var34 - 1))) {
									if((var21 == st[(i$var34 - 1)])) {
										if(fixedFlag$sample45) {
											// Processing sample task 45 of consumer random variable null.
											{
												// Copy of index so that its values can be safely substituted
												int index$i$23 = i$var34;
												{
													{
														{
															{
																// Increment the sample counter with the value sampled by sample task 45 of random
																// variable var39
																cv$countLocal[st[i$var34]] = (cv$countLocal[st[i$var34]] + 1.0);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						} else {
							for(int index$i$11 = 1; index$i$11 < samples; index$i$11 += 1) {
								if(true) {
									// Enumerating the possible outputs of Categorical 39.
									for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
										int distributionTempVariable$var40$14 = index$sample45$12;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((index$i$11 - 1) / 1)][index$sample45$12]);
										int traceTempVariable$var37$15_1 = distributionTempVariable$var40$14;
										if((index$i$11 == (i$var34 - 1))) {
											if((var21 == traceTempVariable$var37$15_1)) {
												if(fixedFlag$sample45) {
													// Processing sample task 45 of consumer random variable null.
													{
														// Copy of index so that its values can be safely substituted
														int index$i$25 = i$var34;
														{
															{
																{
																	{
																		// Increment the sample counter with the value sampled by sample task 45 of random
																		// variable var39
																		cv$countLocal[st[i$var34]] = (cv$countLocal[st[i$var34]] + cv$probabilitySample45Value13);
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		
		// Processing random variable 39.
		{
			// Looking for a path between Sample 25 and consumer Categorical 39.
			{
				for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
					if(fixedFlag$sample35) {
						if((0 == (i$var34 - 1))) {
							if((var21 == st[(i$var34 - 1)])) {
								if(!fixedFlag$sample45) {
									// Processing sample task 45 of consumer random variable null.
									{
										// Copy of index so that its values can be safely substituted
										int index$i$48 = i$var34;
										{
											{
												// Declare and zero an accumulator for tracking the reached source probability space.
												double scopeVariable$reachedSourceProbability = 0.0;
												{
													// Add the probability of this argument configuration.
													scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
												}
												
												// The probability of reaching the consumer with this set of consumer arguments
												double cv$distributionProbability = (scopeVariable$reachedSourceProbability * 1.0);
												
												// Merge the distribution probabilities into the count
												for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
													cv$countLocal[cv$loopIndex] = (cv$countLocal[cv$loopIndex] + (distribution$sample45[((i$var34 - 1) / 1)][cv$loopIndex] * cv$distributionProbability));
											}
										}
									}
								}
							}
						}
					} else {
						if(true) {
							// Enumerating the possible outputs of Categorical 29.
							for(int index$sample35$32 = 0; index$sample35$32 < noStates; index$sample35$32 += 1) {
								int distributionTempVariable$var30$34 = index$sample35$32;
								
								// Update the probability of sampling this value from the distribution value.
								double cv$probabilitySample35Value33 = (1.0 * distribution$sample35[index$sample35$32]);
								int traceTempVariable$var37$35_1 = distributionTempVariable$var30$34;
								if((0 == (i$var34 - 1))) {
									if((var21 == traceTempVariable$var37$35_1)) {
										if(!fixedFlag$sample45) {
											// Processing sample task 45 of consumer random variable null.
											{
												// Copy of index so that its values can be safely substituted
												int index$i$50 = i$var34;
												{
													{
														// Declare and zero an accumulator for tracking the reached source probability space.
														double scopeVariable$reachedSourceProbability = 0.0;
														{
															// Add the probability of this argument configuration.
															scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
														}
														
														// The probability of reaching the consumer with this set of consumer arguments
														double cv$distributionProbability = (scopeVariable$reachedSourceProbability * cv$probabilitySample35Value33);
														
														// Merge the distribution probabilities into the count
														for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
															cv$countLocal[cv$loopIndex] = (cv$countLocal[cv$loopIndex] + (distribution$sample45[((i$var34 - 1) / 1)][cv$loopIndex] * cv$distributionProbability));
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
					if(fixedFlag$sample45) {
						for(int index$i$39_1 = 1; index$i$39_1 < samples; index$i$39_1 += 1) {
							if((index$i$39_1 == (i$var34 - 1))) {
								if((var21 == st[(i$var34 - 1)])) {
									if(!fixedFlag$sample45) {
										// Processing sample task 45 of consumer random variable null.
										{
											// Copy of index so that its values can be safely substituted
											int index$i$52 = i$var34;
											{
												{
													// Declare and zero an accumulator for tracking the reached source probability space.
													double scopeVariable$reachedSourceProbability = 0.0;
													{
														// Add the probability of this argument configuration.
														scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
													}
													
													// The probability of reaching the consumer with this set of consumer arguments
													double cv$distributionProbability = (scopeVariable$reachedSourceProbability * 1.0);
													
													// Merge the distribution probabilities into the count
													for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
														cv$countLocal[cv$loopIndex] = (cv$countLocal[cv$loopIndex] + (distribution$sample45[((i$var34 - 1) / 1)][cv$loopIndex] * cv$distributionProbability));
												}
											}
										}
									}
								}
							}
						}
					} else {
						for(int index$i$40 = 1; index$i$40 < samples; index$i$40 += 1) {
							if(true) {
								// Enumerating the possible outputs of Categorical 39.
								for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
									int distributionTempVariable$var40$43 = index$sample45$41;
									
									// Update the probability of sampling this value from the distribution value.
									double cv$probabilitySample45Value42 = (1.0 * distribution$sample45[((index$i$40 - 1) / 1)][index$sample45$41]);
									int traceTempVariable$var37$44_1 = distributionTempVariable$var40$43;
									if((index$i$40 == (i$var34 - 1))) {
										if((var21 == traceTempVariable$var37$44_1)) {
											if(!fixedFlag$sample45) {
												// Processing sample task 45 of consumer random variable null.
												{
													// Copy of index so that its values can be safely substituted
													int index$i$54 = i$var34;
													{
														{
															// Declare and zero an accumulator for tracking the reached source probability space.
															double scopeVariable$reachedSourceProbability = 0.0;
															{
																// Add the probability of this argument configuration.
																scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
															}
															
															// The probability of reaching the consumer with this set of consumer arguments
															double cv$distributionProbability = (scopeVariable$reachedSourceProbability * cv$probabilitySample45Value42);
															
															// Merge the distribution probabilities into the count
															for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
																cv$countLocal[cv$loopIndex] = (cv$countLocal[cv$loopIndex] + (distribution$sample45[((i$var34 - 1) / 1)][cv$loopIndex] * cv$distributionProbability));
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		
		// Calculate the new sample value
		// 
		// Calculate a new sample value and write it into cv$targetLocal.
		Conjugates.sampleConjugateDirichletCategorical(RNG$, v, cv$countLocal, cv$targetLocal);
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 32 drawn from Dirichlet 26. Inference was performed using a Dirichlet
	// to Categorical conjugate prior.
	private final void sample32() {
		// A reference local to the function for the sample variable.
		double[] cv$targetLocal = initialStateDistribution;
		
		// A local reference to the scratch space.
		double[] cv$countLocal = cv$var27$countGlobal;
		
		// Get the length of the array
		int cv$arrayLength = noStates;
		
		// Initialize the array values to 0.
		for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
			cv$countLocal[cv$loopIndex] = 0.0;
		{
			// Processing random variable 29.
			{
				{
					if(fixedFlag$sample35) {
						// Processing sample task 35 of consumer random variable null.
						{
							{
								{
									{
										{
											// Increment the sample counter with the value sampled by sample task 35 of random
											// variable var29
											cv$countLocal[st[0]] = (cv$countLocal[st[0]] + 1.0);
										}
									}
								}
							}
						}
					}
				}
			}
		}
		
		// Processing random variable 29.
		{
			{
				if(!fixedFlag$sample35) {
					// Processing sample task 35 of consumer random variable null.
					{
						{
							{
								// Declare and zero an accumulator for tracking the reached source probability space.
								double scopeVariable$reachedSourceProbability = 0.0;
								{
									// Add the probability of this argument configuration.
									scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
								}
								
								// The probability of reaching the consumer with this set of consumer arguments
								double cv$distributionProbability = (scopeVariable$reachedSourceProbability * 1.0);
								
								// Merge the distribution probabilities into the count
								for(int cv$loopIndex = 0; cv$loopIndex < cv$arrayLength; cv$loopIndex += 1)
									cv$countLocal[cv$loopIndex] = (cv$countLocal[cv$loopIndex] + (distribution$sample35[cv$loopIndex] * cv$distributionProbability));
							}
						}
					}
				}
			}
		}
		
		// Calculate the new sample value
		// 
		// Calculate a new sample value and write it into cv$targetLocal.
		Conjugates.sampleConjugateDirichletCategorical(RNG$, v, cv$countLocal, cv$targetLocal);
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 35 drawn from Categorical 29. Inference was performed using variable
	// marginalization.
	private final void sample35() {
		// Get a local reference to the scratch space.
		double[] cv$stateProbabilityLocal = cv$var30$stateProbabilityGlobal;
		for(int cv$valuePos = 0; cv$valuePos < noStates; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			int cv$currentValue;
			
			// Value of the variable at this index
			cv$currentValue = cv$valuePos;
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double[] cv$temp$0$initialStateDistribution;
				{
					cv$temp$0$initialStateDistribution = initialStateDistribution;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + (((0.0 <= cv$currentValue) && (cv$currentValue < cv$temp$0$initialStateDistribution.length))?Math.log(cv$temp$0$initialStateDistribution[cv$currentValue]):Double.NEGATIVE_INFINITY));
				
				// Processing random variable 39.
				{
					// Looking for a path between Sample 35 and consumer Categorical 39.
					{
						int traceTempVariable$var37$1_1 = cv$currentValue;
						for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
							if((0 == (i$var34 - 1))) {
								if(fixedFlag$sample45) {
									// Processing sample task 45 of consumer random variable null.
									{
										// Copy of index so that its values can be safely substituted
										int index$i$3 = i$var34;
										
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Categorical 39 which is consuming
											// the output of Sample task 35.
											for(int var21 = 0; var21 < noStates; var21 += 1) {
												if((var21 == traceTempVariable$var37$1_1)) {
													{
														{
															double[] cv$temp$1$var38;
															{
																// Constructing a random variable input for use later.
																double[] var38 = m[traceTempVariable$var37$1_1];
																cv$temp$1$var38 = var38;
															}
															
															// Record the probability of sample task 45 generating output with current configuration.
															if(((Math.log(1.0) + (((0.0 <= st[i$var34]) && (st[i$var34] < cv$temp$1$var38.length))?Math.log(cv$temp$1$var38[st[i$var34]]):Double.NEGATIVE_INFINITY)) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (((0.0 <= st[i$var34]) && (st[i$var34] < cv$temp$1$var38.length))?Math.log(cv$temp$1$var38[st[i$var34]]):Double.NEGATIVE_INFINITY)) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (((0.0 <= st[i$var34]) && (st[i$var34] < cv$temp$1$var38.length))?Math.log(cv$temp$1$var38[st[i$var34]]):Double.NEGATIVE_INFINITY));
																else
																	cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (((0.0 <= st[i$var34]) && (st[i$var34] < cv$temp$1$var38.length))?Math.log(cv$temp$1$var38[st[i$var34]]):Double.NEGATIVE_INFINITY)))) + 1)) + (Math.log(1.0) + (((0.0 <= st[i$var34]) && (st[i$var34] < cv$temp$1$var38.length))?Math.log(cv$temp$1$var38[st[i$var34]]):Double.NEGATIVE_INFINITY)));
															}
															
															// Recorded the probability of reaching sample task 45 with the current configuration.
															cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
					}
				}
				
				// Processing random variable 113.
				{
					// Looking for a path between Sample 35 and consumer Gaussian 113.
					{
						// Guard to check that at most one copy of the code is executed for a given random
						// variable instance.
						boolean[] guard$sample35gaussian118 = guard$sample35gaussian118$global;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109))
								// Set the flags to false
								guard$sample35gaussian118[((i$var109 - 0) / 1)] = false;
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109))
								// Set the flags to false
								guard$sample35gaussian118[((i$var109 - 0) / 1)] = false;
						}
						int traceTempVariable$s$8_1 = cv$currentValue;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109)) {
								if(!guard$sample35gaussian118[((i$var109 - 0) / 1)]) {
									// The body will execute, so should not be executed again
									guard$sample35gaussian118[((i$var109 - 0) / 1)] = true;
									
									// Processing sample task 119 of consumer random variable null.
									{
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
											// the output of Sample task 35.
											for(int var52 = 0; var52 < noStates; var52 += 1) {
												if((var52 == traceTempVariable$s$8_1)) {
													int traceTempVariable$s$13_1 = cv$currentValue;
													if((0 == i$var109)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$13_1)) {
																{
																	{
																		double cv$temp$2$var111;
																		{
																			// Constructing a random variable input for use later.
																			double var111 = cpuMean[traceTempVariable$s$13_1];
																			cv$temp$2$var111 = var111;
																		}
																		double cv$temp$3$var112;
																		{
																			// Constructing a random variable input for use later.
																			double var112 = cpuVar[traceTempVariable$s$13_1];
																			cv$temp$3$var112 = var112;
																		}
																		
																		// Record the probability of sample task 119 generating output with current configuration.
																		if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))) < cv$accumulatedConsumerProbabilities))
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																		else {
																			// If the second value is -infinity.
																			if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																				cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112))));
																			else
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))));
																		}
																		
																		// Recorded the probability of reaching sample task 119 with the current configuration.
																		cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																	}
																}
															}
														}
													}
													if(!true) {
														// Enumerating the possible outputs of Categorical 29.
														for(int index$sample35$14 = 0; index$sample35$14 < noStates; index$sample35$14 += 1) {
															int distributionTempVariable$var30$16 = index$sample35$14;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample35Value15 = (1.0 * distribution$sample35[index$sample35$14]);
															int traceTempVariable$s$17_1 = distributionTempVariable$var30$16;
															if((0 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$17_1)) {
																		{
																			{
																				double cv$temp$4$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$17_1];
																					cv$temp$4$var111 = var111;
																				}
																				double cv$temp$5$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$17_1];
																					cv$temp$5$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample35Value15) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value15) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value15) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value15) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value15) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value15);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
											// the output of Sample task 35.
											for(int var52 = 0; var52 < noStates; var52 += 1) {
												if((var52 == traceTempVariable$s$8_1)) {
													if(fixedFlag$sample45) {
														for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
															if((i$var34 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$8_1)) {
																		{
																			{
																				double cv$temp$6$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$8_1];
																					cv$temp$6$var111 = var111;
																				}
																				double cv$temp$7$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$8_1];
																					cv$temp$7$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													} else {
														for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
															if(true) {
																// Enumerating the possible outputs of Categorical 39.
																for(int index$sample45$23 = 0; index$sample45$23 < noStates; index$sample45$23 += 1) {
																	int distributionTempVariable$var40$25 = index$sample45$23;
																	
																	// Update the probability of sampling this value from the distribution value.
																	double cv$probabilitySample45Value24 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$23]);
																	int traceTempVariable$s$26_1 = distributionTempVariable$var40$25;
																	if((i$var34 == i$var109)) {
																		for(int var84 = 0; var84 < noStates; var84 += 1) {
																			if((var84 == traceTempVariable$s$26_1)) {
																				{
																					{
																						double cv$temp$8$var111;
																						{
																							// Constructing a random variable input for use later.
																							double var111 = cpuMean[traceTempVariable$s$26_1];
																							cv$temp$8$var111 = var111;
																						}
																						double cv$temp$9$var112;
																						{
																							// Constructing a random variable input for use later.
																							double var112 = cpuVar[traceTempVariable$s$26_1];
																							cv$temp$9$var112 = var112;
																						}
																						
																						// Record the probability of sample task 119 generating output with current configuration.
																						if(((Math.log(cv$probabilitySample45Value24) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) < cv$accumulatedConsumerProbabilities))
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value24) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																						else {
																							// If the second value is -infinity.
																							if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																								cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value24) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112))));
																							else
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value24) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value24) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))));
																						}
																						
																						// Recorded the probability of reaching sample task 119 with the current configuration.
																						cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value24);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
						int traceTempVariable$s$9_1 = cv$currentValue;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109)) {
								if(!guard$sample35gaussian118[((i$var109 - 0) / 1)]) {
									// The body will execute, so should not be executed again
									guard$sample35gaussian118[((i$var109 - 0) / 1)] = true;
									
									// Processing sample task 119 of consumer random variable null.
									{
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
											// the output of Sample task 35.
											int traceTempVariable$s$29_1 = cv$currentValue;
											if((0 == i$var109)) {
												for(int var52 = 0; var52 < noStates; var52 += 1) {
													if((var52 == traceTempVariable$s$29_1)) {
														for(int var84 = 0; var84 < noStates; var84 += 1) {
															if((var84 == traceTempVariable$s$29_1)) {
																{
																	{
																		double cv$temp$10$var111;
																		{
																			// Constructing a random variable input for use later.
																			double var111 = cpuMean[traceTempVariable$s$29_1];
																			cv$temp$10$var111 = var111;
																		}
																		double cv$temp$11$var112;
																		{
																			// Constructing a random variable input for use later.
																			double var112 = cpuVar[traceTempVariable$s$29_1];
																			cv$temp$11$var112 = var112;
																		}
																		
																		// Record the probability of sample task 119 generating output with current configuration.
																		if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) < cv$accumulatedConsumerProbabilities))
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																		else {
																			// If the second value is -infinity.
																			if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																				cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112))));
																			else
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))));
																		}
																		
																		// Recorded the probability of reaching sample task 119 with the current configuration.
																		cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																	}
																}
															}
														}
													}
												}
											}
											if(!true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$30 = 0; index$sample35$30 < noStates; index$sample35$30 += 1) {
													int distributionTempVariable$var30$32 = index$sample35$30;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value31 = (1.0 * distribution$sample35[index$sample35$30]);
													int traceTempVariable$s$33_1 = distributionTempVariable$var30$32;
													if((0 == i$var109)) {
														for(int var52 = 0; var52 < noStates; var52 += 1) {
															if((var52 == traceTempVariable$s$33_1)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$33_1)) {
																		{
																			{
																				double cv$temp$12$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$33_1];
																					cv$temp$12$var111 = var111;
																				}
																				double cv$temp$13$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$33_1];
																					cv$temp$13$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample35Value31) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value31) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value31) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value31) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value31) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value31);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
											// the output of Sample task 35.
											if(fixedFlag$sample45) {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if((i$var34 == i$var109)) {
														for(int var52 = 0; var52 < noStates; var52 += 1) {
															if((var52 == traceTempVariable$s$9_1)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$9_1)) {
																		{
																			{
																				double cv$temp$14$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$9_1];
																					cv$temp$14$var111 = var111;
																				}
																				double cv$temp$15$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$9_1];
																					cv$temp$15$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											} else {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if(true) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$40 = 0; index$sample45$40 < noStates; index$sample45$40 += 1) {
															int distributionTempVariable$var40$42 = index$sample45$40;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value41 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$40]);
															int traceTempVariable$s$43_1 = distributionTempVariable$var40$42;
															if((i$var34 == i$var109)) {
																for(int var52 = 0; var52 < noStates; var52 += 1) {
																	if((var52 == traceTempVariable$s$43_1)) {
																		for(int var84 = 0; var84 < noStates; var84 += 1) {
																			if((var84 == traceTempVariable$s$43_1)) {
																				{
																					{
																						double cv$temp$16$var111;
																						{
																							// Constructing a random variable input for use later.
																							double var111 = cpuMean[traceTempVariable$s$43_1];
																							cv$temp$16$var111 = var111;
																						}
																						double cv$temp$17$var112;
																						{
																							// Constructing a random variable input for use later.
																							double var112 = cpuVar[traceTempVariable$s$43_1];
																							cv$temp$17$var112 = var112;
																						}
																						
																						// Record the probability of sample task 119 generating output with current configuration.
																						if(((Math.log(cv$probabilitySample45Value41) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) < cv$accumulatedConsumerProbabilities))
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value41) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																						else {
																							// If the second value is -infinity.
																							if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																								cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value41) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112))));
																							else
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value41) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value41) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))));
																						}
																						
																						// Recorded the probability of reaching sample task 119 with the current configuration.
																						cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value41);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
					}
				}
				
				// Processing random variable 118.
				{
					// Looking for a path between Sample 35 and consumer Gaussian 118.
					{
						// Guard to check that at most one copy of the code is executed for a given random
						// variable instance.
						boolean[] guard$sample35gaussian123 = guard$sample35gaussian123$global;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109))
								// Set the flags to false
								guard$sample35gaussian123[((i$var109 - 0) / 1)] = false;
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109))
								// Set the flags to false
								guard$sample35gaussian123[((i$var109 - 0) / 1)] = false;
						}
						int traceTempVariable$s$58_1 = cv$currentValue;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109)) {
								if(!guard$sample35gaussian123[((i$var109 - 0) / 1)]) {
									// The body will execute, so should not be executed again
									guard$sample35gaussian123[((i$var109 - 0) / 1)] = true;
									
									// Processing sample task 124 of consumer random variable null.
									{
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
											// the output of Sample task 35.
											for(int var63 = 0; var63 < noStates; var63 += 1) {
												if((var63 == traceTempVariable$s$58_1)) {
													int traceTempVariable$s$63_1 = cv$currentValue;
													if((0 == i$var109)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$63_1)) {
																{
																	{
																		double cv$temp$18$var116;
																		{
																			// Constructing a random variable input for use later.
																			double var116 = memMean[traceTempVariable$s$63_1];
																			cv$temp$18$var116 = var116;
																		}
																		double cv$temp$19$var117;
																		{
																			// Constructing a random variable input for use later.
																			double var117 = memVar[traceTempVariable$s$63_1];
																			cv$temp$19$var117 = var117;
																		}
																		
																		// Record the probability of sample task 124 generating output with current configuration.
																		if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))) < cv$accumulatedConsumerProbabilities))
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																		else {
																			// If the second value is -infinity.
																			if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																				cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117))));
																			else
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))));
																		}
																		
																		// Recorded the probability of reaching sample task 124 with the current configuration.
																		cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																	}
																}
															}
														}
													}
													if(!true) {
														// Enumerating the possible outputs of Categorical 29.
														for(int index$sample35$64 = 0; index$sample35$64 < noStates; index$sample35$64 += 1) {
															int distributionTempVariable$var30$66 = index$sample35$64;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample35Value65 = (1.0 * distribution$sample35[index$sample35$64]);
															int traceTempVariable$s$67_1 = distributionTempVariable$var30$66;
															if((0 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$67_1)) {
																		{
																			{
																				double cv$temp$20$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$67_1];
																					cv$temp$20$var116 = var116;
																				}
																				double cv$temp$21$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$67_1];
																					cv$temp$21$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample35Value65) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value65) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value65) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value65) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value65) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value65);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
											// the output of Sample task 35.
											for(int var63 = 0; var63 < noStates; var63 += 1) {
												if((var63 == traceTempVariable$s$58_1)) {
													if(fixedFlag$sample45) {
														for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
															if((i$var34 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$58_1)) {
																		{
																			{
																				double cv$temp$22$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$58_1];
																					cv$temp$22$var116 = var116;
																				}
																				double cv$temp$23$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$58_1];
																					cv$temp$23$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													} else {
														for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
															if(true) {
																// Enumerating the possible outputs of Categorical 39.
																for(int index$sample45$73 = 0; index$sample45$73 < noStates; index$sample45$73 += 1) {
																	int distributionTempVariable$var40$75 = index$sample45$73;
																	
																	// Update the probability of sampling this value from the distribution value.
																	double cv$probabilitySample45Value74 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$73]);
																	int traceTempVariable$s$76_1 = distributionTempVariable$var40$75;
																	if((i$var34 == i$var109)) {
																		for(int var94 = 0; var94 < noStates; var94 += 1) {
																			if((var94 == traceTempVariable$s$76_1)) {
																				{
																					{
																						double cv$temp$24$var116;
																						{
																							// Constructing a random variable input for use later.
																							double var116 = memMean[traceTempVariable$s$76_1];
																							cv$temp$24$var116 = var116;
																						}
																						double cv$temp$25$var117;
																						{
																							// Constructing a random variable input for use later.
																							double var117 = memVar[traceTempVariable$s$76_1];
																							cv$temp$25$var117 = var117;
																						}
																						
																						// Record the probability of sample task 124 generating output with current configuration.
																						if(((Math.log(cv$probabilitySample45Value74) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))) < cv$accumulatedConsumerProbabilities))
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value74) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																						else {
																							// If the second value is -infinity.
																							if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																								cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value74) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117))));
																							else
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value74) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value74) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))));
																						}
																						
																						// Recorded the probability of reaching sample task 124 with the current configuration.
																						cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value74);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
						int traceTempVariable$s$59_1 = cv$currentValue;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109)) {
								if(!guard$sample35gaussian123[((i$var109 - 0) / 1)]) {
									// The body will execute, so should not be executed again
									guard$sample35gaussian123[((i$var109 - 0) / 1)] = true;
									
									// Processing sample task 124 of consumer random variable null.
									{
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
											// the output of Sample task 35.
											int traceTempVariable$s$79_1 = cv$currentValue;
											if((0 == i$var109)) {
												for(int var63 = 0; var63 < noStates; var63 += 1) {
													if((var63 == traceTempVariable$s$79_1)) {
														for(int var94 = 0; var94 < noStates; var94 += 1) {
															if((var94 == traceTempVariable$s$79_1)) {
																{
																	{
																		double cv$temp$26$var116;
																		{
																			// Constructing a random variable input for use later.
																			double var116 = memMean[traceTempVariable$s$79_1];
																			cv$temp$26$var116 = var116;
																		}
																		double cv$temp$27$var117;
																		{
																			// Constructing a random variable input for use later.
																			double var117 = memVar[traceTempVariable$s$79_1];
																			cv$temp$27$var117 = var117;
																		}
																		
																		// Record the probability of sample task 124 generating output with current configuration.
																		if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))) < cv$accumulatedConsumerProbabilities))
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																		else {
																			// If the second value is -infinity.
																			if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																				cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117))));
																			else
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))));
																		}
																		
																		// Recorded the probability of reaching sample task 124 with the current configuration.
																		cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																	}
																}
															}
														}
													}
												}
											}
											if(!true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$80 = 0; index$sample35$80 < noStates; index$sample35$80 += 1) {
													int distributionTempVariable$var30$82 = index$sample35$80;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value81 = (1.0 * distribution$sample35[index$sample35$80]);
													int traceTempVariable$s$83_1 = distributionTempVariable$var30$82;
													if((0 == i$var109)) {
														for(int var63 = 0; var63 < noStates; var63 += 1) {
															if((var63 == traceTempVariable$s$83_1)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$83_1)) {
																		{
																			{
																				double cv$temp$28$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$83_1];
																					cv$temp$28$var116 = var116;
																				}
																				double cv$temp$29$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$83_1];
																					cv$temp$29$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample35Value81) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value81) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value81) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value81) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value81) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value81);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
											// the output of Sample task 35.
											if(fixedFlag$sample45) {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if((i$var34 == i$var109)) {
														for(int var63 = 0; var63 < noStates; var63 += 1) {
															if((var63 == traceTempVariable$s$59_1)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$59_1)) {
																		{
																			{
																				double cv$temp$30$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$59_1];
																					cv$temp$30$var116 = var116;
																				}
																				double cv$temp$31$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$59_1];
																					cv$temp$31$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$30$var116) / Math.sqrt(cv$temp$31$var117))) - (0.5 * Math.log(cv$temp$31$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$30$var116) / Math.sqrt(cv$temp$31$var117))) - (0.5 * Math.log(cv$temp$31$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$30$var116) / Math.sqrt(cv$temp$31$var117))) - (0.5 * Math.log(cv$temp$31$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$30$var116) / Math.sqrt(cv$temp$31$var117))) - (0.5 * Math.log(cv$temp$31$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$30$var116) / Math.sqrt(cv$temp$31$var117))) - (0.5 * Math.log(cv$temp$31$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											} else {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if(true) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$90 = 0; index$sample45$90 < noStates; index$sample45$90 += 1) {
															int distributionTempVariable$var40$92 = index$sample45$90;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value91 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$90]);
															int traceTempVariable$s$93_1 = distributionTempVariable$var40$92;
															if((i$var34 == i$var109)) {
																for(int var63 = 0; var63 < noStates; var63 += 1) {
																	if((var63 == traceTempVariable$s$93_1)) {
																		for(int var94 = 0; var94 < noStates; var94 += 1) {
																			if((var94 == traceTempVariable$s$93_1)) {
																				{
																					{
																						double cv$temp$32$var116;
																						{
																							// Constructing a random variable input for use later.
																							double var116 = memMean[traceTempVariable$s$93_1];
																							cv$temp$32$var116 = var116;
																						}
																						double cv$temp$33$var117;
																						{
																							// Constructing a random variable input for use later.
																							double var117 = memVar[traceTempVariable$s$93_1];
																							cv$temp$33$var117 = var117;
																						}
																						
																						// Record the probability of sample task 124 generating output with current configuration.
																						if(((Math.log(cv$probabilitySample45Value91) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$32$var116) / Math.sqrt(cv$temp$33$var117))) - (0.5 * Math.log(cv$temp$33$var117)))) < cv$accumulatedConsumerProbabilities))
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value91) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$32$var116) / Math.sqrt(cv$temp$33$var117))) - (0.5 * Math.log(cv$temp$33$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																						else {
																							// If the second value is -infinity.
																							if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																								cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value91) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$32$var116) / Math.sqrt(cv$temp$33$var117))) - (0.5 * Math.log(cv$temp$33$var117))));
																							else
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value91) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$32$var116) / Math.sqrt(cv$temp$33$var117))) - (0.5 * Math.log(cv$temp$33$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value91) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$32$var116) / Math.sqrt(cv$temp$33$var117))) - (0.5 * Math.log(cv$temp$33$var117)))));
																						}
																						
																						// Recorded the probability of reaching sample task 124 with the current configuration.
																						cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value91);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
					}
				}
				
				// Processing random variable 123.
				{
					// Looking for a path between Sample 35 and consumer Gaussian 123.
					{
						// Guard to check that at most one copy of the code is executed for a given random
						// variable instance.
						boolean[] guard$sample35gaussian128 = guard$sample35gaussian128$global;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109))
								// Set the flags to false
								guard$sample35gaussian128[((i$var109 - 0) / 1)] = false;
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109))
								// Set the flags to false
								guard$sample35gaussian128[((i$var109 - 0) / 1)] = false;
						}
						int traceTempVariable$s$108_1 = cv$currentValue;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109)) {
								if(!guard$sample35gaussian128[((i$var109 - 0) / 1)]) {
									// The body will execute, so should not be executed again
									guard$sample35gaussian128[((i$var109 - 0) / 1)] = true;
									
									// Processing sample task 129 of consumer random variable null.
									{
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
											// the output of Sample task 35.
											for(int var74 = 0; var74 < noStates; var74 += 1) {
												if((var74 == traceTempVariable$s$108_1)) {
													int traceTempVariable$s$113_1 = cv$currentValue;
													if((0 == i$var109)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$113_1)) {
																{
																	{
																		double cv$temp$34$var121;
																		{
																			// Constructing a random variable input for use later.
																			double var121 = pageFaultsMean[traceTempVariable$s$113_1];
																			cv$temp$34$var121 = var121;
																		}
																		double cv$temp$35$var122;
																		{
																			// Constructing a random variable input for use later.
																			double var122 = pageFaultsVar[traceTempVariable$s$113_1];
																			cv$temp$35$var122 = var122;
																		}
																		
																		// Record the probability of sample task 129 generating output with current configuration.
																		if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$34$var121) / Math.sqrt(cv$temp$35$var122))) - (0.5 * Math.log(cv$temp$35$var122)))) < cv$accumulatedConsumerProbabilities))
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$34$var121) / Math.sqrt(cv$temp$35$var122))) - (0.5 * Math.log(cv$temp$35$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																		else {
																			// If the second value is -infinity.
																			if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																				cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$34$var121) / Math.sqrt(cv$temp$35$var122))) - (0.5 * Math.log(cv$temp$35$var122))));
																			else
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$34$var121) / Math.sqrt(cv$temp$35$var122))) - (0.5 * Math.log(cv$temp$35$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$34$var121) / Math.sqrt(cv$temp$35$var122))) - (0.5 * Math.log(cv$temp$35$var122)))));
																		}
																		
																		// Recorded the probability of reaching sample task 129 with the current configuration.
																		cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																	}
																}
															}
														}
													}
													if(!true) {
														// Enumerating the possible outputs of Categorical 29.
														for(int index$sample35$114 = 0; index$sample35$114 < noStates; index$sample35$114 += 1) {
															int distributionTempVariable$var30$116 = index$sample35$114;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample35Value115 = (1.0 * distribution$sample35[index$sample35$114]);
															int traceTempVariable$s$117_1 = distributionTempVariable$var30$116;
															if((0 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$117_1)) {
																		{
																			{
																				double cv$temp$36$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$117_1];
																					cv$temp$36$var121 = var121;
																				}
																				double cv$temp$37$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$117_1];
																					cv$temp$37$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample35Value115) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$36$var121) / Math.sqrt(cv$temp$37$var122))) - (0.5 * Math.log(cv$temp$37$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value115) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$36$var121) / Math.sqrt(cv$temp$37$var122))) - (0.5 * Math.log(cv$temp$37$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value115) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$36$var121) / Math.sqrt(cv$temp$37$var122))) - (0.5 * Math.log(cv$temp$37$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value115) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$36$var121) / Math.sqrt(cv$temp$37$var122))) - (0.5 * Math.log(cv$temp$37$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value115) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$36$var121) / Math.sqrt(cv$temp$37$var122))) - (0.5 * Math.log(cv$temp$37$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value115);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
											// the output of Sample task 35.
											for(int var74 = 0; var74 < noStates; var74 += 1) {
												if((var74 == traceTempVariable$s$108_1)) {
													if(fixedFlag$sample45) {
														for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
															if((i$var34 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$108_1)) {
																		{
																			{
																				double cv$temp$38$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$108_1];
																					cv$temp$38$var121 = var121;
																				}
																				double cv$temp$39$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$108_1];
																					cv$temp$39$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$38$var121) / Math.sqrt(cv$temp$39$var122))) - (0.5 * Math.log(cv$temp$39$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$38$var121) / Math.sqrt(cv$temp$39$var122))) - (0.5 * Math.log(cv$temp$39$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$38$var121) / Math.sqrt(cv$temp$39$var122))) - (0.5 * Math.log(cv$temp$39$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$38$var121) / Math.sqrt(cv$temp$39$var122))) - (0.5 * Math.log(cv$temp$39$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$38$var121) / Math.sqrt(cv$temp$39$var122))) - (0.5 * Math.log(cv$temp$39$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													} else {
														for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
															if(true) {
																// Enumerating the possible outputs of Categorical 39.
																for(int index$sample45$123 = 0; index$sample45$123 < noStates; index$sample45$123 += 1) {
																	int distributionTempVariable$var40$125 = index$sample45$123;
																	
																	// Update the probability of sampling this value from the distribution value.
																	double cv$probabilitySample45Value124 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$123]);
																	int traceTempVariable$s$126_1 = distributionTempVariable$var40$125;
																	if((i$var34 == i$var109)) {
																		for(int var104 = 0; var104 < noStates; var104 += 1) {
																			if((var104 == traceTempVariable$s$126_1)) {
																				{
																					{
																						double cv$temp$40$var121;
																						{
																							// Constructing a random variable input for use later.
																							double var121 = pageFaultsMean[traceTempVariable$s$126_1];
																							cv$temp$40$var121 = var121;
																						}
																						double cv$temp$41$var122;
																						{
																							// Constructing a random variable input for use later.
																							double var122 = pageFaultsVar[traceTempVariable$s$126_1];
																							cv$temp$41$var122 = var122;
																						}
																						
																						// Record the probability of sample task 129 generating output with current configuration.
																						if(((Math.log(cv$probabilitySample45Value124) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$40$var121) / Math.sqrt(cv$temp$41$var122))) - (0.5 * Math.log(cv$temp$41$var122)))) < cv$accumulatedConsumerProbabilities))
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value124) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$40$var121) / Math.sqrt(cv$temp$41$var122))) - (0.5 * Math.log(cv$temp$41$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																						else {
																							// If the second value is -infinity.
																							if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																								cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value124) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$40$var121) / Math.sqrt(cv$temp$41$var122))) - (0.5 * Math.log(cv$temp$41$var122))));
																							else
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value124) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$40$var121) / Math.sqrt(cv$temp$41$var122))) - (0.5 * Math.log(cv$temp$41$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value124) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$40$var121) / Math.sqrt(cv$temp$41$var122))) - (0.5 * Math.log(cv$temp$41$var122)))));
																						}
																						
																						// Recorded the probability of reaching sample task 129 with the current configuration.
																						cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value124);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
						int traceTempVariable$s$109_1 = cv$currentValue;
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if((0 == i$var109)) {
								if(!guard$sample35gaussian128[((i$var109 - 0) / 1)]) {
									// The body will execute, so should not be executed again
									guard$sample35gaussian128[((i$var109 - 0) / 1)] = true;
									
									// Processing sample task 129 of consumer random variable null.
									{
										// Set an accumulator to sum the probabilities for each possible configuration of
										// inputs.
										double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
										
										// Set an accumulator to record the consumer distributions not seen. Initially set
										// to 1 as seen values will be deducted from this value.
										double cv$consumerDistributionProbabilityAccumulator = 1.0;
										{
											// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
											// the output of Sample task 35.
											int traceTempVariable$s$129_1 = cv$currentValue;
											if((0 == i$var109)) {
												for(int var74 = 0; var74 < noStates; var74 += 1) {
													if((var74 == traceTempVariable$s$129_1)) {
														for(int var104 = 0; var104 < noStates; var104 += 1) {
															if((var104 == traceTempVariable$s$129_1)) {
																{
																	{
																		double cv$temp$42$var121;
																		{
																			// Constructing a random variable input for use later.
																			double var121 = pageFaultsMean[traceTempVariable$s$129_1];
																			cv$temp$42$var121 = var121;
																		}
																		double cv$temp$43$var122;
																		{
																			// Constructing a random variable input for use later.
																			double var122 = pageFaultsVar[traceTempVariable$s$129_1];
																			cv$temp$43$var122 = var122;
																		}
																		
																		// Record the probability of sample task 129 generating output with current configuration.
																		if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$42$var121) / Math.sqrt(cv$temp$43$var122))) - (0.5 * Math.log(cv$temp$43$var122)))) < cv$accumulatedConsumerProbabilities))
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$42$var121) / Math.sqrt(cv$temp$43$var122))) - (0.5 * Math.log(cv$temp$43$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																		else {
																			// If the second value is -infinity.
																			if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																				cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$42$var121) / Math.sqrt(cv$temp$43$var122))) - (0.5 * Math.log(cv$temp$43$var122))));
																			else
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$42$var121) / Math.sqrt(cv$temp$43$var122))) - (0.5 * Math.log(cv$temp$43$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$42$var121) / Math.sqrt(cv$temp$43$var122))) - (0.5 * Math.log(cv$temp$43$var122)))));
																		}
																		
																		// Recorded the probability of reaching sample task 129 with the current configuration.
																		cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																	}
																}
															}
														}
													}
												}
											}
											if(!true) {
												// Enumerating the possible outputs of Categorical 29.
												for(int index$sample35$130 = 0; index$sample35$130 < noStates; index$sample35$130 += 1) {
													int distributionTempVariable$var30$132 = index$sample35$130;
													
													// Update the probability of sampling this value from the distribution value.
													double cv$probabilitySample35Value131 = (1.0 * distribution$sample35[index$sample35$130]);
													int traceTempVariable$s$133_1 = distributionTempVariable$var30$132;
													if((0 == i$var109)) {
														for(int var74 = 0; var74 < noStates; var74 += 1) {
															if((var74 == traceTempVariable$s$133_1)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$133_1)) {
																		{
																			{
																				double cv$temp$44$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$133_1];
																					cv$temp$44$var121 = var121;
																				}
																				double cv$temp$45$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$133_1];
																					cv$temp$45$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample35Value131) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$44$var121) / Math.sqrt(cv$temp$45$var122))) - (0.5 * Math.log(cv$temp$45$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value131) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$44$var121) / Math.sqrt(cv$temp$45$var122))) - (0.5 * Math.log(cv$temp$45$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value131) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$44$var121) / Math.sqrt(cv$temp$45$var122))) - (0.5 * Math.log(cv$temp$45$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value131) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$44$var121) / Math.sqrt(cv$temp$45$var122))) - (0.5 * Math.log(cv$temp$45$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value131) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$44$var121) / Math.sqrt(cv$temp$45$var122))) - (0.5 * Math.log(cv$temp$45$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value131);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
											// the output of Sample task 35.
											if(fixedFlag$sample45) {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if((i$var34 == i$var109)) {
														for(int var74 = 0; var74 < noStates; var74 += 1) {
															if((var74 == traceTempVariable$s$109_1)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$109_1)) {
																		{
																			{
																				double cv$temp$46$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$109_1];
																					cv$temp$46$var121 = var121;
																				}
																				double cv$temp$47$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$109_1];
																					cv$temp$47$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$46$var121) / Math.sqrt(cv$temp$47$var122))) - (0.5 * Math.log(cv$temp$47$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$46$var121) / Math.sqrt(cv$temp$47$var122))) - (0.5 * Math.log(cv$temp$47$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$46$var121) / Math.sqrt(cv$temp$47$var122))) - (0.5 * Math.log(cv$temp$47$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$46$var121) / Math.sqrt(cv$temp$47$var122))) - (0.5 * Math.log(cv$temp$47$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$46$var121) / Math.sqrt(cv$temp$47$var122))) - (0.5 * Math.log(cv$temp$47$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													}
												}
											} else {
												for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
													if(true) {
														// Enumerating the possible outputs of Categorical 39.
														for(int index$sample45$140 = 0; index$sample45$140 < noStates; index$sample45$140 += 1) {
															int distributionTempVariable$var40$142 = index$sample45$140;
															
															// Update the probability of sampling this value from the distribution value.
															double cv$probabilitySample45Value141 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$140]);
															int traceTempVariable$s$143_1 = distributionTempVariable$var40$142;
															if((i$var34 == i$var109)) {
																for(int var74 = 0; var74 < noStates; var74 += 1) {
																	if((var74 == traceTempVariable$s$143_1)) {
																		for(int var104 = 0; var104 < noStates; var104 += 1) {
																			if((var104 == traceTempVariable$s$143_1)) {
																				{
																					{
																						double cv$temp$48$var121;
																						{
																							// Constructing a random variable input for use later.
																							double var121 = pageFaultsMean[traceTempVariable$s$143_1];
																							cv$temp$48$var121 = var121;
																						}
																						double cv$temp$49$var122;
																						{
																							// Constructing a random variable input for use later.
																							double var122 = pageFaultsVar[traceTempVariable$s$143_1];
																							cv$temp$49$var122 = var122;
																						}
																						
																						// Record the probability of sample task 129 generating output with current configuration.
																						if(((Math.log(cv$probabilitySample45Value141) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$48$var121) / Math.sqrt(cv$temp$49$var122))) - (0.5 * Math.log(cv$temp$49$var122)))) < cv$accumulatedConsumerProbabilities))
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value141) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$48$var121) / Math.sqrt(cv$temp$49$var122))) - (0.5 * Math.log(cv$temp$49$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																						else {
																							// If the second value is -infinity.
																							if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																								cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value141) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$48$var121) / Math.sqrt(cv$temp$49$var122))) - (0.5 * Math.log(cv$temp$49$var122))));
																							else
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value141) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$48$var121) / Math.sqrt(cv$temp$49$var122))) - (0.5 * Math.log(cv$temp$49$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value141) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$48$var121) / Math.sqrt(cv$temp$49$var122))) - (0.5 * Math.log(cv$temp$49$var122)))));
																						}
																						
																						// Recorded the probability of reaching sample task 129 with the current configuration.
																						cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value141);
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										
										// A check to ensure rounding of floating point values can never result in a negative
										// value.
										cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
										
										// Multiply (log space add) in the probability of the sample task to the overall probability
										// for this configuration of the source random variable.
										if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
											cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
										else {
											// If the second value is -infinity.
											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
												cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
											else
												cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Processing random variable 39.
			{
				// Looking for a path between Sample 35 and consumer Categorical 39.
				{
					int traceTempVariable$var37$156_1 = cv$currentValue;
					for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
						if((0 == (i$var34 - 1))) {
							if(!fixedFlag$sample45) {
								// Processing sample task 45 of consumer random variable null.
								{
									// Copy of index so that its values can be safely substituted
									int index$i$158 = i$var34;
									
									// A local array to hold the accumulated distributions of the sample tasks for each
									// configuration of distributions.
									double[] cv$accumulatedConsumerDistributions = cv$distributionAccumulator$var39;
									
									// Zero all the elements in the distribution accumulator
									for(int cv$i = 0; cv$i < noStates; cv$i += 1)
										cv$accumulatedConsumerDistributions[cv$i] = 0.0;
									
									// Zero an accumulator to track the probabilities reached.
									double cv$reachedDistributionProbability = 0.0;
									
									// Enumerating the possible arguments for the variable Categorical 39 which is consuming
									// the output of Sample task 35.
									for(int var21 = 0; var21 < noStates; var21 += 1) {
										if((var21 == traceTempVariable$var37$156_1)) {
											{
												// Declare and zero an accumulator for tracking the reached source probability space.
												double scopeVariable$reachedSourceProbability = 0.0;
												{
													// Add the probability of this argument configuration.
													scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
												}
												double[] cv$temp$50$var38;
												{
													// Constructing a random variable input for use later.
													double[] var38 = m[traceTempVariable$var37$156_1];
													cv$temp$50$var38 = var38;
												}
												
												// The probability of reaching the consumer with this set of consumer arguments
												double cv$distributionProbability = (scopeVariable$reachedSourceProbability * 1.0);
												
												// Record the reached distribution.
												cv$reachedDistributionProbability = (cv$reachedDistributionProbability + cv$distributionProbability);
												
												// Add the current distribution to the distribution accumulator.
												DistributionSampling.addProbabilityDistributionCategorical(cv$accumulatedConsumerDistributions, cv$distributionProbability, cv$temp$50$var38);
											}
										}
									}
									
									// A local copy of the samples' distribution.
									double[] cv$sampleDistribution = distribution$sample45[((i$var34 - 1) / 1)];
									
									// The overlap of the distributions so far.
									double cv$overlap = 0.0;
									
									// Calculate the overlap for each element in the distribution
									for(int cv$i = 0; cv$i < noStates; cv$i += 1) {
										// Normalise the values in the calculated distribution
										double cv$normalisedDistValue = (cv$accumulatedConsumerDistributions[cv$i] / cv$reachedDistributionProbability);
										
										// Corresponding value from the sample distribution
										double cv$sampleDistValue = cv$sampleDistribution[cv$i];
										
										// Calculate the overlap and store the result
										if((cv$sampleDistValue < cv$normalisedDistValue))
											cv$overlap = (cv$overlap + cv$sampleDistValue);
										
										// Calculate the overlap and store the result
										else
											cv$overlap = (cv$overlap + cv$normalisedDistValue);
									}
									
									// Scale and add the result to the combined results so far. A min is taken over the
									// reached distributions so that rounding cannot result in a value greater than one
									// as for a small probability this could give a negative value
									cv$accumulatedDistributionProbabilities = (cv$accumulatedDistributionProbabilities + Math.log(((cv$overlap * cv$reachedDistributionProbability) + (1.0 - Math.min(cv$reachedDistributionProbability, 1.0)))));
								}
							}
						}
					}
				}
			}
			
			// Save the calculated index value into the array of index value probabilities
			cv$stateProbabilityLocal[cv$valuePos] = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// Set the calculated probabilities to be the distribution values, and normalize
		// 
		// Local copy of the probability array
		double[] cv$localProbability = distribution$sample35;
		
		// The sum of all the probabilities in log space
		double cv$logSum = 0.0;
		
		// Sum all the values
		{
			// Initialise the max to the first element.
			double cv$lseMax = cv$stateProbabilityLocal[0];
			
			// Find max value.
			for(int cv$lseIndex = 1; cv$lseIndex < cv$stateProbabilityLocal.length; cv$lseIndex += 1) {
				double cv$lseElementValue = cv$stateProbabilityLocal[cv$lseIndex];
				if((cv$lseMax < cv$lseElementValue))
					cv$lseMax = cv$lseElementValue;
			}
			
			// If the maximum value is -infinity return -infinity.
			if((cv$lseMax == Double.NEGATIVE_INFINITY))
				cv$logSum = Double.NEGATIVE_INFINITY;
			
			// Sum the values in the array.
			else {
				// Initialise the sum of the array elements
				double cv$lseSum = 0.0;
				
				// Offset values, move to normal space, and sum.
				for(int cv$lseIndex = 0; cv$lseIndex < cv$stateProbabilityLocal.length; cv$lseIndex += 1)
					cv$lseSum = (cv$lseSum + Math.exp((cv$stateProbabilityLocal[cv$lseIndex] - cv$lseMax)));
				
				// Increment the value of the target, moving the value back into log space.
				cv$logSum = (cv$logSum + (Math.log(cv$lseSum) + cv$lseMax));
			}
		}
		
		// If all the sum is zero, just share the probability evenly.
		if((cv$logSum == Double.NEGATIVE_INFINITY)) {
			// Normalize log space values and move to normal space
			for(int cv$indexName = 0; cv$indexName < cv$stateProbabilityLocal.length; cv$indexName += 1)
				cv$localProbability[cv$indexName] = (1.0 / cv$stateProbabilityLocal.length);
		} else {
			// Normalize log space values and move to normal space
			for(int cv$indexName = 0; cv$indexName < cv$stateProbabilityLocal.length; cv$indexName += 1)
				cv$localProbability[cv$indexName] = Math.exp((cv$stateProbabilityLocal[cv$indexName] - cv$logSum));
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 45 drawn from Categorical 39. Inference was performed using variable
	// marginalization.
	private final void sample45(int i$var34) {
		// Get a local reference to the scratch space.
		double[] cv$stateProbabilityLocal = cv$var40$stateProbabilityGlobal;
		for(int cv$valuePos = 0; cv$valuePos < noStates; cv$valuePos += 1) {
			// Exploring all the possible distribution values for random variable 39 creating
			// sample task 45.
			// Copy of index so that its values can be safely substituted
			int index$i$1 = i$var34;
			
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			int cv$currentValue;
			
			// Value of the variable at this index
			cv$currentValue = cv$valuePos;
			
			// Enumerating the possible arguments for Categorical 39.
			if(fixedFlag$sample35) {
				if((0 == (i$var34 - 1))) {
					for(int var21 = 0; var21 < noStates; var21 += 1) {
						if((var21 == st[(i$var34 - 1)])) {
							// Record the reached probability density.
							cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
							double[] cv$temp$0$var38;
							{
								// Constructing a random variable input for use later.
								double[] var38 = m[st[(i$var34 - 1)]];
								cv$temp$0$var38 = var38;
							}
							
							// An accumulator to allow the value for each distribution to be constructed before
							// it is added to the index probabilities.
							double cv$accumulatedProbabilities = (Math.log(1.0) + (((0.0 <= cv$currentValue) && (cv$currentValue < cv$temp$0$var38.length))?Math.log(cv$temp$0$var38[cv$currentValue]):Double.NEGATIVE_INFINITY));
							
							// Processing random variable 39.
							{
								// Looking for a path between Sample 45 and consumer Categorical 39.
								{
									int traceTempVariable$var37$17_1 = cv$currentValue;
								}
							}
							
							// Processing random variable 113.
							{
								// Looking for a path between Sample 45 and consumer Gaussian 113.
								{
									// Guard to check that at most one copy of the code is executed for a given random
									// variable instance.
									boolean[] guard$sample45gaussian118 = guard$sample45gaussian118$global;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109))
											// Set the flags to false
											guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
									}
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109))
											// Set the flags to false
											guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
									}
									int traceTempVariable$s$29_1 = cv$currentValue;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109)) {
											if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
												// The body will execute, so should not be executed again
												guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
												
												// Processing sample task 119 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 45.
														for(int var52 = 0; var52 < noStates; var52 += 1) {
															if((var52 == traceTempVariable$s$29_1)) {
																if((0 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$4$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$29_1];
																						cv$temp$4$var111 = var111;
																					}
																					double cv$temp$5$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$29_1];
																						cv$temp$5$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 45.
														for(int var52 = 0; var52 < noStates; var52 += 1) {
															if((var52 == traceTempVariable$s$29_1)) {
																int traceTempVariable$s$49_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$49_1)) {
																			{
																				{
																					double cv$temp$6$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$49_1];
																						cv$temp$6$var111 = var111;
																					}
																					double cv$temp$7$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$49_1];
																						cv$temp$7$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
																for(int index$i$50 = 1; index$i$50 < samples; index$i$50 += 1) {
																	if(!(index$i$50 == index$i$1)) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$51 = 0; index$sample45$51 < noStates; index$sample45$51 += 1) {
																			int distributionTempVariable$var40$53 = index$sample45$51;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value52 = (1.0 * distribution$sample45[((index$i$50 - 1) / 1)][index$sample45$51]);
																			int traceTempVariable$s$54_1 = distributionTempVariable$var40$53;
																			if((index$i$50 == i$var109)) {
																				for(int var84 = 0; var84 < noStates; var84 += 1) {
																					if((var84 == traceTempVariable$s$54_1)) {
																						{
																							{
																								double cv$temp$8$var111;
																								{
																									// Constructing a random variable input for use later.
																									double var111 = cpuMean[traceTempVariable$s$54_1];
																									cv$temp$8$var111 = var111;
																								}
																								double cv$temp$9$var112;
																								{
																									// Constructing a random variable input for use later.
																									double var112 = cpuVar[traceTempVariable$s$54_1];
																									cv$temp$9$var112 = var112;
																								}
																								
																								// Record the probability of sample task 119 generating output with current configuration.
																								if(((Math.log(cv$probabilitySample45Value52) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value52) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value52) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value52) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value52) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))));
																								}
																								
																								// Recorded the probability of reaching sample task 119 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value52);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
									int traceTempVariable$s$33_1 = cv$currentValue;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109)) {
											if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
												// The body will execute, so should not be executed again
												guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
												
												// Processing sample task 119 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 45.
														if((0 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == traceTempVariable$s$33_1)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$33_1)) {
																			{
																				{
																					double cv$temp$36$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$33_1];
																						cv$temp$36$var111 = var111;
																					}
																					double cv$temp$37$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$33_1];
																						cv$temp$37$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$36$var111) / Math.sqrt(cv$temp$37$var112))) - (0.5 * Math.log(cv$temp$37$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$36$var111) / Math.sqrt(cv$temp$37$var112))) - (0.5 * Math.log(cv$temp$37$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$36$var111) / Math.sqrt(cv$temp$37$var112))) - (0.5 * Math.log(cv$temp$37$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$36$var111) / Math.sqrt(cv$temp$37$var112))) - (0.5 * Math.log(cv$temp$37$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$36$var111) / Math.sqrt(cv$temp$37$var112))) - (0.5 * Math.log(cv$temp$37$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 45.
														int traceTempVariable$s$113_1 = cv$currentValue;
														if((index$i$1 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == traceTempVariable$s$113_1)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$113_1)) {
																			{
																				{
																					double cv$temp$38$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$113_1];
																						cv$temp$38$var111 = var111;
																					}
																					double cv$temp$39$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$113_1];
																						cv$temp$39$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$38$var111) / Math.sqrt(cv$temp$39$var112))) - (0.5 * Math.log(cv$temp$39$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$38$var111) / Math.sqrt(cv$temp$39$var112))) - (0.5 * Math.log(cv$temp$39$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$38$var111) / Math.sqrt(cv$temp$39$var112))) - (0.5 * Math.log(cv$temp$39$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$38$var111) / Math.sqrt(cv$temp$39$var112))) - (0.5 * Math.log(cv$temp$39$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$38$var111) / Math.sqrt(cv$temp$39$var112))) - (0.5 * Math.log(cv$temp$39$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														for(int index$i$114 = 1; index$i$114 < samples; index$i$114 += 1) {
															if(!(index$i$114 == index$i$1)) {
																// Enumerating the possible outputs of Categorical 39.
																for(int index$sample45$115 = 0; index$sample45$115 < noStates; index$sample45$115 += 1) {
																	int distributionTempVariable$var40$117 = index$sample45$115;
																	
																	// Update the probability of sampling this value from the distribution value.
																	double cv$probabilitySample45Value116 = (1.0 * distribution$sample45[((index$i$114 - 1) / 1)][index$sample45$115]);
																	int traceTempVariable$s$118_1 = distributionTempVariable$var40$117;
																	if((index$i$114 == i$var109)) {
																		for(int var52 = 0; var52 < noStates; var52 += 1) {
																			if((var52 == traceTempVariable$s$118_1)) {
																				for(int var84 = 0; var84 < noStates; var84 += 1) {
																					if((var84 == traceTempVariable$s$118_1)) {
																						{
																							{
																								double cv$temp$40$var111;
																								{
																									// Constructing a random variable input for use later.
																									double var111 = cpuMean[traceTempVariable$s$118_1];
																									cv$temp$40$var111 = var111;
																								}
																								double cv$temp$41$var112;
																								{
																									// Constructing a random variable input for use later.
																									double var112 = cpuVar[traceTempVariable$s$118_1];
																									cv$temp$41$var112 = var112;
																								}
																								
																								// Record the probability of sample task 119 generating output with current configuration.
																								if(((Math.log(cv$probabilitySample45Value116) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$40$var111) / Math.sqrt(cv$temp$41$var112))) - (0.5 * Math.log(cv$temp$41$var112)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value116) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$40$var111) / Math.sqrt(cv$temp$41$var112))) - (0.5 * Math.log(cv$temp$41$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value116) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$40$var111) / Math.sqrt(cv$temp$41$var112))) - (0.5 * Math.log(cv$temp$41$var112))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value116) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$40$var111) / Math.sqrt(cv$temp$41$var112))) - (0.5 * Math.log(cv$temp$41$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value116) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$40$var111) / Math.sqrt(cv$temp$41$var112))) - (0.5 * Math.log(cv$temp$41$var112)))));
																								}
																								
																								// Recorded the probability of reaching sample task 119 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value116);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
							
							// Processing random variable 118.
							{
								// Looking for a path between Sample 45 and consumer Gaussian 118.
								{
									// Guard to check that at most one copy of the code is executed for a given random
									// variable instance.
									boolean[] guard$sample45gaussian123 = guard$sample45gaussian123$global;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109))
											// Set the flags to false
											guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
									}
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109))
											// Set the flags to false
											guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
									}
									int traceTempVariable$s$223_1 = cv$currentValue;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109)) {
											if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
												// The body will execute, so should not be executed again
												guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
												
												// Processing sample task 124 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 45.
														for(int var63 = 0; var63 < noStates; var63 += 1) {
															if((var63 == traceTempVariable$s$223_1)) {
																if((0 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$223_1)) {
																			{
																				{
																					double cv$temp$68$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$223_1];
																						cv$temp$68$var116 = var116;
																					}
																					double cv$temp$69$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$223_1];
																						cv$temp$69$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$68$var116) / Math.sqrt(cv$temp$69$var117))) - (0.5 * Math.log(cv$temp$69$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$68$var116) / Math.sqrt(cv$temp$69$var117))) - (0.5 * Math.log(cv$temp$69$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$68$var116) / Math.sqrt(cv$temp$69$var117))) - (0.5 * Math.log(cv$temp$69$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$68$var116) / Math.sqrt(cv$temp$69$var117))) - (0.5 * Math.log(cv$temp$69$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$68$var116) / Math.sqrt(cv$temp$69$var117))) - (0.5 * Math.log(cv$temp$69$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 45.
														for(int var63 = 0; var63 < noStates; var63 += 1) {
															if((var63 == traceTempVariable$s$223_1)) {
																int traceTempVariable$s$243_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$243_1)) {
																			{
																				{
																					double cv$temp$70$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$243_1];
																						cv$temp$70$var116 = var116;
																					}
																					double cv$temp$71$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$243_1];
																						cv$temp$71$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$70$var116) / Math.sqrt(cv$temp$71$var117))) - (0.5 * Math.log(cv$temp$71$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$70$var116) / Math.sqrt(cv$temp$71$var117))) - (0.5 * Math.log(cv$temp$71$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$70$var116) / Math.sqrt(cv$temp$71$var117))) - (0.5 * Math.log(cv$temp$71$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$70$var116) / Math.sqrt(cv$temp$71$var117))) - (0.5 * Math.log(cv$temp$71$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$70$var116) / Math.sqrt(cv$temp$71$var117))) - (0.5 * Math.log(cv$temp$71$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
																for(int index$i$244 = 1; index$i$244 < samples; index$i$244 += 1) {
																	if(!(index$i$244 == index$i$1)) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$245 = 0; index$sample45$245 < noStates; index$sample45$245 += 1) {
																			int distributionTempVariable$var40$247 = index$sample45$245;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value246 = (1.0 * distribution$sample45[((index$i$244 - 1) / 1)][index$sample45$245]);
																			int traceTempVariable$s$248_1 = distributionTempVariable$var40$247;
																			if((index$i$244 == i$var109)) {
																				for(int var94 = 0; var94 < noStates; var94 += 1) {
																					if((var94 == traceTempVariable$s$248_1)) {
																						{
																							{
																								double cv$temp$72$var116;
																								{
																									// Constructing a random variable input for use later.
																									double var116 = memMean[traceTempVariable$s$248_1];
																									cv$temp$72$var116 = var116;
																								}
																								double cv$temp$73$var117;
																								{
																									// Constructing a random variable input for use later.
																									double var117 = memVar[traceTempVariable$s$248_1];
																									cv$temp$73$var117 = var117;
																								}
																								
																								// Record the probability of sample task 124 generating output with current configuration.
																								if(((Math.log(cv$probabilitySample45Value246) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$72$var116) / Math.sqrt(cv$temp$73$var117))) - (0.5 * Math.log(cv$temp$73$var117)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value246) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$72$var116) / Math.sqrt(cv$temp$73$var117))) - (0.5 * Math.log(cv$temp$73$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value246) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$72$var116) / Math.sqrt(cv$temp$73$var117))) - (0.5 * Math.log(cv$temp$73$var117))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value246) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$72$var116) / Math.sqrt(cv$temp$73$var117))) - (0.5 * Math.log(cv$temp$73$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value246) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$72$var116) / Math.sqrt(cv$temp$73$var117))) - (0.5 * Math.log(cv$temp$73$var117)))));
																								}
																								
																								// Recorded the probability of reaching sample task 124 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value246);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
									int traceTempVariable$s$227_1 = cv$currentValue;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109)) {
											if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
												// The body will execute, so should not be executed again
												guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
												
												// Processing sample task 124 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 45.
														if((0 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == traceTempVariable$s$227_1)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$227_1)) {
																			{
																				{
																					double cv$temp$100$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$227_1];
																						cv$temp$100$var116 = var116;
																					}
																					double cv$temp$101$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$227_1];
																						cv$temp$101$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$100$var116) / Math.sqrt(cv$temp$101$var117))) - (0.5 * Math.log(cv$temp$101$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$100$var116) / Math.sqrt(cv$temp$101$var117))) - (0.5 * Math.log(cv$temp$101$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$100$var116) / Math.sqrt(cv$temp$101$var117))) - (0.5 * Math.log(cv$temp$101$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$100$var116) / Math.sqrt(cv$temp$101$var117))) - (0.5 * Math.log(cv$temp$101$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$100$var116) / Math.sqrt(cv$temp$101$var117))) - (0.5 * Math.log(cv$temp$101$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 45.
														int traceTempVariable$s$307_1 = cv$currentValue;
														if((index$i$1 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == traceTempVariable$s$307_1)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$307_1)) {
																			{
																				{
																					double cv$temp$102$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$307_1];
																						cv$temp$102$var116 = var116;
																					}
																					double cv$temp$103$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$307_1];
																						cv$temp$103$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$102$var116) / Math.sqrt(cv$temp$103$var117))) - (0.5 * Math.log(cv$temp$103$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$102$var116) / Math.sqrt(cv$temp$103$var117))) - (0.5 * Math.log(cv$temp$103$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$102$var116) / Math.sqrt(cv$temp$103$var117))) - (0.5 * Math.log(cv$temp$103$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$102$var116) / Math.sqrt(cv$temp$103$var117))) - (0.5 * Math.log(cv$temp$103$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$102$var116) / Math.sqrt(cv$temp$103$var117))) - (0.5 * Math.log(cv$temp$103$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														for(int index$i$308 = 1; index$i$308 < samples; index$i$308 += 1) {
															if(!(index$i$308 == index$i$1)) {
																// Enumerating the possible outputs of Categorical 39.
																for(int index$sample45$309 = 0; index$sample45$309 < noStates; index$sample45$309 += 1) {
																	int distributionTempVariable$var40$311 = index$sample45$309;
																	
																	// Update the probability of sampling this value from the distribution value.
																	double cv$probabilitySample45Value310 = (1.0 * distribution$sample45[((index$i$308 - 1) / 1)][index$sample45$309]);
																	int traceTempVariable$s$312_1 = distributionTempVariable$var40$311;
																	if((index$i$308 == i$var109)) {
																		for(int var63 = 0; var63 < noStates; var63 += 1) {
																			if((var63 == traceTempVariable$s$312_1)) {
																				for(int var94 = 0; var94 < noStates; var94 += 1) {
																					if((var94 == traceTempVariable$s$312_1)) {
																						{
																							{
																								double cv$temp$104$var116;
																								{
																									// Constructing a random variable input for use later.
																									double var116 = memMean[traceTempVariable$s$312_1];
																									cv$temp$104$var116 = var116;
																								}
																								double cv$temp$105$var117;
																								{
																									// Constructing a random variable input for use later.
																									double var117 = memVar[traceTempVariable$s$312_1];
																									cv$temp$105$var117 = var117;
																								}
																								
																								// Record the probability of sample task 124 generating output with current configuration.
																								if(((Math.log(cv$probabilitySample45Value310) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$104$var116) / Math.sqrt(cv$temp$105$var117))) - (0.5 * Math.log(cv$temp$105$var117)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value310) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$104$var116) / Math.sqrt(cv$temp$105$var117))) - (0.5 * Math.log(cv$temp$105$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value310) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$104$var116) / Math.sqrt(cv$temp$105$var117))) - (0.5 * Math.log(cv$temp$105$var117))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value310) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$104$var116) / Math.sqrt(cv$temp$105$var117))) - (0.5 * Math.log(cv$temp$105$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value310) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$104$var116) / Math.sqrt(cv$temp$105$var117))) - (0.5 * Math.log(cv$temp$105$var117)))));
																								}
																								
																								// Recorded the probability of reaching sample task 124 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value310);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
							
							// Processing random variable 123.
							{
								// Looking for a path between Sample 45 and consumer Gaussian 123.
								{
									// Guard to check that at most one copy of the code is executed for a given random
									// variable instance.
									boolean[] guard$sample45gaussian128 = guard$sample45gaussian128$global;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109))
											// Set the flags to false
											guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
									}
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109))
											// Set the flags to false
											guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
									}
									int traceTempVariable$s$417_1 = cv$currentValue;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109)) {
											if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
												// The body will execute, so should not be executed again
												guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
												
												// Processing sample task 129 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 45.
														for(int var74 = 0; var74 < noStates; var74 += 1) {
															if((var74 == traceTempVariable$s$417_1)) {
																if((0 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$417_1)) {
																			{
																				{
																					double cv$temp$132$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$417_1];
																						cv$temp$132$var121 = var121;
																					}
																					double cv$temp$133$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$417_1];
																						cv$temp$133$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$132$var121) / Math.sqrt(cv$temp$133$var122))) - (0.5 * Math.log(cv$temp$133$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$132$var121) / Math.sqrt(cv$temp$133$var122))) - (0.5 * Math.log(cv$temp$133$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$132$var121) / Math.sqrt(cv$temp$133$var122))) - (0.5 * Math.log(cv$temp$133$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$132$var121) / Math.sqrt(cv$temp$133$var122))) - (0.5 * Math.log(cv$temp$133$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$132$var121) / Math.sqrt(cv$temp$133$var122))) - (0.5 * Math.log(cv$temp$133$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 45.
														for(int var74 = 0; var74 < noStates; var74 += 1) {
															if((var74 == traceTempVariable$s$417_1)) {
																int traceTempVariable$s$437_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$437_1)) {
																			{
																				{
																					double cv$temp$134$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$437_1];
																						cv$temp$134$var121 = var121;
																					}
																					double cv$temp$135$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$437_1];
																						cv$temp$135$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$134$var121) / Math.sqrt(cv$temp$135$var122))) - (0.5 * Math.log(cv$temp$135$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$134$var121) / Math.sqrt(cv$temp$135$var122))) - (0.5 * Math.log(cv$temp$135$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$134$var121) / Math.sqrt(cv$temp$135$var122))) - (0.5 * Math.log(cv$temp$135$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$134$var121) / Math.sqrt(cv$temp$135$var122))) - (0.5 * Math.log(cv$temp$135$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$134$var121) / Math.sqrt(cv$temp$135$var122))) - (0.5 * Math.log(cv$temp$135$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
																for(int index$i$438 = 1; index$i$438 < samples; index$i$438 += 1) {
																	if(!(index$i$438 == index$i$1)) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$439 = 0; index$sample45$439 < noStates; index$sample45$439 += 1) {
																			int distributionTempVariable$var40$441 = index$sample45$439;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value440 = (1.0 * distribution$sample45[((index$i$438 - 1) / 1)][index$sample45$439]);
																			int traceTempVariable$s$442_1 = distributionTempVariable$var40$441;
																			if((index$i$438 == i$var109)) {
																				for(int var104 = 0; var104 < noStates; var104 += 1) {
																					if((var104 == traceTempVariable$s$442_1)) {
																						{
																							{
																								double cv$temp$136$var121;
																								{
																									// Constructing a random variable input for use later.
																									double var121 = pageFaultsMean[traceTempVariable$s$442_1];
																									cv$temp$136$var121 = var121;
																								}
																								double cv$temp$137$var122;
																								{
																									// Constructing a random variable input for use later.
																									double var122 = pageFaultsVar[traceTempVariable$s$442_1];
																									cv$temp$137$var122 = var122;
																								}
																								
																								// Record the probability of sample task 129 generating output with current configuration.
																								if(((Math.log(cv$probabilitySample45Value440) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$136$var121) / Math.sqrt(cv$temp$137$var122))) - (0.5 * Math.log(cv$temp$137$var122)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value440) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$136$var121) / Math.sqrt(cv$temp$137$var122))) - (0.5 * Math.log(cv$temp$137$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value440) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$136$var121) / Math.sqrt(cv$temp$137$var122))) - (0.5 * Math.log(cv$temp$137$var122))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value440) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$136$var121) / Math.sqrt(cv$temp$137$var122))) - (0.5 * Math.log(cv$temp$137$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value440) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$136$var121) / Math.sqrt(cv$temp$137$var122))) - (0.5 * Math.log(cv$temp$137$var122)))));
																								}
																								
																								// Recorded the probability of reaching sample task 129 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value440);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
									int traceTempVariable$s$421_1 = cv$currentValue;
									for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
										if((i$var34 == i$var109)) {
											if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
												// The body will execute, so should not be executed again
												guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
												
												// Processing sample task 129 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 45.
														if((0 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == traceTempVariable$s$421_1)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$421_1)) {
																			{
																				{
																					double cv$temp$164$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$421_1];
																						cv$temp$164$var121 = var121;
																					}
																					double cv$temp$165$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$421_1];
																						cv$temp$165$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$164$var121) / Math.sqrt(cv$temp$165$var122))) - (0.5 * Math.log(cv$temp$165$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$164$var121) / Math.sqrt(cv$temp$165$var122))) - (0.5 * Math.log(cv$temp$165$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$164$var121) / Math.sqrt(cv$temp$165$var122))) - (0.5 * Math.log(cv$temp$165$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$164$var121) / Math.sqrt(cv$temp$165$var122))) - (0.5 * Math.log(cv$temp$165$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$164$var121) / Math.sqrt(cv$temp$165$var122))) - (0.5 * Math.log(cv$temp$165$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 45.
														int traceTempVariable$s$501_1 = cv$currentValue;
														if((index$i$1 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == traceTempVariable$s$501_1)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$501_1)) {
																			{
																				{
																					double cv$temp$166$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$501_1];
																						cv$temp$166$var121 = var121;
																					}
																					double cv$temp$167$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$501_1];
																						cv$temp$167$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$166$var121) / Math.sqrt(cv$temp$167$var122))) - (0.5 * Math.log(cv$temp$167$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$166$var121) / Math.sqrt(cv$temp$167$var122))) - (0.5 * Math.log(cv$temp$167$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$166$var121) / Math.sqrt(cv$temp$167$var122))) - (0.5 * Math.log(cv$temp$167$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$166$var121) / Math.sqrt(cv$temp$167$var122))) - (0.5 * Math.log(cv$temp$167$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$166$var121) / Math.sqrt(cv$temp$167$var122))) - (0.5 * Math.log(cv$temp$167$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
														for(int index$i$502 = 1; index$i$502 < samples; index$i$502 += 1) {
															if(!(index$i$502 == index$i$1)) {
																// Enumerating the possible outputs of Categorical 39.
																for(int index$sample45$503 = 0; index$sample45$503 < noStates; index$sample45$503 += 1) {
																	int distributionTempVariable$var40$505 = index$sample45$503;
																	
																	// Update the probability of sampling this value from the distribution value.
																	double cv$probabilitySample45Value504 = (1.0 * distribution$sample45[((index$i$502 - 1) / 1)][index$sample45$503]);
																	int traceTempVariable$s$506_1 = distributionTempVariable$var40$505;
																	if((index$i$502 == i$var109)) {
																		for(int var74 = 0; var74 < noStates; var74 += 1) {
																			if((var74 == traceTempVariable$s$506_1)) {
																				for(int var104 = 0; var104 < noStates; var104 += 1) {
																					if((var104 == traceTempVariable$s$506_1)) {
																						{
																							{
																								double cv$temp$168$var121;
																								{
																									// Constructing a random variable input for use later.
																									double var121 = pageFaultsMean[traceTempVariable$s$506_1];
																									cv$temp$168$var121 = var121;
																								}
																								double cv$temp$169$var122;
																								{
																									// Constructing a random variable input for use later.
																									double var122 = pageFaultsVar[traceTempVariable$s$506_1];
																									cv$temp$169$var122 = var122;
																								}
																								
																								// Record the probability of sample task 129 generating output with current configuration.
																								if(((Math.log(cv$probabilitySample45Value504) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$168$var121) / Math.sqrt(cv$temp$169$var122))) - (0.5 * Math.log(cv$temp$169$var122)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value504) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$168$var121) / Math.sqrt(cv$temp$169$var122))) - (0.5 * Math.log(cv$temp$169$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value504) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$168$var121) / Math.sqrt(cv$temp$169$var122))) - (0.5 * Math.log(cv$temp$169$var122))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value504) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$168$var121) / Math.sqrt(cv$temp$169$var122))) - (0.5 * Math.log(cv$temp$169$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value504) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$168$var121) / Math.sqrt(cv$temp$169$var122))) - (0.5 * Math.log(cv$temp$169$var122)))));
																								}
																								
																								// Recorded the probability of reaching sample task 129 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value504);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
							
							// Add the values for the source and any standard consumers for this configuration
							// of arguments to the source.
							if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
								cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
							else {
								// If the second value is -infinity.
								if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
									cv$stateProbabilityValue = cv$accumulatedProbabilities;
								else
									cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
							}
						}
					}
				}
			} else {
				if(true) {
					// Enumerating the possible outputs of Categorical 29.
					for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
						int distributionTempVariable$var30$5 = index$sample35$3;
						
						// Update the probability of sampling this value from the distribution value.
						double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
						int traceTempVariable$var37$6_1 = distributionTempVariable$var30$5;
						if((0 == (i$var34 - 1))) {
							for(int var21 = 0; var21 < noStates; var21 += 1) {
								if((var21 == traceTempVariable$var37$6_1)) {
									// Record the reached probability density.
									cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + cv$probabilitySample35Value4);
									double[] cv$temp$1$var38;
									{
										// Constructing a random variable input for use later.
										double[] var38 = m[traceTempVariable$var37$6_1];
										cv$temp$1$var38 = var38;
									}
									
									// An accumulator to allow the value for each distribution to be constructed before
									// it is added to the index probabilities.
									double cv$accumulatedProbabilities = (Math.log(cv$probabilitySample35Value4) + (((0.0 <= cv$currentValue) && (cv$currentValue < cv$temp$1$var38.length))?Math.log(cv$temp$1$var38[cv$currentValue]):Double.NEGATIVE_INFINITY));
									
									// Processing random variable 39.
									{
										// Looking for a path between Sample 45 and consumer Categorical 39.
										{
											int traceTempVariable$var37$18_1 = cv$currentValue;
										}
									}
									
									// Processing random variable 113.
									{
										// Looking for a path between Sample 45 and consumer Gaussian 113.
										{
											// Guard to check that at most one copy of the code is executed for a given random
											// variable instance.
											boolean[] guard$sample45gaussian118 = guard$sample45gaussian118$global;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
											}
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
											}
											int traceTempVariable$s$30_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 119 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																for(int var52 = 0; var52 < noStates; var52 += 1) {
																	if((var52 == traceTempVariable$s$30_1)) {
																		int traceTempVariable$s$58_1 = distributionTempVariable$var30$5;
																		if((0 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$58_1)) {
																					{
																						{
																							double cv$temp$10$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$58_1];
																								cv$temp$10$var111 = var111;
																							}
																							double cv$temp$11$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$58_1];
																								cv$temp$11$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		if(!true) {
																			// Enumerating the possible outputs of Categorical 29.
																			for(int index$sample35$59 = 0; index$sample35$59 < noStates; index$sample35$59 += 1) {
																				int distributionTempVariable$var30$61 = index$sample35$59;
																				
																				// Update the probability of sampling this value from the distribution value.
																				double cv$probabilitySample35Value60 = (1.0 * distribution$sample35[index$sample35$59]);
																				int traceTempVariable$s$62_1 = distributionTempVariable$var30$61;
																				if((0 == i$var109)) {
																					for(int var84 = 0; var84 < noStates; var84 += 1) {
																						if((var84 == traceTempVariable$s$62_1)) {
																							{
																								{
																									double cv$temp$12$var111;
																									{
																										// Constructing a random variable input for use later.
																										double var111 = cpuMean[traceTempVariable$s$62_1];
																										cv$temp$12$var111 = var111;
																									}
																									double cv$temp$13$var112;
																									{
																										// Constructing a random variable input for use later.
																										double var112 = cpuVar[traceTempVariable$s$62_1];
																										cv$temp$13$var112 = var112;
																									}
																									
																									// Record the probability of sample task 119 generating output with current configuration.
																									if(((Math.log(cv$probabilitySample35Value60) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) < cv$accumulatedConsumerProbabilities))
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value60) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																									else {
																										// If the second value is -infinity.
																										if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																											cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value60) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112))));
																										else
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value60) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value60) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))));
																									}
																									
																									// Recorded the probability of reaching sample task 119 with the current configuration.
																									cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value60);
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																for(int var52 = 0; var52 < noStates; var52 += 1) {
																	if((var52 == traceTempVariable$s$30_1)) {
																		int traceTempVariable$s$66_1 = cv$currentValue;
																		if((index$i$1 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$66_1)) {
																					{
																						{
																							double cv$temp$14$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$66_1];
																								cv$temp$14$var111 = var111;
																							}
																							double cv$temp$15$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$66_1];
																								cv$temp$15$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		for(int index$i$67 = 1; index$i$67 < samples; index$i$67 += 1) {
																			if(!(index$i$67 == index$i$1)) {
																				// Enumerating the possible outputs of Categorical 39.
																				for(int index$sample45$68 = 0; index$sample45$68 < noStates; index$sample45$68 += 1) {
																					int distributionTempVariable$var40$70 = index$sample45$68;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample45Value69 = (1.0 * distribution$sample45[((index$i$67 - 1) / 1)][index$sample45$68]);
																					int traceTempVariable$s$71_1 = distributionTempVariable$var40$70;
																					if((index$i$67 == i$var109)) {
																						for(int var84 = 0; var84 < noStates; var84 += 1) {
																							if((var84 == traceTempVariable$s$71_1)) {
																								{
																									{
																										double cv$temp$16$var111;
																										{
																											// Constructing a random variable input for use later.
																											double var111 = cpuMean[traceTempVariable$s$71_1];
																											cv$temp$16$var111 = var111;
																										}
																										double cv$temp$17$var112;
																										{
																											// Constructing a random variable input for use later.
																											double var112 = cpuVar[traceTempVariable$s$71_1];
																											cv$temp$17$var112 = var112;
																										}
																										
																										// Record the probability of sample task 119 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value69) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value69) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value69) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value69) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value69) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))));
																										}
																										
																										// Recorded the probability of reaching sample task 119 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value69);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
											int traceTempVariable$s$34_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 119 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$123_1 = distributionTempVariable$var30$5;
																if((0 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$123_1)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$123_1)) {
																					{
																						{
																							double cv$temp$42$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$123_1];
																								cv$temp$42$var111 = var111;
																							}
																							double cv$temp$43$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$123_1];
																								cv$temp$43$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$42$var111) / Math.sqrt(cv$temp$43$var112))) - (0.5 * Math.log(cv$temp$43$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$42$var111) / Math.sqrt(cv$temp$43$var112))) - (0.5 * Math.log(cv$temp$43$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$42$var111) / Math.sqrt(cv$temp$43$var112))) - (0.5 * Math.log(cv$temp$43$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$42$var111) / Math.sqrt(cv$temp$43$var112))) - (0.5 * Math.log(cv$temp$43$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$42$var111) / Math.sqrt(cv$temp$43$var112))) - (0.5 * Math.log(cv$temp$43$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																if(!true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$124 = 0; index$sample35$124 < noStates; index$sample35$124 += 1) {
																		int distributionTempVariable$var30$126 = index$sample35$124;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value125 = (1.0 * distribution$sample35[index$sample35$124]);
																		int traceTempVariable$s$127_1 = distributionTempVariable$var30$126;
																		if((0 == i$var109)) {
																			for(int var52 = 0; var52 < noStates; var52 += 1) {
																				if((var52 == traceTempVariable$s$127_1)) {
																					for(int var84 = 0; var84 < noStates; var84 += 1) {
																						if((var84 == traceTempVariable$s$127_1)) {
																							{
																								{
																									double cv$temp$44$var111;
																									{
																										// Constructing a random variable input for use later.
																										double var111 = cpuMean[traceTempVariable$s$127_1];
																										cv$temp$44$var111 = var111;
																									}
																									double cv$temp$45$var112;
																									{
																										// Constructing a random variable input for use later.
																										double var112 = cpuVar[traceTempVariable$s$127_1];
																										cv$temp$45$var112 = var112;
																									}
																									
																									// Record the probability of sample task 119 generating output with current configuration.
																									if(((Math.log(cv$probabilitySample35Value125) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$44$var111) / Math.sqrt(cv$temp$45$var112))) - (0.5 * Math.log(cv$temp$45$var112)))) < cv$accumulatedConsumerProbabilities))
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value125) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$44$var111) / Math.sqrt(cv$temp$45$var112))) - (0.5 * Math.log(cv$temp$45$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																									else {
																										// If the second value is -infinity.
																										if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																											cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value125) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$44$var111) / Math.sqrt(cv$temp$45$var112))) - (0.5 * Math.log(cv$temp$45$var112))));
																										else
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value125) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$44$var111) / Math.sqrt(cv$temp$45$var112))) - (0.5 * Math.log(cv$temp$45$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value125) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$44$var111) / Math.sqrt(cv$temp$45$var112))) - (0.5 * Math.log(cv$temp$45$var112)))));
																									}
																									
																									// Recorded the probability of reaching sample task 119 with the current configuration.
																									cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value125);
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$132_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$132_1)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$132_1)) {
																					{
																						{
																							double cv$temp$46$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$132_1];
																								cv$temp$46$var111 = var111;
																							}
																							double cv$temp$47$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$132_1];
																								cv$temp$47$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$46$var111) / Math.sqrt(cv$temp$47$var112))) - (0.5 * Math.log(cv$temp$47$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$46$var111) / Math.sqrt(cv$temp$47$var112))) - (0.5 * Math.log(cv$temp$47$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$46$var111) / Math.sqrt(cv$temp$47$var112))) - (0.5 * Math.log(cv$temp$47$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$46$var111) / Math.sqrt(cv$temp$47$var112))) - (0.5 * Math.log(cv$temp$47$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$46$var111) / Math.sqrt(cv$temp$47$var112))) - (0.5 * Math.log(cv$temp$47$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																for(int index$i$133 = 1; index$i$133 < samples; index$i$133 += 1) {
																	if(!(index$i$133 == index$i$1)) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$134 = 0; index$sample45$134 < noStates; index$sample45$134 += 1) {
																			int distributionTempVariable$var40$136 = index$sample45$134;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value135 = (1.0 * distribution$sample45[((index$i$133 - 1) / 1)][index$sample45$134]);
																			int traceTempVariable$s$137_1 = distributionTempVariable$var40$136;
																			if((index$i$133 == i$var109)) {
																				for(int var52 = 0; var52 < noStates; var52 += 1) {
																					if((var52 == traceTempVariable$s$137_1)) {
																						for(int var84 = 0; var84 < noStates; var84 += 1) {
																							if((var84 == traceTempVariable$s$137_1)) {
																								{
																									{
																										double cv$temp$48$var111;
																										{
																											// Constructing a random variable input for use later.
																											double var111 = cpuMean[traceTempVariable$s$137_1];
																											cv$temp$48$var111 = var111;
																										}
																										double cv$temp$49$var112;
																										{
																											// Constructing a random variable input for use later.
																											double var112 = cpuVar[traceTempVariable$s$137_1];
																											cv$temp$49$var112 = var112;
																										}
																										
																										// Record the probability of sample task 119 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value135) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$48$var111) / Math.sqrt(cv$temp$49$var112))) - (0.5 * Math.log(cv$temp$49$var112)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value135) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$48$var111) / Math.sqrt(cv$temp$49$var112))) - (0.5 * Math.log(cv$temp$49$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value135) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$48$var111) / Math.sqrt(cv$temp$49$var112))) - (0.5 * Math.log(cv$temp$49$var112))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value135) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$48$var111) / Math.sqrt(cv$temp$49$var112))) - (0.5 * Math.log(cv$temp$49$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value135) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$48$var111) / Math.sqrt(cv$temp$49$var112))) - (0.5 * Math.log(cv$temp$49$var112)))));
																										}
																										
																										// Recorded the probability of reaching sample task 119 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value135);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
										}
									}
									
									// Processing random variable 118.
									{
										// Looking for a path between Sample 45 and consumer Gaussian 118.
										{
											// Guard to check that at most one copy of the code is executed for a given random
											// variable instance.
											boolean[] guard$sample45gaussian123 = guard$sample45gaussian123$global;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
											}
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
											}
											int traceTempVariable$s$224_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 124 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																for(int var63 = 0; var63 < noStates; var63 += 1) {
																	if((var63 == traceTempVariable$s$224_1)) {
																		int traceTempVariable$s$252_1 = distributionTempVariable$var30$5;
																		if((0 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$252_1)) {
																					{
																						{
																							double cv$temp$74$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$252_1];
																								cv$temp$74$var116 = var116;
																							}
																							double cv$temp$75$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$252_1];
																								cv$temp$75$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$74$var116) / Math.sqrt(cv$temp$75$var117))) - (0.5 * Math.log(cv$temp$75$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$74$var116) / Math.sqrt(cv$temp$75$var117))) - (0.5 * Math.log(cv$temp$75$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$74$var116) / Math.sqrt(cv$temp$75$var117))) - (0.5 * Math.log(cv$temp$75$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$74$var116) / Math.sqrt(cv$temp$75$var117))) - (0.5 * Math.log(cv$temp$75$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$74$var116) / Math.sqrt(cv$temp$75$var117))) - (0.5 * Math.log(cv$temp$75$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		if(!true) {
																			// Enumerating the possible outputs of Categorical 29.
																			for(int index$sample35$253 = 0; index$sample35$253 < noStates; index$sample35$253 += 1) {
																				int distributionTempVariable$var30$255 = index$sample35$253;
																				
																				// Update the probability of sampling this value from the distribution value.
																				double cv$probabilitySample35Value254 = (1.0 * distribution$sample35[index$sample35$253]);
																				int traceTempVariable$s$256_1 = distributionTempVariable$var30$255;
																				if((0 == i$var109)) {
																					for(int var94 = 0; var94 < noStates; var94 += 1) {
																						if((var94 == traceTempVariable$s$256_1)) {
																							{
																								{
																									double cv$temp$76$var116;
																									{
																										// Constructing a random variable input for use later.
																										double var116 = memMean[traceTempVariable$s$256_1];
																										cv$temp$76$var116 = var116;
																									}
																									double cv$temp$77$var117;
																									{
																										// Constructing a random variable input for use later.
																										double var117 = memVar[traceTempVariable$s$256_1];
																										cv$temp$77$var117 = var117;
																									}
																									
																									// Record the probability of sample task 124 generating output with current configuration.
																									if(((Math.log(cv$probabilitySample35Value254) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$76$var116) / Math.sqrt(cv$temp$77$var117))) - (0.5 * Math.log(cv$temp$77$var117)))) < cv$accumulatedConsumerProbabilities))
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value254) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$76$var116) / Math.sqrt(cv$temp$77$var117))) - (0.5 * Math.log(cv$temp$77$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																									else {
																										// If the second value is -infinity.
																										if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																											cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value254) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$76$var116) / Math.sqrt(cv$temp$77$var117))) - (0.5 * Math.log(cv$temp$77$var117))));
																										else
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value254) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$76$var116) / Math.sqrt(cv$temp$77$var117))) - (0.5 * Math.log(cv$temp$77$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value254) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$76$var116) / Math.sqrt(cv$temp$77$var117))) - (0.5 * Math.log(cv$temp$77$var117)))));
																									}
																									
																									// Recorded the probability of reaching sample task 124 with the current configuration.
																									cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value254);
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																for(int var63 = 0; var63 < noStates; var63 += 1) {
																	if((var63 == traceTempVariable$s$224_1)) {
																		int traceTempVariable$s$260_1 = cv$currentValue;
																		if((index$i$1 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$260_1)) {
																					{
																						{
																							double cv$temp$78$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$260_1];
																								cv$temp$78$var116 = var116;
																							}
																							double cv$temp$79$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$260_1];
																								cv$temp$79$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$78$var116) / Math.sqrt(cv$temp$79$var117))) - (0.5 * Math.log(cv$temp$79$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$78$var116) / Math.sqrt(cv$temp$79$var117))) - (0.5 * Math.log(cv$temp$79$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$78$var116) / Math.sqrt(cv$temp$79$var117))) - (0.5 * Math.log(cv$temp$79$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$78$var116) / Math.sqrt(cv$temp$79$var117))) - (0.5 * Math.log(cv$temp$79$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$78$var116) / Math.sqrt(cv$temp$79$var117))) - (0.5 * Math.log(cv$temp$79$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		for(int index$i$261 = 1; index$i$261 < samples; index$i$261 += 1) {
																			if(!(index$i$261 == index$i$1)) {
																				// Enumerating the possible outputs of Categorical 39.
																				for(int index$sample45$262 = 0; index$sample45$262 < noStates; index$sample45$262 += 1) {
																					int distributionTempVariable$var40$264 = index$sample45$262;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample45Value263 = (1.0 * distribution$sample45[((index$i$261 - 1) / 1)][index$sample45$262]);
																					int traceTempVariable$s$265_1 = distributionTempVariable$var40$264;
																					if((index$i$261 == i$var109)) {
																						for(int var94 = 0; var94 < noStates; var94 += 1) {
																							if((var94 == traceTempVariable$s$265_1)) {
																								{
																									{
																										double cv$temp$80$var116;
																										{
																											// Constructing a random variable input for use later.
																											double var116 = memMean[traceTempVariable$s$265_1];
																											cv$temp$80$var116 = var116;
																										}
																										double cv$temp$81$var117;
																										{
																											// Constructing a random variable input for use later.
																											double var117 = memVar[traceTempVariable$s$265_1];
																											cv$temp$81$var117 = var117;
																										}
																										
																										// Record the probability of sample task 124 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value263) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$80$var116) / Math.sqrt(cv$temp$81$var117))) - (0.5 * Math.log(cv$temp$81$var117)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value263) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$80$var116) / Math.sqrt(cv$temp$81$var117))) - (0.5 * Math.log(cv$temp$81$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value263) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$80$var116) / Math.sqrt(cv$temp$81$var117))) - (0.5 * Math.log(cv$temp$81$var117))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value263) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$80$var116) / Math.sqrt(cv$temp$81$var117))) - (0.5 * Math.log(cv$temp$81$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value263) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$80$var116) / Math.sqrt(cv$temp$81$var117))) - (0.5 * Math.log(cv$temp$81$var117)))));
																										}
																										
																										// Recorded the probability of reaching sample task 124 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value263);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
											int traceTempVariable$s$228_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 124 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$317_1 = distributionTempVariable$var30$5;
																if((0 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$317_1)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$317_1)) {
																					{
																						{
																							double cv$temp$106$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$317_1];
																								cv$temp$106$var116 = var116;
																							}
																							double cv$temp$107$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$317_1];
																								cv$temp$107$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$106$var116) / Math.sqrt(cv$temp$107$var117))) - (0.5 * Math.log(cv$temp$107$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$106$var116) / Math.sqrt(cv$temp$107$var117))) - (0.5 * Math.log(cv$temp$107$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$106$var116) / Math.sqrt(cv$temp$107$var117))) - (0.5 * Math.log(cv$temp$107$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$106$var116) / Math.sqrt(cv$temp$107$var117))) - (0.5 * Math.log(cv$temp$107$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$106$var116) / Math.sqrt(cv$temp$107$var117))) - (0.5 * Math.log(cv$temp$107$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																if(!true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$318 = 0; index$sample35$318 < noStates; index$sample35$318 += 1) {
																		int distributionTempVariable$var30$320 = index$sample35$318;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value319 = (1.0 * distribution$sample35[index$sample35$318]);
																		int traceTempVariable$s$321_1 = distributionTempVariable$var30$320;
																		if((0 == i$var109)) {
																			for(int var63 = 0; var63 < noStates; var63 += 1) {
																				if((var63 == traceTempVariable$s$321_1)) {
																					for(int var94 = 0; var94 < noStates; var94 += 1) {
																						if((var94 == traceTempVariable$s$321_1)) {
																							{
																								{
																									double cv$temp$108$var116;
																									{
																										// Constructing a random variable input for use later.
																										double var116 = memMean[traceTempVariable$s$321_1];
																										cv$temp$108$var116 = var116;
																									}
																									double cv$temp$109$var117;
																									{
																										// Constructing a random variable input for use later.
																										double var117 = memVar[traceTempVariable$s$321_1];
																										cv$temp$109$var117 = var117;
																									}
																									
																									// Record the probability of sample task 124 generating output with current configuration.
																									if(((Math.log(cv$probabilitySample35Value319) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$108$var116) / Math.sqrt(cv$temp$109$var117))) - (0.5 * Math.log(cv$temp$109$var117)))) < cv$accumulatedConsumerProbabilities))
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value319) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$108$var116) / Math.sqrt(cv$temp$109$var117))) - (0.5 * Math.log(cv$temp$109$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																									else {
																										// If the second value is -infinity.
																										if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																											cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value319) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$108$var116) / Math.sqrt(cv$temp$109$var117))) - (0.5 * Math.log(cv$temp$109$var117))));
																										else
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value319) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$108$var116) / Math.sqrt(cv$temp$109$var117))) - (0.5 * Math.log(cv$temp$109$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value319) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$108$var116) / Math.sqrt(cv$temp$109$var117))) - (0.5 * Math.log(cv$temp$109$var117)))));
																									}
																									
																									// Recorded the probability of reaching sample task 124 with the current configuration.
																									cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value319);
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$326_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$326_1)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$326_1)) {
																					{
																						{
																							double cv$temp$110$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$326_1];
																								cv$temp$110$var116 = var116;
																							}
																							double cv$temp$111$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$326_1];
																								cv$temp$111$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$110$var116) / Math.sqrt(cv$temp$111$var117))) - (0.5 * Math.log(cv$temp$111$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$110$var116) / Math.sqrt(cv$temp$111$var117))) - (0.5 * Math.log(cv$temp$111$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$110$var116) / Math.sqrt(cv$temp$111$var117))) - (0.5 * Math.log(cv$temp$111$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$110$var116) / Math.sqrt(cv$temp$111$var117))) - (0.5 * Math.log(cv$temp$111$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$110$var116) / Math.sqrt(cv$temp$111$var117))) - (0.5 * Math.log(cv$temp$111$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																for(int index$i$327 = 1; index$i$327 < samples; index$i$327 += 1) {
																	if(!(index$i$327 == index$i$1)) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$328 = 0; index$sample45$328 < noStates; index$sample45$328 += 1) {
																			int distributionTempVariable$var40$330 = index$sample45$328;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value329 = (1.0 * distribution$sample45[((index$i$327 - 1) / 1)][index$sample45$328]);
																			int traceTempVariable$s$331_1 = distributionTempVariable$var40$330;
																			if((index$i$327 == i$var109)) {
																				for(int var63 = 0; var63 < noStates; var63 += 1) {
																					if((var63 == traceTempVariable$s$331_1)) {
																						for(int var94 = 0; var94 < noStates; var94 += 1) {
																							if((var94 == traceTempVariable$s$331_1)) {
																								{
																									{
																										double cv$temp$112$var116;
																										{
																											// Constructing a random variable input for use later.
																											double var116 = memMean[traceTempVariable$s$331_1];
																											cv$temp$112$var116 = var116;
																										}
																										double cv$temp$113$var117;
																										{
																											// Constructing a random variable input for use later.
																											double var117 = memVar[traceTempVariable$s$331_1];
																											cv$temp$113$var117 = var117;
																										}
																										
																										// Record the probability of sample task 124 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value329) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$112$var116) / Math.sqrt(cv$temp$113$var117))) - (0.5 * Math.log(cv$temp$113$var117)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value329) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$112$var116) / Math.sqrt(cv$temp$113$var117))) - (0.5 * Math.log(cv$temp$113$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value329) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$112$var116) / Math.sqrt(cv$temp$113$var117))) - (0.5 * Math.log(cv$temp$113$var117))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value329) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$112$var116) / Math.sqrt(cv$temp$113$var117))) - (0.5 * Math.log(cv$temp$113$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value329) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$112$var116) / Math.sqrt(cv$temp$113$var117))) - (0.5 * Math.log(cv$temp$113$var117)))));
																										}
																										
																										// Recorded the probability of reaching sample task 124 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value329);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
										}
									}
									
									// Processing random variable 123.
									{
										// Looking for a path between Sample 45 and consumer Gaussian 123.
										{
											// Guard to check that at most one copy of the code is executed for a given random
											// variable instance.
											boolean[] guard$sample45gaussian128 = guard$sample45gaussian128$global;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
											}
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
											}
											int traceTempVariable$s$418_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 129 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																for(int var74 = 0; var74 < noStates; var74 += 1) {
																	if((var74 == traceTempVariable$s$418_1)) {
																		int traceTempVariable$s$446_1 = distributionTempVariable$var30$5;
																		if((0 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$446_1)) {
																					{
																						{
																							double cv$temp$138$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$446_1];
																								cv$temp$138$var121 = var121;
																							}
																							double cv$temp$139$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$446_1];
																								cv$temp$139$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$138$var121) / Math.sqrt(cv$temp$139$var122))) - (0.5 * Math.log(cv$temp$139$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$138$var121) / Math.sqrt(cv$temp$139$var122))) - (0.5 * Math.log(cv$temp$139$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$138$var121) / Math.sqrt(cv$temp$139$var122))) - (0.5 * Math.log(cv$temp$139$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$138$var121) / Math.sqrt(cv$temp$139$var122))) - (0.5 * Math.log(cv$temp$139$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$138$var121) / Math.sqrt(cv$temp$139$var122))) - (0.5 * Math.log(cv$temp$139$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		if(!true) {
																			// Enumerating the possible outputs of Categorical 29.
																			for(int index$sample35$447 = 0; index$sample35$447 < noStates; index$sample35$447 += 1) {
																				int distributionTempVariable$var30$449 = index$sample35$447;
																				
																				// Update the probability of sampling this value from the distribution value.
																				double cv$probabilitySample35Value448 = (1.0 * distribution$sample35[index$sample35$447]);
																				int traceTempVariable$s$450_1 = distributionTempVariable$var30$449;
																				if((0 == i$var109)) {
																					for(int var104 = 0; var104 < noStates; var104 += 1) {
																						if((var104 == traceTempVariable$s$450_1)) {
																							{
																								{
																									double cv$temp$140$var121;
																									{
																										// Constructing a random variable input for use later.
																										double var121 = pageFaultsMean[traceTempVariable$s$450_1];
																										cv$temp$140$var121 = var121;
																									}
																									double cv$temp$141$var122;
																									{
																										// Constructing a random variable input for use later.
																										double var122 = pageFaultsVar[traceTempVariable$s$450_1];
																										cv$temp$141$var122 = var122;
																									}
																									
																									// Record the probability of sample task 129 generating output with current configuration.
																									if(((Math.log(cv$probabilitySample35Value448) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$140$var121) / Math.sqrt(cv$temp$141$var122))) - (0.5 * Math.log(cv$temp$141$var122)))) < cv$accumulatedConsumerProbabilities))
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value448) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$140$var121) / Math.sqrt(cv$temp$141$var122))) - (0.5 * Math.log(cv$temp$141$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																									else {
																										// If the second value is -infinity.
																										if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																											cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value448) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$140$var121) / Math.sqrt(cv$temp$141$var122))) - (0.5 * Math.log(cv$temp$141$var122))));
																										else
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value448) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$140$var121) / Math.sqrt(cv$temp$141$var122))) - (0.5 * Math.log(cv$temp$141$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value448) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$140$var121) / Math.sqrt(cv$temp$141$var122))) - (0.5 * Math.log(cv$temp$141$var122)))));
																									}
																									
																									// Recorded the probability of reaching sample task 129 with the current configuration.
																									cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value448);
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																for(int var74 = 0; var74 < noStates; var74 += 1) {
																	if((var74 == traceTempVariable$s$418_1)) {
																		int traceTempVariable$s$454_1 = cv$currentValue;
																		if((index$i$1 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$454_1)) {
																					{
																						{
																							double cv$temp$142$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$454_1];
																								cv$temp$142$var121 = var121;
																							}
																							double cv$temp$143$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$454_1];
																								cv$temp$143$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$142$var121) / Math.sqrt(cv$temp$143$var122))) - (0.5 * Math.log(cv$temp$143$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$142$var121) / Math.sqrt(cv$temp$143$var122))) - (0.5 * Math.log(cv$temp$143$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$142$var121) / Math.sqrt(cv$temp$143$var122))) - (0.5 * Math.log(cv$temp$143$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$142$var121) / Math.sqrt(cv$temp$143$var122))) - (0.5 * Math.log(cv$temp$143$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$142$var121) / Math.sqrt(cv$temp$143$var122))) - (0.5 * Math.log(cv$temp$143$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		for(int index$i$455 = 1; index$i$455 < samples; index$i$455 += 1) {
																			if(!(index$i$455 == index$i$1)) {
																				// Enumerating the possible outputs of Categorical 39.
																				for(int index$sample45$456 = 0; index$sample45$456 < noStates; index$sample45$456 += 1) {
																					int distributionTempVariable$var40$458 = index$sample45$456;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample45Value457 = (1.0 * distribution$sample45[((index$i$455 - 1) / 1)][index$sample45$456]);
																					int traceTempVariable$s$459_1 = distributionTempVariable$var40$458;
																					if((index$i$455 == i$var109)) {
																						for(int var104 = 0; var104 < noStates; var104 += 1) {
																							if((var104 == traceTempVariable$s$459_1)) {
																								{
																									{
																										double cv$temp$144$var121;
																										{
																											// Constructing a random variable input for use later.
																											double var121 = pageFaultsMean[traceTempVariable$s$459_1];
																											cv$temp$144$var121 = var121;
																										}
																										double cv$temp$145$var122;
																										{
																											// Constructing a random variable input for use later.
																											double var122 = pageFaultsVar[traceTempVariable$s$459_1];
																											cv$temp$145$var122 = var122;
																										}
																										
																										// Record the probability of sample task 129 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value457) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$144$var121) / Math.sqrt(cv$temp$145$var122))) - (0.5 * Math.log(cv$temp$145$var122)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value457) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$144$var121) / Math.sqrt(cv$temp$145$var122))) - (0.5 * Math.log(cv$temp$145$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value457) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$144$var121) / Math.sqrt(cv$temp$145$var122))) - (0.5 * Math.log(cv$temp$145$var122))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value457) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$144$var121) / Math.sqrt(cv$temp$145$var122))) - (0.5 * Math.log(cv$temp$145$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value457) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$144$var121) / Math.sqrt(cv$temp$145$var122))) - (0.5 * Math.log(cv$temp$145$var122)))));
																										}
																										
																										// Recorded the probability of reaching sample task 129 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value457);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
											int traceTempVariable$s$422_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 129 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$511_1 = distributionTempVariable$var30$5;
																if((0 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$511_1)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$511_1)) {
																					{
																						{
																							double cv$temp$170$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$511_1];
																								cv$temp$170$var121 = var121;
																							}
																							double cv$temp$171$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$511_1];
																								cv$temp$171$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$170$var121) / Math.sqrt(cv$temp$171$var122))) - (0.5 * Math.log(cv$temp$171$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$170$var121) / Math.sqrt(cv$temp$171$var122))) - (0.5 * Math.log(cv$temp$171$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$170$var121) / Math.sqrt(cv$temp$171$var122))) - (0.5 * Math.log(cv$temp$171$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$170$var121) / Math.sqrt(cv$temp$171$var122))) - (0.5 * Math.log(cv$temp$171$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$170$var121) / Math.sqrt(cv$temp$171$var122))) - (0.5 * Math.log(cv$temp$171$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																if(!true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$512 = 0; index$sample35$512 < noStates; index$sample35$512 += 1) {
																		int distributionTempVariable$var30$514 = index$sample35$512;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value513 = (1.0 * distribution$sample35[index$sample35$512]);
																		int traceTempVariable$s$515_1 = distributionTempVariable$var30$514;
																		if((0 == i$var109)) {
																			for(int var74 = 0; var74 < noStates; var74 += 1) {
																				if((var74 == traceTempVariable$s$515_1)) {
																					for(int var104 = 0; var104 < noStates; var104 += 1) {
																						if((var104 == traceTempVariable$s$515_1)) {
																							{
																								{
																									double cv$temp$172$var121;
																									{
																										// Constructing a random variable input for use later.
																										double var121 = pageFaultsMean[traceTempVariable$s$515_1];
																										cv$temp$172$var121 = var121;
																									}
																									double cv$temp$173$var122;
																									{
																										// Constructing a random variable input for use later.
																										double var122 = pageFaultsVar[traceTempVariable$s$515_1];
																										cv$temp$173$var122 = var122;
																									}
																									
																									// Record the probability of sample task 129 generating output with current configuration.
																									if(((Math.log(cv$probabilitySample35Value513) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$172$var121) / Math.sqrt(cv$temp$173$var122))) - (0.5 * Math.log(cv$temp$173$var122)))) < cv$accumulatedConsumerProbabilities))
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value513) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$172$var121) / Math.sqrt(cv$temp$173$var122))) - (0.5 * Math.log(cv$temp$173$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																									else {
																										// If the second value is -infinity.
																										if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																											cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value513) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$172$var121) / Math.sqrt(cv$temp$173$var122))) - (0.5 * Math.log(cv$temp$173$var122))));
																										else
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value513) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$172$var121) / Math.sqrt(cv$temp$173$var122))) - (0.5 * Math.log(cv$temp$173$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value513) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$172$var121) / Math.sqrt(cv$temp$173$var122))) - (0.5 * Math.log(cv$temp$173$var122)))));
																									}
																									
																									// Recorded the probability of reaching sample task 129 with the current configuration.
																									cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value513);
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$520_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$520_1)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$520_1)) {
																					{
																						{
																							double cv$temp$174$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$520_1];
																								cv$temp$174$var121 = var121;
																							}
																							double cv$temp$175$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$520_1];
																								cv$temp$175$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$174$var121) / Math.sqrt(cv$temp$175$var122))) - (0.5 * Math.log(cv$temp$175$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$174$var121) / Math.sqrt(cv$temp$175$var122))) - (0.5 * Math.log(cv$temp$175$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$174$var121) / Math.sqrt(cv$temp$175$var122))) - (0.5 * Math.log(cv$temp$175$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$174$var121) / Math.sqrt(cv$temp$175$var122))) - (0.5 * Math.log(cv$temp$175$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$174$var121) / Math.sqrt(cv$temp$175$var122))) - (0.5 * Math.log(cv$temp$175$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																for(int index$i$521 = 1; index$i$521 < samples; index$i$521 += 1) {
																	if(!(index$i$521 == index$i$1)) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$522 = 0; index$sample45$522 < noStates; index$sample45$522 += 1) {
																			int distributionTempVariable$var40$524 = index$sample45$522;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value523 = (1.0 * distribution$sample45[((index$i$521 - 1) / 1)][index$sample45$522]);
																			int traceTempVariable$s$525_1 = distributionTempVariable$var40$524;
																			if((index$i$521 == i$var109)) {
																				for(int var74 = 0; var74 < noStates; var74 += 1) {
																					if((var74 == traceTempVariable$s$525_1)) {
																						for(int var104 = 0; var104 < noStates; var104 += 1) {
																							if((var104 == traceTempVariable$s$525_1)) {
																								{
																									{
																										double cv$temp$176$var121;
																										{
																											// Constructing a random variable input for use later.
																											double var121 = pageFaultsMean[traceTempVariable$s$525_1];
																											cv$temp$176$var121 = var121;
																										}
																										double cv$temp$177$var122;
																										{
																											// Constructing a random variable input for use later.
																											double var122 = pageFaultsVar[traceTempVariable$s$525_1];
																											cv$temp$177$var122 = var122;
																										}
																										
																										// Record the probability of sample task 129 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value523) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$176$var121) / Math.sqrt(cv$temp$177$var122))) - (0.5 * Math.log(cv$temp$177$var122)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value523) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$176$var121) / Math.sqrt(cv$temp$177$var122))) - (0.5 * Math.log(cv$temp$177$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value523) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$176$var121) / Math.sqrt(cv$temp$177$var122))) - (0.5 * Math.log(cv$temp$177$var122))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value523) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$176$var121) / Math.sqrt(cv$temp$177$var122))) - (0.5 * Math.log(cv$temp$177$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value523) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$176$var121) / Math.sqrt(cv$temp$177$var122))) - (0.5 * Math.log(cv$temp$177$var122)))));
																										}
																										
																										// Recorded the probability of reaching sample task 129 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value523);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
										}
									}
									
									// Add the values for the source and any standard consumers for this configuration
									// of arguments to the source.
									if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
										cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
									else {
										// If the second value is -infinity.
										if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
											cv$stateProbabilityValue = cv$accumulatedProbabilities;
										else
											cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
									}
								}
							}
						}
					}
				}
			}
			
			// Enumerating the possible arguments for Categorical 39.
			int traceTempVariable$var37$9_1 = cv$currentValue;
			if((index$i$1 == (i$var34 - 1))) {
				for(int var21 = 0; var21 < noStates; var21 += 1) {
					if((var21 == traceTempVariable$var37$9_1)) {
						// Record the reached probability density.
						cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
						double[] cv$temp$2$var38;
						{
							// Constructing a random variable input for use later.
							double[] var38 = m[traceTempVariable$var37$9_1];
							cv$temp$2$var38 = var38;
						}
						
						// An accumulator to allow the value for each distribution to be constructed before
						// it is added to the index probabilities.
						double cv$accumulatedProbabilities = (Math.log(1.0) + (((0.0 <= cv$currentValue) && (cv$currentValue < cv$temp$2$var38.length))?Math.log(cv$temp$2$var38[cv$currentValue]):Double.NEGATIVE_INFINITY));
						
						// Processing random variable 39.
						{
							// Looking for a path between Sample 45 and consumer Categorical 39.
							{
								int traceTempVariable$var37$19_1 = cv$currentValue;
							}
						}
						
						// Processing random variable 113.
						{
							// Looking for a path between Sample 45 and consumer Gaussian 113.
							{
								// Guard to check that at most one copy of the code is executed for a given random
								// variable instance.
								boolean[] guard$sample45gaussian118 = guard$sample45gaussian118$global;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109))
										// Set the flags to false
										guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
								}
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109))
										// Set the flags to false
										guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
								}
								int traceTempVariable$s$31_1 = cv$currentValue;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109)) {
										if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
											// The body will execute, so should not be executed again
											guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
											
											// Processing sample task 119 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 45.
													for(int var52 = 0; var52 < noStates; var52 += 1) {
														if((var52 == traceTempVariable$s$31_1)) {
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$31_1)) {
																			{
																				{
																					double cv$temp$18$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$31_1];
																						cv$temp$18$var111 = var111;
																					}
																					double cv$temp$19$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$31_1];
																						cv$temp$19$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$76 = 0; index$sample35$76 < noStates; index$sample35$76 += 1) {
																		int distributionTempVariable$var30$78 = index$sample35$76;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value77 = (1.0 * distribution$sample35[index$sample35$76]);
																		int traceTempVariable$s$79_1 = distributionTempVariable$var30$78;
																		if((0 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$79_1)) {
																					{
																						{
																							double cv$temp$20$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$79_1];
																								cv$temp$20$var111 = var111;
																							}
																							double cv$temp$21$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$79_1];
																								cv$temp$21$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value77) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value77) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value77) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value77) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value77) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value77);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 45.
													for(int var52 = 0; var52 < noStates; var52 += 1) {
														if((var52 == traceTempVariable$s$31_1)) {
															int traceTempVariable$s$83_1 = cv$currentValue;
															if((index$i$1 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$83_1)) {
																		{
																			{
																				double cv$temp$22$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$83_1];
																					cv$temp$22$var111 = var111;
																				}
																				double cv$temp$23$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$83_1];
																					cv$temp$23$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
															for(int index$i$84 = 1; index$i$84 < samples; index$i$84 += 1) {
																if(!(index$i$84 == index$i$1)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$85 = 0; index$sample45$85 < noStates; index$sample45$85 += 1) {
																		int distributionTempVariable$var40$87 = index$sample45$85;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value86 = (1.0 * distribution$sample45[((index$i$84 - 1) / 1)][index$sample45$85]);
																		int traceTempVariable$s$88_1 = distributionTempVariable$var40$87;
																		if((index$i$84 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$88_1)) {
																					{
																						{
																							double cv$temp$24$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$88_1];
																								cv$temp$24$var111 = var111;
																							}
																							double cv$temp$25$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$88_1];
																								cv$temp$25$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value86) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value86) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value86) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value86) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value86) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value86);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
								int traceTempVariable$s$35_1 = cv$currentValue;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109)) {
										if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
											// The body will execute, so should not be executed again
											guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
											
											// Processing sample task 119 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 45.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == traceTempVariable$s$35_1)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$35_1)) {
																			{
																				{
																					double cv$temp$50$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$35_1];
																						cv$temp$50$var111 = var111;
																					}
																					double cv$temp$51$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$35_1];
																						cv$temp$51$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$50$var111) / Math.sqrt(cv$temp$51$var112))) - (0.5 * Math.log(cv$temp$51$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$50$var111) / Math.sqrt(cv$temp$51$var112))) - (0.5 * Math.log(cv$temp$51$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$50$var111) / Math.sqrt(cv$temp$51$var112))) - (0.5 * Math.log(cv$temp$51$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$50$var111) / Math.sqrt(cv$temp$51$var112))) - (0.5 * Math.log(cv$temp$51$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$50$var111) / Math.sqrt(cv$temp$51$var112))) - (0.5 * Math.log(cv$temp$51$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$143 = 0; index$sample35$143 < noStates; index$sample35$143 += 1) {
																int distributionTempVariable$var30$145 = index$sample35$143;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value144 = (1.0 * distribution$sample35[index$sample35$143]);
																int traceTempVariable$s$146_1 = distributionTempVariable$var30$145;
																if((0 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$146_1)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$146_1)) {
																					{
																						{
																							double cv$temp$52$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$146_1];
																								cv$temp$52$var111 = var111;
																							}
																							double cv$temp$53$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$146_1];
																								cv$temp$53$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value144) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$52$var111) / Math.sqrt(cv$temp$53$var112))) - (0.5 * Math.log(cv$temp$53$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value144) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$52$var111) / Math.sqrt(cv$temp$53$var112))) - (0.5 * Math.log(cv$temp$53$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value144) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$52$var111) / Math.sqrt(cv$temp$53$var112))) - (0.5 * Math.log(cv$temp$53$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value144) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$52$var111) / Math.sqrt(cv$temp$53$var112))) - (0.5 * Math.log(cv$temp$53$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value144) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$52$var111) / Math.sqrt(cv$temp$53$var112))) - (0.5 * Math.log(cv$temp$53$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value144);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 45.
													int traceTempVariable$s$151_1 = cv$currentValue;
													if((index$i$1 == i$var109)) {
														for(int var52 = 0; var52 < noStates; var52 += 1) {
															if((var52 == traceTempVariable$s$151_1)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$151_1)) {
																		{
																			{
																				double cv$temp$54$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$151_1];
																					cv$temp$54$var111 = var111;
																				}
																				double cv$temp$55$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$151_1];
																					cv$temp$55$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$54$var111) / Math.sqrt(cv$temp$55$var112))) - (0.5 * Math.log(cv$temp$55$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$54$var111) / Math.sqrt(cv$temp$55$var112))) - (0.5 * Math.log(cv$temp$55$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$54$var111) / Math.sqrt(cv$temp$55$var112))) - (0.5 * Math.log(cv$temp$55$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$54$var111) / Math.sqrt(cv$temp$55$var112))) - (0.5 * Math.log(cv$temp$55$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$54$var111) / Math.sqrt(cv$temp$55$var112))) - (0.5 * Math.log(cv$temp$55$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													}
													for(int index$i$152 = 1; index$i$152 < samples; index$i$152 += 1) {
														if(!(index$i$152 == index$i$1)) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$153 = 0; index$sample45$153 < noStates; index$sample45$153 += 1) {
																int distributionTempVariable$var40$155 = index$sample45$153;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value154 = (1.0 * distribution$sample45[((index$i$152 - 1) / 1)][index$sample45$153]);
																int traceTempVariable$s$156_1 = distributionTempVariable$var40$155;
																if((index$i$152 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$156_1)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$156_1)) {
																					{
																						{
																							double cv$temp$56$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$156_1];
																								cv$temp$56$var111 = var111;
																							}
																							double cv$temp$57$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$156_1];
																								cv$temp$57$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value154) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$56$var111) / Math.sqrt(cv$temp$57$var112))) - (0.5 * Math.log(cv$temp$57$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value154) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$56$var111) / Math.sqrt(cv$temp$57$var112))) - (0.5 * Math.log(cv$temp$57$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value154) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$56$var111) / Math.sqrt(cv$temp$57$var112))) - (0.5 * Math.log(cv$temp$57$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value154) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$56$var111) / Math.sqrt(cv$temp$57$var112))) - (0.5 * Math.log(cv$temp$57$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value154) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$56$var111) / Math.sqrt(cv$temp$57$var112))) - (0.5 * Math.log(cv$temp$57$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value154);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							}
						}
						
						// Processing random variable 118.
						{
							// Looking for a path between Sample 45 and consumer Gaussian 118.
							{
								// Guard to check that at most one copy of the code is executed for a given random
								// variable instance.
								boolean[] guard$sample45gaussian123 = guard$sample45gaussian123$global;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109))
										// Set the flags to false
										guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
								}
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109))
										// Set the flags to false
										guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
								}
								int traceTempVariable$s$225_1 = cv$currentValue;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109)) {
										if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
											// The body will execute, so should not be executed again
											guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
											
											// Processing sample task 124 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 45.
													for(int var63 = 0; var63 < noStates; var63 += 1) {
														if((var63 == traceTempVariable$s$225_1)) {
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$225_1)) {
																			{
																				{
																					double cv$temp$82$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$225_1];
																						cv$temp$82$var116 = var116;
																					}
																					double cv$temp$83$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$225_1];
																						cv$temp$83$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$82$var116) / Math.sqrt(cv$temp$83$var117))) - (0.5 * Math.log(cv$temp$83$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$82$var116) / Math.sqrt(cv$temp$83$var117))) - (0.5 * Math.log(cv$temp$83$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$82$var116) / Math.sqrt(cv$temp$83$var117))) - (0.5 * Math.log(cv$temp$83$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$82$var116) / Math.sqrt(cv$temp$83$var117))) - (0.5 * Math.log(cv$temp$83$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$82$var116) / Math.sqrt(cv$temp$83$var117))) - (0.5 * Math.log(cv$temp$83$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$270 = 0; index$sample35$270 < noStates; index$sample35$270 += 1) {
																		int distributionTempVariable$var30$272 = index$sample35$270;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value271 = (1.0 * distribution$sample35[index$sample35$270]);
																		int traceTempVariable$s$273_1 = distributionTempVariable$var30$272;
																		if((0 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$273_1)) {
																					{
																						{
																							double cv$temp$84$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$273_1];
																								cv$temp$84$var116 = var116;
																							}
																							double cv$temp$85$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$273_1];
																								cv$temp$85$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value271) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$84$var116) / Math.sqrt(cv$temp$85$var117))) - (0.5 * Math.log(cv$temp$85$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value271) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$84$var116) / Math.sqrt(cv$temp$85$var117))) - (0.5 * Math.log(cv$temp$85$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value271) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$84$var116) / Math.sqrt(cv$temp$85$var117))) - (0.5 * Math.log(cv$temp$85$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value271) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$84$var116) / Math.sqrt(cv$temp$85$var117))) - (0.5 * Math.log(cv$temp$85$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value271) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$84$var116) / Math.sqrt(cv$temp$85$var117))) - (0.5 * Math.log(cv$temp$85$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value271);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 45.
													for(int var63 = 0; var63 < noStates; var63 += 1) {
														if((var63 == traceTempVariable$s$225_1)) {
															int traceTempVariable$s$277_1 = cv$currentValue;
															if((index$i$1 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$277_1)) {
																		{
																			{
																				double cv$temp$86$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$277_1];
																					cv$temp$86$var116 = var116;
																				}
																				double cv$temp$87$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$277_1];
																					cv$temp$87$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$86$var116) / Math.sqrt(cv$temp$87$var117))) - (0.5 * Math.log(cv$temp$87$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$86$var116) / Math.sqrt(cv$temp$87$var117))) - (0.5 * Math.log(cv$temp$87$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$86$var116) / Math.sqrt(cv$temp$87$var117))) - (0.5 * Math.log(cv$temp$87$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$86$var116) / Math.sqrt(cv$temp$87$var117))) - (0.5 * Math.log(cv$temp$87$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$86$var116) / Math.sqrt(cv$temp$87$var117))) - (0.5 * Math.log(cv$temp$87$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
															for(int index$i$278 = 1; index$i$278 < samples; index$i$278 += 1) {
																if(!(index$i$278 == index$i$1)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$279 = 0; index$sample45$279 < noStates; index$sample45$279 += 1) {
																		int distributionTempVariable$var40$281 = index$sample45$279;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value280 = (1.0 * distribution$sample45[((index$i$278 - 1) / 1)][index$sample45$279]);
																		int traceTempVariable$s$282_1 = distributionTempVariable$var40$281;
																		if((index$i$278 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$282_1)) {
																					{
																						{
																							double cv$temp$88$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$282_1];
																								cv$temp$88$var116 = var116;
																							}
																							double cv$temp$89$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$282_1];
																								cv$temp$89$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value280) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$88$var116) / Math.sqrt(cv$temp$89$var117))) - (0.5 * Math.log(cv$temp$89$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value280) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$88$var116) / Math.sqrt(cv$temp$89$var117))) - (0.5 * Math.log(cv$temp$89$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value280) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$88$var116) / Math.sqrt(cv$temp$89$var117))) - (0.5 * Math.log(cv$temp$89$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value280) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$88$var116) / Math.sqrt(cv$temp$89$var117))) - (0.5 * Math.log(cv$temp$89$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value280) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$88$var116) / Math.sqrt(cv$temp$89$var117))) - (0.5 * Math.log(cv$temp$89$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value280);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
								int traceTempVariable$s$229_1 = cv$currentValue;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109)) {
										if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
											// The body will execute, so should not be executed again
											guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
											
											// Processing sample task 124 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 45.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var63 = 0; var63 < noStates; var63 += 1) {
																if((var63 == traceTempVariable$s$229_1)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$229_1)) {
																			{
																				{
																					double cv$temp$114$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = memMean[traceTempVariable$s$229_1];
																						cv$temp$114$var116 = var116;
																					}
																					double cv$temp$115$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$229_1];
																						cv$temp$115$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$114$var116) / Math.sqrt(cv$temp$115$var117))) - (0.5 * Math.log(cv$temp$115$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$114$var116) / Math.sqrt(cv$temp$115$var117))) - (0.5 * Math.log(cv$temp$115$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$114$var116) / Math.sqrt(cv$temp$115$var117))) - (0.5 * Math.log(cv$temp$115$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$114$var116) / Math.sqrt(cv$temp$115$var117))) - (0.5 * Math.log(cv$temp$115$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$114$var116) / Math.sqrt(cv$temp$115$var117))) - (0.5 * Math.log(cv$temp$115$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$337 = 0; index$sample35$337 < noStates; index$sample35$337 += 1) {
																int distributionTempVariable$var30$339 = index$sample35$337;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value338 = (1.0 * distribution$sample35[index$sample35$337]);
																int traceTempVariable$s$340_1 = distributionTempVariable$var30$339;
																if((0 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$340_1)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$340_1)) {
																					{
																						{
																							double cv$temp$116$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$340_1];
																								cv$temp$116$var116 = var116;
																							}
																							double cv$temp$117$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$340_1];
																								cv$temp$117$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value338) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$116$var116) / Math.sqrt(cv$temp$117$var117))) - (0.5 * Math.log(cv$temp$117$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value338) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$116$var116) / Math.sqrt(cv$temp$117$var117))) - (0.5 * Math.log(cv$temp$117$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value338) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$116$var116) / Math.sqrt(cv$temp$117$var117))) - (0.5 * Math.log(cv$temp$117$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value338) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$116$var116) / Math.sqrt(cv$temp$117$var117))) - (0.5 * Math.log(cv$temp$117$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value338) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$116$var116) / Math.sqrt(cv$temp$117$var117))) - (0.5 * Math.log(cv$temp$117$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value338);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 45.
													int traceTempVariable$s$345_1 = cv$currentValue;
													if((index$i$1 == i$var109)) {
														for(int var63 = 0; var63 < noStates; var63 += 1) {
															if((var63 == traceTempVariable$s$345_1)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$345_1)) {
																		{
																			{
																				double cv$temp$118$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = memMean[traceTempVariable$s$345_1];
																					cv$temp$118$var116 = var116;
																				}
																				double cv$temp$119$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$345_1];
																					cv$temp$119$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$118$var116) / Math.sqrt(cv$temp$119$var117))) - (0.5 * Math.log(cv$temp$119$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$118$var116) / Math.sqrt(cv$temp$119$var117))) - (0.5 * Math.log(cv$temp$119$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$118$var116) / Math.sqrt(cv$temp$119$var117))) - (0.5 * Math.log(cv$temp$119$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$118$var116) / Math.sqrt(cv$temp$119$var117))) - (0.5 * Math.log(cv$temp$119$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$118$var116) / Math.sqrt(cv$temp$119$var117))) - (0.5 * Math.log(cv$temp$119$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													}
													for(int index$i$346 = 1; index$i$346 < samples; index$i$346 += 1) {
														if(!(index$i$346 == index$i$1)) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$347 = 0; index$sample45$347 < noStates; index$sample45$347 += 1) {
																int distributionTempVariable$var40$349 = index$sample45$347;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value348 = (1.0 * distribution$sample45[((index$i$346 - 1) / 1)][index$sample45$347]);
																int traceTempVariable$s$350_1 = distributionTempVariable$var40$349;
																if((index$i$346 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$350_1)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$350_1)) {
																					{
																						{
																							double cv$temp$120$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$350_1];
																								cv$temp$120$var116 = var116;
																							}
																							double cv$temp$121$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$350_1];
																								cv$temp$121$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value348) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$120$var116) / Math.sqrt(cv$temp$121$var117))) - (0.5 * Math.log(cv$temp$121$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value348) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$120$var116) / Math.sqrt(cv$temp$121$var117))) - (0.5 * Math.log(cv$temp$121$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value348) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$120$var116) / Math.sqrt(cv$temp$121$var117))) - (0.5 * Math.log(cv$temp$121$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value348) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$120$var116) / Math.sqrt(cv$temp$121$var117))) - (0.5 * Math.log(cv$temp$121$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value348) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$120$var116) / Math.sqrt(cv$temp$121$var117))) - (0.5 * Math.log(cv$temp$121$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value348);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							}
						}
						
						// Processing random variable 123.
						{
							// Looking for a path between Sample 45 and consumer Gaussian 123.
							{
								// Guard to check that at most one copy of the code is executed for a given random
								// variable instance.
								boolean[] guard$sample45gaussian128 = guard$sample45gaussian128$global;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109))
										// Set the flags to false
										guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
								}
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109))
										// Set the flags to false
										guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
								}
								int traceTempVariable$s$419_1 = cv$currentValue;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109)) {
										if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
											// The body will execute, so should not be executed again
											guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
											
											// Processing sample task 129 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 45.
													for(int var74 = 0; var74 < noStates; var74 += 1) {
														if((var74 == traceTempVariable$s$419_1)) {
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$419_1)) {
																			{
																				{
																					double cv$temp$146$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$419_1];
																						cv$temp$146$var121 = var121;
																					}
																					double cv$temp$147$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$419_1];
																						cv$temp$147$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$146$var121) / Math.sqrt(cv$temp$147$var122))) - (0.5 * Math.log(cv$temp$147$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$146$var121) / Math.sqrt(cv$temp$147$var122))) - (0.5 * Math.log(cv$temp$147$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$146$var121) / Math.sqrt(cv$temp$147$var122))) - (0.5 * Math.log(cv$temp$147$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$146$var121) / Math.sqrt(cv$temp$147$var122))) - (0.5 * Math.log(cv$temp$147$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$146$var121) / Math.sqrt(cv$temp$147$var122))) - (0.5 * Math.log(cv$temp$147$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$464 = 0; index$sample35$464 < noStates; index$sample35$464 += 1) {
																		int distributionTempVariable$var30$466 = index$sample35$464;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value465 = (1.0 * distribution$sample35[index$sample35$464]);
																		int traceTempVariable$s$467_1 = distributionTempVariable$var30$466;
																		if((0 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$467_1)) {
																					{
																						{
																							double cv$temp$148$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$467_1];
																								cv$temp$148$var121 = var121;
																							}
																							double cv$temp$149$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$467_1];
																								cv$temp$149$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value465) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$148$var121) / Math.sqrt(cv$temp$149$var122))) - (0.5 * Math.log(cv$temp$149$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value465) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$148$var121) / Math.sqrt(cv$temp$149$var122))) - (0.5 * Math.log(cv$temp$149$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value465) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$148$var121) / Math.sqrt(cv$temp$149$var122))) - (0.5 * Math.log(cv$temp$149$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value465) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$148$var121) / Math.sqrt(cv$temp$149$var122))) - (0.5 * Math.log(cv$temp$149$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value465) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$148$var121) / Math.sqrt(cv$temp$149$var122))) - (0.5 * Math.log(cv$temp$149$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value465);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 45.
													for(int var74 = 0; var74 < noStates; var74 += 1) {
														if((var74 == traceTempVariable$s$419_1)) {
															int traceTempVariable$s$471_1 = cv$currentValue;
															if((index$i$1 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$471_1)) {
																		{
																			{
																				double cv$temp$150$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$471_1];
																					cv$temp$150$var121 = var121;
																				}
																				double cv$temp$151$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$471_1];
																					cv$temp$151$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$150$var121) / Math.sqrt(cv$temp$151$var122))) - (0.5 * Math.log(cv$temp$151$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$150$var121) / Math.sqrt(cv$temp$151$var122))) - (0.5 * Math.log(cv$temp$151$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$150$var121) / Math.sqrt(cv$temp$151$var122))) - (0.5 * Math.log(cv$temp$151$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$150$var121) / Math.sqrt(cv$temp$151$var122))) - (0.5 * Math.log(cv$temp$151$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$150$var121) / Math.sqrt(cv$temp$151$var122))) - (0.5 * Math.log(cv$temp$151$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
															for(int index$i$472 = 1; index$i$472 < samples; index$i$472 += 1) {
																if(!(index$i$472 == index$i$1)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$473 = 0; index$sample45$473 < noStates; index$sample45$473 += 1) {
																		int distributionTempVariable$var40$475 = index$sample45$473;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value474 = (1.0 * distribution$sample45[((index$i$472 - 1) / 1)][index$sample45$473]);
																		int traceTempVariable$s$476_1 = distributionTempVariable$var40$475;
																		if((index$i$472 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$476_1)) {
																					{
																						{
																							double cv$temp$152$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$476_1];
																								cv$temp$152$var121 = var121;
																							}
																							double cv$temp$153$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$476_1];
																								cv$temp$153$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value474) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$152$var121) / Math.sqrt(cv$temp$153$var122))) - (0.5 * Math.log(cv$temp$153$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value474) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$152$var121) / Math.sqrt(cv$temp$153$var122))) - (0.5 * Math.log(cv$temp$153$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value474) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$152$var121) / Math.sqrt(cv$temp$153$var122))) - (0.5 * Math.log(cv$temp$153$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value474) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$152$var121) / Math.sqrt(cv$temp$153$var122))) - (0.5 * Math.log(cv$temp$153$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value474) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$152$var121) / Math.sqrt(cv$temp$153$var122))) - (0.5 * Math.log(cv$temp$153$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value474);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
								int traceTempVariable$s$423_1 = cv$currentValue;
								for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
									if((i$var34 == i$var109)) {
										if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
											// The body will execute, so should not be executed again
											guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
											
											// Processing sample task 129 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 45.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var74 = 0; var74 < noStates; var74 += 1) {
																if((var74 == traceTempVariable$s$423_1)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$423_1)) {
																			{
																				{
																					double cv$temp$178$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = pageFaultsMean[traceTempVariable$s$423_1];
																						cv$temp$178$var121 = var121;
																					}
																					double cv$temp$179$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$423_1];
																						cv$temp$179$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$178$var121) / Math.sqrt(cv$temp$179$var122))) - (0.5 * Math.log(cv$temp$179$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$178$var121) / Math.sqrt(cv$temp$179$var122))) - (0.5 * Math.log(cv$temp$179$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$178$var121) / Math.sqrt(cv$temp$179$var122))) - (0.5 * Math.log(cv$temp$179$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$178$var121) / Math.sqrt(cv$temp$179$var122))) - (0.5 * Math.log(cv$temp$179$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$178$var121) / Math.sqrt(cv$temp$179$var122))) - (0.5 * Math.log(cv$temp$179$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																				}
																			}
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$531 = 0; index$sample35$531 < noStates; index$sample35$531 += 1) {
																int distributionTempVariable$var30$533 = index$sample35$531;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value532 = (1.0 * distribution$sample35[index$sample35$531]);
																int traceTempVariable$s$534_1 = distributionTempVariable$var30$533;
																if((0 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$534_1)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$534_1)) {
																					{
																						{
																							double cv$temp$180$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$534_1];
																								cv$temp$180$var121 = var121;
																							}
																							double cv$temp$181$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$534_1];
																								cv$temp$181$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value532) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$180$var121) / Math.sqrt(cv$temp$181$var122))) - (0.5 * Math.log(cv$temp$181$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value532) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$180$var121) / Math.sqrt(cv$temp$181$var122))) - (0.5 * Math.log(cv$temp$181$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value532) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$180$var121) / Math.sqrt(cv$temp$181$var122))) - (0.5 * Math.log(cv$temp$181$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value532) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$180$var121) / Math.sqrt(cv$temp$181$var122))) - (0.5 * Math.log(cv$temp$181$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value532) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$180$var121) / Math.sqrt(cv$temp$181$var122))) - (0.5 * Math.log(cv$temp$181$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value532);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 45.
													int traceTempVariable$s$539_1 = cv$currentValue;
													if((index$i$1 == i$var109)) {
														for(int var74 = 0; var74 < noStates; var74 += 1) {
															if((var74 == traceTempVariable$s$539_1)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$539_1)) {
																		{
																			{
																				double cv$temp$182$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = pageFaultsMean[traceTempVariable$s$539_1];
																					cv$temp$182$var121 = var121;
																				}
																				double cv$temp$183$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$539_1];
																					cv$temp$183$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$182$var121) / Math.sqrt(cv$temp$183$var122))) - (0.5 * Math.log(cv$temp$183$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$182$var121) / Math.sqrt(cv$temp$183$var122))) - (0.5 * Math.log(cv$temp$183$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$182$var121) / Math.sqrt(cv$temp$183$var122))) - (0.5 * Math.log(cv$temp$183$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$182$var121) / Math.sqrt(cv$temp$183$var122))) - (0.5 * Math.log(cv$temp$183$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$182$var121) / Math.sqrt(cv$temp$183$var122))) - (0.5 * Math.log(cv$temp$183$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																			}
																		}
																	}
																}
															}
														}
													}
													for(int index$i$540 = 1; index$i$540 < samples; index$i$540 += 1) {
														if(!(index$i$540 == index$i$1)) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$541 = 0; index$sample45$541 < noStates; index$sample45$541 += 1) {
																int distributionTempVariable$var40$543 = index$sample45$541;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value542 = (1.0 * distribution$sample45[((index$i$540 - 1) / 1)][index$sample45$541]);
																int traceTempVariable$s$544_1 = distributionTempVariable$var40$543;
																if((index$i$540 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$544_1)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$544_1)) {
																					{
																						{
																							double cv$temp$184$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$544_1];
																								cv$temp$184$var121 = var121;
																							}
																							double cv$temp$185$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$544_1];
																								cv$temp$185$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value542) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$184$var121) / Math.sqrt(cv$temp$185$var122))) - (0.5 * Math.log(cv$temp$185$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value542) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$184$var121) / Math.sqrt(cv$temp$185$var122))) - (0.5 * Math.log(cv$temp$185$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value542) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$184$var121) / Math.sqrt(cv$temp$185$var122))) - (0.5 * Math.log(cv$temp$185$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value542) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$184$var121) / Math.sqrt(cv$temp$185$var122))) - (0.5 * Math.log(cv$temp$185$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value542) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$184$var121) / Math.sqrt(cv$temp$185$var122))) - (0.5 * Math.log(cv$temp$185$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value542);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							}
						}
						
						// Add the values for the source and any standard consumers for this configuration
						// of arguments to the source.
						if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
							cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
						else {
							// If the second value is -infinity.
							if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
								cv$stateProbabilityValue = cv$accumulatedProbabilities;
							else
								cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
						}
					}
				}
			}
			for(int index$i$10 = 1; index$i$10 < samples; index$i$10 += 1) {
				if(!(index$i$10 == index$i$1)) {
					// Enumerating the possible outputs of Categorical 39.
					for(int index$sample45$11 = 0; index$sample45$11 < noStates; index$sample45$11 += 1) {
						int distributionTempVariable$var40$13 = index$sample45$11;
						
						// Update the probability of sampling this value from the distribution value.
						double cv$probabilitySample45Value12 = (1.0 * distribution$sample45[((index$i$10 - 1) / 1)][index$sample45$11]);
						int traceTempVariable$var37$14_1 = distributionTempVariable$var40$13;
						if((index$i$10 == (i$var34 - 1))) {
							for(int var21 = 0; var21 < noStates; var21 += 1) {
								if((var21 == traceTempVariable$var37$14_1)) {
									// Record the reached probability density.
									cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + cv$probabilitySample45Value12);
									double[] cv$temp$3$var38;
									{
										// Constructing a random variable input for use later.
										double[] var38 = m[traceTempVariable$var37$14_1];
										cv$temp$3$var38 = var38;
									}
									
									// An accumulator to allow the value for each distribution to be constructed before
									// it is added to the index probabilities.
									double cv$accumulatedProbabilities = (Math.log(cv$probabilitySample45Value12) + (((0.0 <= cv$currentValue) && (cv$currentValue < cv$temp$3$var38.length))?Math.log(cv$temp$3$var38[cv$currentValue]):Double.NEGATIVE_INFINITY));
									
									// Processing random variable 39.
									{
										// Looking for a path between Sample 45 and consumer Categorical 39.
										{
											int traceTempVariable$var37$20_1 = cv$currentValue;
										}
									}
									
									// Processing random variable 113.
									{
										// Looking for a path between Sample 45 and consumer Gaussian 113.
										{
											// Guard to check that at most one copy of the code is executed for a given random
											// variable instance.
											boolean[] guard$sample45gaussian118 = guard$sample45gaussian118$global;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
											}
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian118[((i$var109 - 0) / 1)] = false;
											}
											int traceTempVariable$s$32_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 119 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																for(int var52 = 0; var52 < noStates; var52 += 1) {
																	if((var52 == traceTempVariable$s$32_1)) {
																		if(fixedFlag$sample35) {
																			if((0 == i$var109)) {
																				for(int var84 = 0; var84 < noStates; var84 += 1) {
																					if((var84 == traceTempVariable$s$32_1)) {
																						{
																							{
																								double cv$temp$26$var111;
																								{
																									// Constructing a random variable input for use later.
																									double var111 = cpuMean[traceTempVariable$s$32_1];
																									cv$temp$26$var111 = var111;
																								}
																								double cv$temp$27$var112;
																								{
																									// Constructing a random variable input for use later.
																									double var112 = cpuVar[traceTempVariable$s$32_1];
																									cv$temp$27$var112 = var112;
																								}
																								
																								// Record the probability of sample task 119 generating output with current configuration.
																								if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))));
																								}
																								
																								// Recorded the probability of reaching sample task 119 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																							}
																						}
																					}
																				}
																			}
																		} else {
																			if(true) {
																				// Enumerating the possible outputs of Categorical 29.
																				for(int index$sample35$93 = 0; index$sample35$93 < noStates; index$sample35$93 += 1) {
																					int distributionTempVariable$var30$95 = index$sample35$93;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample35Value94 = (1.0 * distribution$sample35[index$sample35$93]);
																					int traceTempVariable$s$96_1 = distributionTempVariable$var30$95;
																					if((0 == i$var109)) {
																						for(int var84 = 0; var84 < noStates; var84 += 1) {
																							if((var84 == traceTempVariable$s$96_1)) {
																								{
																									{
																										double cv$temp$28$var111;
																										{
																											// Constructing a random variable input for use later.
																											double var111 = cpuMean[traceTempVariable$s$96_1];
																											cv$temp$28$var111 = var111;
																										}
																										double cv$temp$29$var112;
																										{
																											// Constructing a random variable input for use later.
																											double var112 = cpuVar[traceTempVariable$s$96_1];
																											cv$temp$29$var112 = var112;
																										}
																										
																										// Record the probability of sample task 119 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample35Value94) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value94) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value94) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value94) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value94) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))));
																										}
																										
																										// Recorded the probability of reaching sample task 119 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value94);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																for(int var52 = 0; var52 < noStates; var52 += 1) {
																	if((var52 == traceTempVariable$s$32_1)) {
																		int traceTempVariable$s$100_1 = cv$currentValue;
																		if((index$i$1 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$100_1)) {
																					{
																						{
																							double cv$temp$30$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$100_1];
																								cv$temp$30$var111 = var111;
																							}
																							double cv$temp$31$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$100_1];
																								cv$temp$31$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$30$var111) / Math.sqrt(cv$temp$31$var112))) - (0.5 * Math.log(cv$temp$31$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$30$var111) / Math.sqrt(cv$temp$31$var112))) - (0.5 * Math.log(cv$temp$31$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$30$var111) / Math.sqrt(cv$temp$31$var112))) - (0.5 * Math.log(cv$temp$31$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$30$var111) / Math.sqrt(cv$temp$31$var112))) - (0.5 * Math.log(cv$temp$31$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$30$var111) / Math.sqrt(cv$temp$31$var112))) - (0.5 * Math.log(cv$temp$31$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		int traceTempVariable$s$101_1 = distributionTempVariable$var40$13;
																		if((index$i$10 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$101_1)) {
																					{
																						{
																							double cv$temp$32$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$101_1];
																								cv$temp$32$var111 = var111;
																							}
																							double cv$temp$33$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$101_1];
																								cv$temp$33$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$32$var111) / Math.sqrt(cv$temp$33$var112))) - (0.5 * Math.log(cv$temp$33$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$32$var111) / Math.sqrt(cv$temp$33$var112))) - (0.5 * Math.log(cv$temp$33$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$32$var111) / Math.sqrt(cv$temp$33$var112))) - (0.5 * Math.log(cv$temp$33$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$32$var111) / Math.sqrt(cv$temp$33$var112))) - (0.5 * Math.log(cv$temp$33$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$32$var111) / Math.sqrt(cv$temp$33$var112))) - (0.5 * Math.log(cv$temp$33$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		for(int index$i$102 = 1; index$i$102 < samples; index$i$102 += 1) {
																			if((!(index$i$102 == index$i$1) && !(index$i$102 == index$i$10))) {
																				// Enumerating the possible outputs of Categorical 39.
																				for(int index$sample45$103 = 0; index$sample45$103 < noStates; index$sample45$103 += 1) {
																					int distributionTempVariable$var40$105 = index$sample45$103;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample45Value104 = (1.0 * distribution$sample45[((index$i$102 - 1) / 1)][index$sample45$103]);
																					int traceTempVariable$s$106_1 = distributionTempVariable$var40$105;
																					if((index$i$102 == i$var109)) {
																						for(int var84 = 0; var84 < noStates; var84 += 1) {
																							if((var84 == traceTempVariable$s$106_1)) {
																								{
																									{
																										double cv$temp$34$var111;
																										{
																											// Constructing a random variable input for use later.
																											double var111 = cpuMean[traceTempVariable$s$106_1];
																											cv$temp$34$var111 = var111;
																										}
																										double cv$temp$35$var112;
																										{
																											// Constructing a random variable input for use later.
																											double var112 = cpuVar[traceTempVariable$s$106_1];
																											cv$temp$35$var112 = var112;
																										}
																										
																										// Record the probability of sample task 119 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value104) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$34$var111) / Math.sqrt(cv$temp$35$var112))) - (0.5 * Math.log(cv$temp$35$var112)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value104) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$34$var111) / Math.sqrt(cv$temp$35$var112))) - (0.5 * Math.log(cv$temp$35$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value104) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$34$var111) / Math.sqrt(cv$temp$35$var112))) - (0.5 * Math.log(cv$temp$35$var112))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value104) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$34$var111) / Math.sqrt(cv$temp$35$var112))) - (0.5 * Math.log(cv$temp$35$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value104) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$34$var111) / Math.sqrt(cv$temp$35$var112))) - (0.5 * Math.log(cv$temp$35$var112)))));
																										}
																										
																										// Recorded the probability of reaching sample task 119 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value104);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
											int traceTempVariable$s$36_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian118[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian118[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 119 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																if(fixedFlag$sample35) {
																	if((0 == i$var109)) {
																		for(int var52 = 0; var52 < noStates; var52 += 1) {
																			if((var52 == traceTempVariable$s$36_1)) {
																				for(int var84 = 0; var84 < noStates; var84 += 1) {
																					if((var84 == traceTempVariable$s$36_1)) {
																						{
																							{
																								double cv$temp$58$var111;
																								{
																									// Constructing a random variable input for use later.
																									double var111 = cpuMean[traceTempVariable$s$36_1];
																									cv$temp$58$var111 = var111;
																								}
																								double cv$temp$59$var112;
																								{
																									// Constructing a random variable input for use later.
																									double var112 = cpuVar[traceTempVariable$s$36_1];
																									cv$temp$59$var112 = var112;
																								}
																								
																								// Record the probability of sample task 119 generating output with current configuration.
																								if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$58$var111) / Math.sqrt(cv$temp$59$var112))) - (0.5 * Math.log(cv$temp$59$var112)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$58$var111) / Math.sqrt(cv$temp$59$var112))) - (0.5 * Math.log(cv$temp$59$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$58$var111) / Math.sqrt(cv$temp$59$var112))) - (0.5 * Math.log(cv$temp$59$var112))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$58$var111) / Math.sqrt(cv$temp$59$var112))) - (0.5 * Math.log(cv$temp$59$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$58$var111) / Math.sqrt(cv$temp$59$var112))) - (0.5 * Math.log(cv$temp$59$var112)))));
																								}
																								
																								// Recorded the probability of reaching sample task 119 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																} else {
																	if(true) {
																		// Enumerating the possible outputs of Categorical 29.
																		for(int index$sample35$162 = 0; index$sample35$162 < noStates; index$sample35$162 += 1) {
																			int distributionTempVariable$var30$164 = index$sample35$162;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample35Value163 = (1.0 * distribution$sample35[index$sample35$162]);
																			int traceTempVariable$s$165_1 = distributionTempVariable$var30$164;
																			if((0 == i$var109)) {
																				for(int var52 = 0; var52 < noStates; var52 += 1) {
																					if((var52 == traceTempVariable$s$165_1)) {
																						for(int var84 = 0; var84 < noStates; var84 += 1) {
																							if((var84 == traceTempVariable$s$165_1)) {
																								{
																									{
																										double cv$temp$60$var111;
																										{
																											// Constructing a random variable input for use later.
																											double var111 = cpuMean[traceTempVariable$s$165_1];
																											cv$temp$60$var111 = var111;
																										}
																										double cv$temp$61$var112;
																										{
																											// Constructing a random variable input for use later.
																											double var112 = cpuVar[traceTempVariable$s$165_1];
																											cv$temp$61$var112 = var112;
																										}
																										
																										// Record the probability of sample task 119 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample35Value163) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$60$var111) / Math.sqrt(cv$temp$61$var112))) - (0.5 * Math.log(cv$temp$61$var112)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value163) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$60$var111) / Math.sqrt(cv$temp$61$var112))) - (0.5 * Math.log(cv$temp$61$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value163) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$60$var111) / Math.sqrt(cv$temp$61$var112))) - (0.5 * Math.log(cv$temp$61$var112))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value163) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$60$var111) / Math.sqrt(cv$temp$61$var112))) - (0.5 * Math.log(cv$temp$61$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value163) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$60$var111) / Math.sqrt(cv$temp$61$var112))) - (0.5 * Math.log(cv$temp$61$var112)))));
																										}
																										
																										// Recorded the probability of reaching sample task 119 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value163);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$170_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$170_1)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$170_1)) {
																					{
																						{
																							double cv$temp$62$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$170_1];
																								cv$temp$62$var111 = var111;
																							}
																							double cv$temp$63$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$170_1];
																								cv$temp$63$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$62$var111) / Math.sqrt(cv$temp$63$var112))) - (0.5 * Math.log(cv$temp$63$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$62$var111) / Math.sqrt(cv$temp$63$var112))) - (0.5 * Math.log(cv$temp$63$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$62$var111) / Math.sqrt(cv$temp$63$var112))) - (0.5 * Math.log(cv$temp$63$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$62$var111) / Math.sqrt(cv$temp$63$var112))) - (0.5 * Math.log(cv$temp$63$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$62$var111) / Math.sqrt(cv$temp$63$var112))) - (0.5 * Math.log(cv$temp$63$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																int traceTempVariable$s$171_1 = distributionTempVariable$var40$13;
																if((index$i$10 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$171_1)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$171_1)) {
																					{
																						{
																							double cv$temp$64$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$171_1];
																								cv$temp$64$var111 = var111;
																							}
																							double cv$temp$65$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$171_1];
																								cv$temp$65$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$64$var111) / Math.sqrt(cv$temp$65$var112))) - (0.5 * Math.log(cv$temp$65$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$64$var111) / Math.sqrt(cv$temp$65$var112))) - (0.5 * Math.log(cv$temp$65$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$64$var111) / Math.sqrt(cv$temp$65$var112))) - (0.5 * Math.log(cv$temp$65$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$64$var111) / Math.sqrt(cv$temp$65$var112))) - (0.5 * Math.log(cv$temp$65$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$64$var111) / Math.sqrt(cv$temp$65$var112))) - (0.5 * Math.log(cv$temp$65$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																for(int index$i$172 = 1; index$i$172 < samples; index$i$172 += 1) {
																	if((!(index$i$172 == index$i$1) && !(index$i$172 == index$i$10))) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$173 = 0; index$sample45$173 < noStates; index$sample45$173 += 1) {
																			int distributionTempVariable$var40$175 = index$sample45$173;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value174 = (1.0 * distribution$sample45[((index$i$172 - 1) / 1)][index$sample45$173]);
																			int traceTempVariable$s$176_1 = distributionTempVariable$var40$175;
																			if((index$i$172 == i$var109)) {
																				for(int var52 = 0; var52 < noStates; var52 += 1) {
																					if((var52 == traceTempVariable$s$176_1)) {
																						for(int var84 = 0; var84 < noStates; var84 += 1) {
																							if((var84 == traceTempVariable$s$176_1)) {
																								{
																									{
																										double cv$temp$66$var111;
																										{
																											// Constructing a random variable input for use later.
																											double var111 = cpuMean[traceTempVariable$s$176_1];
																											cv$temp$66$var111 = var111;
																										}
																										double cv$temp$67$var112;
																										{
																											// Constructing a random variable input for use later.
																											double var112 = cpuVar[traceTempVariable$s$176_1];
																											cv$temp$67$var112 = var112;
																										}
																										
																										// Record the probability of sample task 119 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value174) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$66$var111) / Math.sqrt(cv$temp$67$var112))) - (0.5 * Math.log(cv$temp$67$var112)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value174) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$66$var111) / Math.sqrt(cv$temp$67$var112))) - (0.5 * Math.log(cv$temp$67$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value174) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$66$var111) / Math.sqrt(cv$temp$67$var112))) - (0.5 * Math.log(cv$temp$67$var112))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value174) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$66$var111) / Math.sqrt(cv$temp$67$var112))) - (0.5 * Math.log(cv$temp$67$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value174) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$66$var111) / Math.sqrt(cv$temp$67$var112))) - (0.5 * Math.log(cv$temp$67$var112)))));
																										}
																										
																										// Recorded the probability of reaching sample task 119 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value174);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
										}
									}
									
									// Processing random variable 118.
									{
										// Looking for a path between Sample 45 and consumer Gaussian 118.
										{
											// Guard to check that at most one copy of the code is executed for a given random
											// variable instance.
											boolean[] guard$sample45gaussian123 = guard$sample45gaussian123$global;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
											}
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian123[((i$var109 - 0) / 1)] = false;
											}
											int traceTempVariable$s$226_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 124 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																for(int var63 = 0; var63 < noStates; var63 += 1) {
																	if((var63 == traceTempVariable$s$226_1)) {
																		if(fixedFlag$sample35) {
																			if((0 == i$var109)) {
																				for(int var94 = 0; var94 < noStates; var94 += 1) {
																					if((var94 == traceTempVariable$s$226_1)) {
																						{
																							{
																								double cv$temp$90$var116;
																								{
																									// Constructing a random variable input for use later.
																									double var116 = memMean[traceTempVariable$s$226_1];
																									cv$temp$90$var116 = var116;
																								}
																								double cv$temp$91$var117;
																								{
																									// Constructing a random variable input for use later.
																									double var117 = memVar[traceTempVariable$s$226_1];
																									cv$temp$91$var117 = var117;
																								}
																								
																								// Record the probability of sample task 124 generating output with current configuration.
																								if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$90$var116) / Math.sqrt(cv$temp$91$var117))) - (0.5 * Math.log(cv$temp$91$var117)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$90$var116) / Math.sqrt(cv$temp$91$var117))) - (0.5 * Math.log(cv$temp$91$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$90$var116) / Math.sqrt(cv$temp$91$var117))) - (0.5 * Math.log(cv$temp$91$var117))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$90$var116) / Math.sqrt(cv$temp$91$var117))) - (0.5 * Math.log(cv$temp$91$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$90$var116) / Math.sqrt(cv$temp$91$var117))) - (0.5 * Math.log(cv$temp$91$var117)))));
																								}
																								
																								// Recorded the probability of reaching sample task 124 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																							}
																						}
																					}
																				}
																			}
																		} else {
																			if(true) {
																				// Enumerating the possible outputs of Categorical 29.
																				for(int index$sample35$287 = 0; index$sample35$287 < noStates; index$sample35$287 += 1) {
																					int distributionTempVariable$var30$289 = index$sample35$287;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample35Value288 = (1.0 * distribution$sample35[index$sample35$287]);
																					int traceTempVariable$s$290_1 = distributionTempVariable$var30$289;
																					if((0 == i$var109)) {
																						for(int var94 = 0; var94 < noStates; var94 += 1) {
																							if((var94 == traceTempVariable$s$290_1)) {
																								{
																									{
																										double cv$temp$92$var116;
																										{
																											// Constructing a random variable input for use later.
																											double var116 = memMean[traceTempVariable$s$290_1];
																											cv$temp$92$var116 = var116;
																										}
																										double cv$temp$93$var117;
																										{
																											// Constructing a random variable input for use later.
																											double var117 = memVar[traceTempVariable$s$290_1];
																											cv$temp$93$var117 = var117;
																										}
																										
																										// Record the probability of sample task 124 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample35Value288) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$92$var116) / Math.sqrt(cv$temp$93$var117))) - (0.5 * Math.log(cv$temp$93$var117)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value288) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$92$var116) / Math.sqrt(cv$temp$93$var117))) - (0.5 * Math.log(cv$temp$93$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value288) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$92$var116) / Math.sqrt(cv$temp$93$var117))) - (0.5 * Math.log(cv$temp$93$var117))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value288) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$92$var116) / Math.sqrt(cv$temp$93$var117))) - (0.5 * Math.log(cv$temp$93$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value288) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$92$var116) / Math.sqrt(cv$temp$93$var117))) - (0.5 * Math.log(cv$temp$93$var117)))));
																										}
																										
																										// Recorded the probability of reaching sample task 124 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value288);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																for(int var63 = 0; var63 < noStates; var63 += 1) {
																	if((var63 == traceTempVariable$s$226_1)) {
																		int traceTempVariable$s$294_1 = cv$currentValue;
																		if((index$i$1 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$294_1)) {
																					{
																						{
																							double cv$temp$94$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$294_1];
																								cv$temp$94$var116 = var116;
																							}
																							double cv$temp$95$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$294_1];
																								cv$temp$95$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$94$var116) / Math.sqrt(cv$temp$95$var117))) - (0.5 * Math.log(cv$temp$95$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$94$var116) / Math.sqrt(cv$temp$95$var117))) - (0.5 * Math.log(cv$temp$95$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$94$var116) / Math.sqrt(cv$temp$95$var117))) - (0.5 * Math.log(cv$temp$95$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$94$var116) / Math.sqrt(cv$temp$95$var117))) - (0.5 * Math.log(cv$temp$95$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$94$var116) / Math.sqrt(cv$temp$95$var117))) - (0.5 * Math.log(cv$temp$95$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		int traceTempVariable$s$295_1 = distributionTempVariable$var40$13;
																		if((index$i$10 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$295_1)) {
																					{
																						{
																							double cv$temp$96$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$295_1];
																								cv$temp$96$var116 = var116;
																							}
																							double cv$temp$97$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$295_1];
																								cv$temp$97$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$96$var116) / Math.sqrt(cv$temp$97$var117))) - (0.5 * Math.log(cv$temp$97$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$96$var116) / Math.sqrt(cv$temp$97$var117))) - (0.5 * Math.log(cv$temp$97$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$96$var116) / Math.sqrt(cv$temp$97$var117))) - (0.5 * Math.log(cv$temp$97$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$96$var116) / Math.sqrt(cv$temp$97$var117))) - (0.5 * Math.log(cv$temp$97$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$96$var116) / Math.sqrt(cv$temp$97$var117))) - (0.5 * Math.log(cv$temp$97$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		for(int index$i$296 = 1; index$i$296 < samples; index$i$296 += 1) {
																			if((!(index$i$296 == index$i$1) && !(index$i$296 == index$i$10))) {
																				// Enumerating the possible outputs of Categorical 39.
																				for(int index$sample45$297 = 0; index$sample45$297 < noStates; index$sample45$297 += 1) {
																					int distributionTempVariable$var40$299 = index$sample45$297;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample45Value298 = (1.0 * distribution$sample45[((index$i$296 - 1) / 1)][index$sample45$297]);
																					int traceTempVariable$s$300_1 = distributionTempVariable$var40$299;
																					if((index$i$296 == i$var109)) {
																						for(int var94 = 0; var94 < noStates; var94 += 1) {
																							if((var94 == traceTempVariable$s$300_1)) {
																								{
																									{
																										double cv$temp$98$var116;
																										{
																											// Constructing a random variable input for use later.
																											double var116 = memMean[traceTempVariable$s$300_1];
																											cv$temp$98$var116 = var116;
																										}
																										double cv$temp$99$var117;
																										{
																											// Constructing a random variable input for use later.
																											double var117 = memVar[traceTempVariable$s$300_1];
																											cv$temp$99$var117 = var117;
																										}
																										
																										// Record the probability of sample task 124 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value298) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$98$var116) / Math.sqrt(cv$temp$99$var117))) - (0.5 * Math.log(cv$temp$99$var117)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value298) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$98$var116) / Math.sqrt(cv$temp$99$var117))) - (0.5 * Math.log(cv$temp$99$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value298) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$98$var116) / Math.sqrt(cv$temp$99$var117))) - (0.5 * Math.log(cv$temp$99$var117))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value298) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$98$var116) / Math.sqrt(cv$temp$99$var117))) - (0.5 * Math.log(cv$temp$99$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value298) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$98$var116) / Math.sqrt(cv$temp$99$var117))) - (0.5 * Math.log(cv$temp$99$var117)))));
																										}
																										
																										// Recorded the probability of reaching sample task 124 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value298);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
											int traceTempVariable$s$230_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian123[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian123[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 124 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																if(fixedFlag$sample35) {
																	if((0 == i$var109)) {
																		for(int var63 = 0; var63 < noStates; var63 += 1) {
																			if((var63 == traceTempVariable$s$230_1)) {
																				for(int var94 = 0; var94 < noStates; var94 += 1) {
																					if((var94 == traceTempVariable$s$230_1)) {
																						{
																							{
																								double cv$temp$122$var116;
																								{
																									// Constructing a random variable input for use later.
																									double var116 = memMean[traceTempVariable$s$230_1];
																									cv$temp$122$var116 = var116;
																								}
																								double cv$temp$123$var117;
																								{
																									// Constructing a random variable input for use later.
																									double var117 = memVar[traceTempVariable$s$230_1];
																									cv$temp$123$var117 = var117;
																								}
																								
																								// Record the probability of sample task 124 generating output with current configuration.
																								if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$122$var116) / Math.sqrt(cv$temp$123$var117))) - (0.5 * Math.log(cv$temp$123$var117)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$122$var116) / Math.sqrt(cv$temp$123$var117))) - (0.5 * Math.log(cv$temp$123$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$122$var116) / Math.sqrt(cv$temp$123$var117))) - (0.5 * Math.log(cv$temp$123$var117))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$122$var116) / Math.sqrt(cv$temp$123$var117))) - (0.5 * Math.log(cv$temp$123$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$122$var116) / Math.sqrt(cv$temp$123$var117))) - (0.5 * Math.log(cv$temp$123$var117)))));
																								}
																								
																								// Recorded the probability of reaching sample task 124 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																} else {
																	if(true) {
																		// Enumerating the possible outputs of Categorical 29.
																		for(int index$sample35$356 = 0; index$sample35$356 < noStates; index$sample35$356 += 1) {
																			int distributionTempVariable$var30$358 = index$sample35$356;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample35Value357 = (1.0 * distribution$sample35[index$sample35$356]);
																			int traceTempVariable$s$359_1 = distributionTempVariable$var30$358;
																			if((0 == i$var109)) {
																				for(int var63 = 0; var63 < noStates; var63 += 1) {
																					if((var63 == traceTempVariable$s$359_1)) {
																						for(int var94 = 0; var94 < noStates; var94 += 1) {
																							if((var94 == traceTempVariable$s$359_1)) {
																								{
																									{
																										double cv$temp$124$var116;
																										{
																											// Constructing a random variable input for use later.
																											double var116 = memMean[traceTempVariable$s$359_1];
																											cv$temp$124$var116 = var116;
																										}
																										double cv$temp$125$var117;
																										{
																											// Constructing a random variable input for use later.
																											double var117 = memVar[traceTempVariable$s$359_1];
																											cv$temp$125$var117 = var117;
																										}
																										
																										// Record the probability of sample task 124 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample35Value357) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$124$var116) / Math.sqrt(cv$temp$125$var117))) - (0.5 * Math.log(cv$temp$125$var117)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value357) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$124$var116) / Math.sqrt(cv$temp$125$var117))) - (0.5 * Math.log(cv$temp$125$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value357) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$124$var116) / Math.sqrt(cv$temp$125$var117))) - (0.5 * Math.log(cv$temp$125$var117))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value357) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$124$var116) / Math.sqrt(cv$temp$125$var117))) - (0.5 * Math.log(cv$temp$125$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value357) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$124$var116) / Math.sqrt(cv$temp$125$var117))) - (0.5 * Math.log(cv$temp$125$var117)))));
																										}
																										
																										// Recorded the probability of reaching sample task 124 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value357);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$364_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$364_1)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$364_1)) {
																					{
																						{
																							double cv$temp$126$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$364_1];
																								cv$temp$126$var116 = var116;
																							}
																							double cv$temp$127$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$364_1];
																								cv$temp$127$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$126$var116) / Math.sqrt(cv$temp$127$var117))) - (0.5 * Math.log(cv$temp$127$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$126$var116) / Math.sqrt(cv$temp$127$var117))) - (0.5 * Math.log(cv$temp$127$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$126$var116) / Math.sqrt(cv$temp$127$var117))) - (0.5 * Math.log(cv$temp$127$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$126$var116) / Math.sqrt(cv$temp$127$var117))) - (0.5 * Math.log(cv$temp$127$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$126$var116) / Math.sqrt(cv$temp$127$var117))) - (0.5 * Math.log(cv$temp$127$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																int traceTempVariable$s$365_1 = distributionTempVariable$var40$13;
																if((index$i$10 == i$var109)) {
																	for(int var63 = 0; var63 < noStates; var63 += 1) {
																		if((var63 == traceTempVariable$s$365_1)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$365_1)) {
																					{
																						{
																							double cv$temp$128$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = memMean[traceTempVariable$s$365_1];
																								cv$temp$128$var116 = var116;
																							}
																							double cv$temp$129$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$365_1];
																								cv$temp$129$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$128$var116) / Math.sqrt(cv$temp$129$var117))) - (0.5 * Math.log(cv$temp$129$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$128$var116) / Math.sqrt(cv$temp$129$var117))) - (0.5 * Math.log(cv$temp$129$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$128$var116) / Math.sqrt(cv$temp$129$var117))) - (0.5 * Math.log(cv$temp$129$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$128$var116) / Math.sqrt(cv$temp$129$var117))) - (0.5 * Math.log(cv$temp$129$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$128$var116) / Math.sqrt(cv$temp$129$var117))) - (0.5 * Math.log(cv$temp$129$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																for(int index$i$366 = 1; index$i$366 < samples; index$i$366 += 1) {
																	if((!(index$i$366 == index$i$1) && !(index$i$366 == index$i$10))) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$367 = 0; index$sample45$367 < noStates; index$sample45$367 += 1) {
																			int distributionTempVariable$var40$369 = index$sample45$367;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value368 = (1.0 * distribution$sample45[((index$i$366 - 1) / 1)][index$sample45$367]);
																			int traceTempVariable$s$370_1 = distributionTempVariable$var40$369;
																			if((index$i$366 == i$var109)) {
																				for(int var63 = 0; var63 < noStates; var63 += 1) {
																					if((var63 == traceTempVariable$s$370_1)) {
																						for(int var94 = 0; var94 < noStates; var94 += 1) {
																							if((var94 == traceTempVariable$s$370_1)) {
																								{
																									{
																										double cv$temp$130$var116;
																										{
																											// Constructing a random variable input for use later.
																											double var116 = memMean[traceTempVariable$s$370_1];
																											cv$temp$130$var116 = var116;
																										}
																										double cv$temp$131$var117;
																										{
																											// Constructing a random variable input for use later.
																											double var117 = memVar[traceTempVariable$s$370_1];
																											cv$temp$131$var117 = var117;
																										}
																										
																										// Record the probability of sample task 124 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value368) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$130$var116) / Math.sqrt(cv$temp$131$var117))) - (0.5 * Math.log(cv$temp$131$var117)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value368) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$130$var116) / Math.sqrt(cv$temp$131$var117))) - (0.5 * Math.log(cv$temp$131$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value368) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$130$var116) / Math.sqrt(cv$temp$131$var117))) - (0.5 * Math.log(cv$temp$131$var117))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value368) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$130$var116) / Math.sqrt(cv$temp$131$var117))) - (0.5 * Math.log(cv$temp$131$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value368) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$130$var116) / Math.sqrt(cv$temp$131$var117))) - (0.5 * Math.log(cv$temp$131$var117)))));
																										}
																										
																										// Recorded the probability of reaching sample task 124 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value368);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
										}
									}
									
									// Processing random variable 123.
									{
										// Looking for a path between Sample 45 and consumer Gaussian 123.
										{
											// Guard to check that at most one copy of the code is executed for a given random
											// variable instance.
											boolean[] guard$sample45gaussian128 = guard$sample45gaussian128$global;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
											}
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109))
													// Set the flags to false
													guard$sample45gaussian128[((i$var109 - 0) / 1)] = false;
											}
											int traceTempVariable$s$420_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 129 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																for(int var74 = 0; var74 < noStates; var74 += 1) {
																	if((var74 == traceTempVariable$s$420_1)) {
																		if(fixedFlag$sample35) {
																			if((0 == i$var109)) {
																				for(int var104 = 0; var104 < noStates; var104 += 1) {
																					if((var104 == traceTempVariable$s$420_1)) {
																						{
																							{
																								double cv$temp$154$var121;
																								{
																									// Constructing a random variable input for use later.
																									double var121 = pageFaultsMean[traceTempVariable$s$420_1];
																									cv$temp$154$var121 = var121;
																								}
																								double cv$temp$155$var122;
																								{
																									// Constructing a random variable input for use later.
																									double var122 = pageFaultsVar[traceTempVariable$s$420_1];
																									cv$temp$155$var122 = var122;
																								}
																								
																								// Record the probability of sample task 129 generating output with current configuration.
																								if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$154$var121) / Math.sqrt(cv$temp$155$var122))) - (0.5 * Math.log(cv$temp$155$var122)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$154$var121) / Math.sqrt(cv$temp$155$var122))) - (0.5 * Math.log(cv$temp$155$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$154$var121) / Math.sqrt(cv$temp$155$var122))) - (0.5 * Math.log(cv$temp$155$var122))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$154$var121) / Math.sqrt(cv$temp$155$var122))) - (0.5 * Math.log(cv$temp$155$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$154$var121) / Math.sqrt(cv$temp$155$var122))) - (0.5 * Math.log(cv$temp$155$var122)))));
																								}
																								
																								// Recorded the probability of reaching sample task 129 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																							}
																						}
																					}
																				}
																			}
																		} else {
																			if(true) {
																				// Enumerating the possible outputs of Categorical 29.
																				for(int index$sample35$481 = 0; index$sample35$481 < noStates; index$sample35$481 += 1) {
																					int distributionTempVariable$var30$483 = index$sample35$481;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample35Value482 = (1.0 * distribution$sample35[index$sample35$481]);
																					int traceTempVariable$s$484_1 = distributionTempVariable$var30$483;
																					if((0 == i$var109)) {
																						for(int var104 = 0; var104 < noStates; var104 += 1) {
																							if((var104 == traceTempVariable$s$484_1)) {
																								{
																									{
																										double cv$temp$156$var121;
																										{
																											// Constructing a random variable input for use later.
																											double var121 = pageFaultsMean[traceTempVariable$s$484_1];
																											cv$temp$156$var121 = var121;
																										}
																										double cv$temp$157$var122;
																										{
																											// Constructing a random variable input for use later.
																											double var122 = pageFaultsVar[traceTempVariable$s$484_1];
																											cv$temp$157$var122 = var122;
																										}
																										
																										// Record the probability of sample task 129 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample35Value482) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$156$var121) / Math.sqrt(cv$temp$157$var122))) - (0.5 * Math.log(cv$temp$157$var122)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value482) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$156$var121) / Math.sqrt(cv$temp$157$var122))) - (0.5 * Math.log(cv$temp$157$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value482) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$156$var121) / Math.sqrt(cv$temp$157$var122))) - (0.5 * Math.log(cv$temp$157$var122))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value482) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$156$var121) / Math.sqrt(cv$temp$157$var122))) - (0.5 * Math.log(cv$temp$157$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value482) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$156$var121) / Math.sqrt(cv$temp$157$var122))) - (0.5 * Math.log(cv$temp$157$var122)))));
																										}
																										
																										// Recorded the probability of reaching sample task 129 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value482);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																for(int var74 = 0; var74 < noStates; var74 += 1) {
																	if((var74 == traceTempVariable$s$420_1)) {
																		int traceTempVariable$s$488_1 = cv$currentValue;
																		if((index$i$1 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$488_1)) {
																					{
																						{
																							double cv$temp$158$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$488_1];
																								cv$temp$158$var121 = var121;
																							}
																							double cv$temp$159$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$488_1];
																								cv$temp$159$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$158$var121) / Math.sqrt(cv$temp$159$var122))) - (0.5 * Math.log(cv$temp$159$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$158$var121) / Math.sqrt(cv$temp$159$var122))) - (0.5 * Math.log(cv$temp$159$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$158$var121) / Math.sqrt(cv$temp$159$var122))) - (0.5 * Math.log(cv$temp$159$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$158$var121) / Math.sqrt(cv$temp$159$var122))) - (0.5 * Math.log(cv$temp$159$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$158$var121) / Math.sqrt(cv$temp$159$var122))) - (0.5 * Math.log(cv$temp$159$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		int traceTempVariable$s$489_1 = distributionTempVariable$var40$13;
																		if((index$i$10 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$489_1)) {
																					{
																						{
																							double cv$temp$160$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$489_1];
																								cv$temp$160$var121 = var121;
																							}
																							double cv$temp$161$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$489_1];
																								cv$temp$161$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$160$var121) / Math.sqrt(cv$temp$161$var122))) - (0.5 * Math.log(cv$temp$161$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$160$var121) / Math.sqrt(cv$temp$161$var122))) - (0.5 * Math.log(cv$temp$161$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$160$var121) / Math.sqrt(cv$temp$161$var122))) - (0.5 * Math.log(cv$temp$161$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$160$var121) / Math.sqrt(cv$temp$161$var122))) - (0.5 * Math.log(cv$temp$161$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$160$var121) / Math.sqrt(cv$temp$161$var122))) - (0.5 * Math.log(cv$temp$161$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																		for(int index$i$490 = 1; index$i$490 < samples; index$i$490 += 1) {
																			if((!(index$i$490 == index$i$1) && !(index$i$490 == index$i$10))) {
																				// Enumerating the possible outputs of Categorical 39.
																				for(int index$sample45$491 = 0; index$sample45$491 < noStates; index$sample45$491 += 1) {
																					int distributionTempVariable$var40$493 = index$sample45$491;
																					
																					// Update the probability of sampling this value from the distribution value.
																					double cv$probabilitySample45Value492 = (1.0 * distribution$sample45[((index$i$490 - 1) / 1)][index$sample45$491]);
																					int traceTempVariable$s$494_1 = distributionTempVariable$var40$493;
																					if((index$i$490 == i$var109)) {
																						for(int var104 = 0; var104 < noStates; var104 += 1) {
																							if((var104 == traceTempVariable$s$494_1)) {
																								{
																									{
																										double cv$temp$162$var121;
																										{
																											// Constructing a random variable input for use later.
																											double var121 = pageFaultsMean[traceTempVariable$s$494_1];
																											cv$temp$162$var121 = var121;
																										}
																										double cv$temp$163$var122;
																										{
																											// Constructing a random variable input for use later.
																											double var122 = pageFaultsVar[traceTempVariable$s$494_1];
																											cv$temp$163$var122 = var122;
																										}
																										
																										// Record the probability of sample task 129 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value492) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$162$var121) / Math.sqrt(cv$temp$163$var122))) - (0.5 * Math.log(cv$temp$163$var122)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value492) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$162$var121) / Math.sqrt(cv$temp$163$var122))) - (0.5 * Math.log(cv$temp$163$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value492) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$162$var121) / Math.sqrt(cv$temp$163$var122))) - (0.5 * Math.log(cv$temp$163$var122))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value492) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$162$var121) / Math.sqrt(cv$temp$163$var122))) - (0.5 * Math.log(cv$temp$163$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value492) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$162$var121) / Math.sqrt(cv$temp$163$var122))) - (0.5 * Math.log(cv$temp$163$var122)))));
																										}
																										
																										// Recorded the probability of reaching sample task 129 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value492);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
											int traceTempVariable$s$424_1 = cv$currentValue;
											for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
												if((i$var34 == i$var109)) {
													if(!guard$sample45gaussian128[((i$var109 - 0) / 1)]) {
														// The body will execute, so should not be executed again
														guard$sample45gaussian128[((i$var109 - 0) / 1)] = true;
														
														// Processing sample task 129 of consumer random variable null.
														{
															// Set an accumulator to sum the probabilities for each possible configuration of
															// inputs.
															double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
															
															// Set an accumulator to record the consumer distributions not seen. Initially set
															// to 1 as seen values will be deducted from this value.
															double cv$consumerDistributionProbabilityAccumulator = 1.0;
															{
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																if(fixedFlag$sample35) {
																	if((0 == i$var109)) {
																		for(int var74 = 0; var74 < noStates; var74 += 1) {
																			if((var74 == traceTempVariable$s$424_1)) {
																				for(int var104 = 0; var104 < noStates; var104 += 1) {
																					if((var104 == traceTempVariable$s$424_1)) {
																						{
																							{
																								double cv$temp$186$var121;
																								{
																									// Constructing a random variable input for use later.
																									double var121 = pageFaultsMean[traceTempVariable$s$424_1];
																									cv$temp$186$var121 = var121;
																								}
																								double cv$temp$187$var122;
																								{
																									// Constructing a random variable input for use later.
																									double var122 = pageFaultsVar[traceTempVariable$s$424_1];
																									cv$temp$187$var122 = var122;
																								}
																								
																								// Record the probability of sample task 129 generating output with current configuration.
																								if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$186$var121) / Math.sqrt(cv$temp$187$var122))) - (0.5 * Math.log(cv$temp$187$var122)))) < cv$accumulatedConsumerProbabilities))
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$186$var121) / Math.sqrt(cv$temp$187$var122))) - (0.5 * Math.log(cv$temp$187$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																								else {
																									// If the second value is -infinity.
																									if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																										cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$186$var121) / Math.sqrt(cv$temp$187$var122))) - (0.5 * Math.log(cv$temp$187$var122))));
																									else
																										cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$186$var121) / Math.sqrt(cv$temp$187$var122))) - (0.5 * Math.log(cv$temp$187$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$186$var121) / Math.sqrt(cv$temp$187$var122))) - (0.5 * Math.log(cv$temp$187$var122)))));
																								}
																								
																								// Recorded the probability of reaching sample task 129 with the current configuration.
																								cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																} else {
																	if(true) {
																		// Enumerating the possible outputs of Categorical 29.
																		for(int index$sample35$550 = 0; index$sample35$550 < noStates; index$sample35$550 += 1) {
																			int distributionTempVariable$var30$552 = index$sample35$550;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample35Value551 = (1.0 * distribution$sample35[index$sample35$550]);
																			int traceTempVariable$s$553_1 = distributionTempVariable$var30$552;
																			if((0 == i$var109)) {
																				for(int var74 = 0; var74 < noStates; var74 += 1) {
																					if((var74 == traceTempVariable$s$553_1)) {
																						for(int var104 = 0; var104 < noStates; var104 += 1) {
																							if((var104 == traceTempVariable$s$553_1)) {
																								{
																									{
																										double cv$temp$188$var121;
																										{
																											// Constructing a random variable input for use later.
																											double var121 = pageFaultsMean[traceTempVariable$s$553_1];
																											cv$temp$188$var121 = var121;
																										}
																										double cv$temp$189$var122;
																										{
																											// Constructing a random variable input for use later.
																											double var122 = pageFaultsVar[traceTempVariable$s$553_1];
																											cv$temp$189$var122 = var122;
																										}
																										
																										// Record the probability of sample task 129 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample35Value551) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$188$var121) / Math.sqrt(cv$temp$189$var122))) - (0.5 * Math.log(cv$temp$189$var122)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value551) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$188$var121) / Math.sqrt(cv$temp$189$var122))) - (0.5 * Math.log(cv$temp$189$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value551) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$188$var121) / Math.sqrt(cv$temp$189$var122))) - (0.5 * Math.log(cv$temp$189$var122))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value551) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$188$var121) / Math.sqrt(cv$temp$189$var122))) - (0.5 * Math.log(cv$temp$189$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value551) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$188$var121) / Math.sqrt(cv$temp$189$var122))) - (0.5 * Math.log(cv$temp$189$var122)))));
																										}
																										
																										// Recorded the probability of reaching sample task 129 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value551);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
																
																// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
																// the output of Sample task 45.
																int traceTempVariable$s$558_1 = cv$currentValue;
																if((index$i$1 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$558_1)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$558_1)) {
																					{
																						{
																							double cv$temp$190$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$558_1];
																								cv$temp$190$var121 = var121;
																							}
																							double cv$temp$191$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$558_1];
																								cv$temp$191$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$190$var121) / Math.sqrt(cv$temp$191$var122))) - (0.5 * Math.log(cv$temp$191$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$190$var121) / Math.sqrt(cv$temp$191$var122))) - (0.5 * Math.log(cv$temp$191$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$190$var121) / Math.sqrt(cv$temp$191$var122))) - (0.5 * Math.log(cv$temp$191$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$190$var121) / Math.sqrt(cv$temp$191$var122))) - (0.5 * Math.log(cv$temp$191$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$190$var121) / Math.sqrt(cv$temp$191$var122))) - (0.5 * Math.log(cv$temp$191$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																int traceTempVariable$s$559_1 = distributionTempVariable$var40$13;
																if((index$i$10 == i$var109)) {
																	for(int var74 = 0; var74 < noStates; var74 += 1) {
																		if((var74 == traceTempVariable$s$559_1)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$559_1)) {
																					{
																						{
																							double cv$temp$192$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = pageFaultsMean[traceTempVariable$s$559_1];
																								cv$temp$192$var121 = var121;
																							}
																							double cv$temp$193$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$559_1];
																								cv$temp$193$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$192$var121) / Math.sqrt(cv$temp$193$var122))) - (0.5 * Math.log(cv$temp$193$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$192$var121) / Math.sqrt(cv$temp$193$var122))) - (0.5 * Math.log(cv$temp$193$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$192$var121) / Math.sqrt(cv$temp$193$var122))) - (0.5 * Math.log(cv$temp$193$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$192$var121) / Math.sqrt(cv$temp$193$var122))) - (0.5 * Math.log(cv$temp$193$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$192$var121) / Math.sqrt(cv$temp$193$var122))) - (0.5 * Math.log(cv$temp$193$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																						}
																					}
																				}
																			}
																		}
																	}
																}
																for(int index$i$560 = 1; index$i$560 < samples; index$i$560 += 1) {
																	if((!(index$i$560 == index$i$1) && !(index$i$560 == index$i$10))) {
																		// Enumerating the possible outputs of Categorical 39.
																		for(int index$sample45$561 = 0; index$sample45$561 < noStates; index$sample45$561 += 1) {
																			int distributionTempVariable$var40$563 = index$sample45$561;
																			
																			// Update the probability of sampling this value from the distribution value.
																			double cv$probabilitySample45Value562 = (1.0 * distribution$sample45[((index$i$560 - 1) / 1)][index$sample45$561]);
																			int traceTempVariable$s$564_1 = distributionTempVariable$var40$563;
																			if((index$i$560 == i$var109)) {
																				for(int var74 = 0; var74 < noStates; var74 += 1) {
																					if((var74 == traceTempVariable$s$564_1)) {
																						for(int var104 = 0; var104 < noStates; var104 += 1) {
																							if((var104 == traceTempVariable$s$564_1)) {
																								{
																									{
																										double cv$temp$194$var121;
																										{
																											// Constructing a random variable input for use later.
																											double var121 = pageFaultsMean[traceTempVariable$s$564_1];
																											cv$temp$194$var121 = var121;
																										}
																										double cv$temp$195$var122;
																										{
																											// Constructing a random variable input for use later.
																											double var122 = pageFaultsVar[traceTempVariable$s$564_1];
																											cv$temp$195$var122 = var122;
																										}
																										
																										// Record the probability of sample task 129 generating output with current configuration.
																										if(((Math.log(cv$probabilitySample45Value562) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$194$var121) / Math.sqrt(cv$temp$195$var122))) - (0.5 * Math.log(cv$temp$195$var122)))) < cv$accumulatedConsumerProbabilities))
																											cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value562) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$194$var121) / Math.sqrt(cv$temp$195$var122))) - (0.5 * Math.log(cv$temp$195$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																										else {
																											// If the second value is -infinity.
																											if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																												cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value562) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$194$var121) / Math.sqrt(cv$temp$195$var122))) - (0.5 * Math.log(cv$temp$195$var122))));
																											else
																												cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value562) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$194$var121) / Math.sqrt(cv$temp$195$var122))) - (0.5 * Math.log(cv$temp$195$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value562) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$194$var121) / Math.sqrt(cv$temp$195$var122))) - (0.5 * Math.log(cv$temp$195$var122)))));
																										}
																										
																										// Recorded the probability of reaching sample task 129 with the current configuration.
																										cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value562);
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// A check to ensure rounding of floating point values can never result in a negative
															// value.
															cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
															
															// Multiply (log space add) in the probability of the sample task to the overall probability
															// for this configuration of the source random variable.
															if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
																cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
															else {
																// If the second value is -infinity.
																if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																	cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
																else
																	cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
															}
														}
													}
												}
											}
										}
									}
									
									// Add the values for the source and any standard consumers for this configuration
									// of arguments to the source.
									if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
										cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
									else {
										// If the second value is -infinity.
										if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
											cv$stateProbabilityValue = cv$accumulatedProbabilities;
										else
											cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
									}
								}
							}
						}
					}
				}
			}
			
			// Processing random variable 39.
			{
				// Looking for a path between Sample 45 and consumer Categorical 39.
				{
					int traceTempVariable$var37$603_1 = cv$currentValue;
					for(int index$i$603_2 = 1; index$i$603_2 < samples; index$i$603_2 += 1) {
						if((i$var34 == (index$i$603_2 - 1))) {
							// Processing sample task 45 of consumer random variable null.
							{
								// Copy of index so that its values can be safely substituted
								int index$i$605 = index$i$603_2;
								
								// A local array to hold the accumulated distributions of the sample tasks for each
								// configuration of distributions.
								double[] cv$accumulatedConsumerDistributions = cv$distributionAccumulator$var39;
								
								// Zero all the elements in the distribution accumulator
								for(int cv$i = 0; cv$i < noStates; cv$i += 1)
									cv$accumulatedConsumerDistributions[cv$i] = 0.0;
								
								// Zero an accumulator to track the probabilities reached.
								double cv$reachedDistributionProbability = 0.0;
								
								// Enumerating the possible arguments for the variable Categorical 39 which is consuming
								// the output of Sample task 45.
								for(int var21 = 0; var21 < noStates; var21 += 1) {
									if((var21 == traceTempVariable$var37$603_1)) {
										{
											// Declare and zero an accumulator for tracking the reached source probability space.
											double scopeVariable$reachedSourceProbability = 0.0;
											
											// Enumerating the possible arguments for Categorical 39.
											if(fixedFlag$sample35) {
												if((0 == (i$var34 - 1))) {
													for(int index$var21$612_1 = 0; index$var21$612_1 < noStates; index$var21$612_1 += 1) {
														if((index$var21$612_1 == st[(i$var34 - 1)]))
															// Add the probability of this argument configuration.
															scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
													}
												}
											} else {
												if(true) {
													// Enumerating the possible outputs of Categorical 29.
													for(int index$sample35$608 = 0; index$sample35$608 < noStates; index$sample35$608 += 1) {
														int distributionTempVariable$var30$610 = index$sample35$608;
														
														// Update the probability of sampling this value from the distribution value.
														double cv$probabilitySample35Value609 = (1.0 * distribution$sample35[index$sample35$608]);
														int traceTempVariable$var37$611_1 = distributionTempVariable$var30$610;
														if((0 == (i$var34 - 1))) {
															for(int index$var21$613_1 = 0; index$var21$613_1 < noStates; index$var21$613_1 += 1) {
																if((index$var21$613_1 == traceTempVariable$var37$611_1))
																	// Add the probability of this argument configuration.
																	scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + cv$probabilitySample35Value609);
															}
														}
													}
												}
											}
											
											// Enumerating the possible arguments for Categorical 39.
											int traceTempVariable$var37$614_1 = cv$currentValue;
											if((index$i$1 == (i$var34 - 1))) {
												for(int index$var21$620_1 = 0; index$var21$620_1 < noStates; index$var21$620_1 += 1) {
													if((index$var21$620_1 == traceTempVariable$var37$614_1))
														// Add the probability of this argument configuration.
														scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + 1.0);
												}
											}
											for(int index$i$615 = 1; index$i$615 < samples; index$i$615 += 1) {
												if((!(index$i$615 == index$i$1) && !(index$i$615 == index$i$605))) {
													// Enumerating the possible outputs of Categorical 39.
													for(int index$sample45$616 = 0; index$sample45$616 < noStates; index$sample45$616 += 1) {
														int distributionTempVariable$var40$618 = index$sample45$616;
														
														// Update the probability of sampling this value from the distribution value.
														double cv$probabilitySample45Value617 = (1.0 * distribution$sample45[((index$i$615 - 1) / 1)][index$sample45$616]);
														int traceTempVariable$var37$619_1 = distributionTempVariable$var40$618;
														if((index$i$615 == (i$var34 - 1))) {
															for(int index$var21$621_1 = 0; index$var21$621_1 < noStates; index$var21$621_1 += 1) {
																if((index$var21$621_1 == traceTempVariable$var37$619_1))
																	// Add the probability of this argument configuration.
																	scopeVariable$reachedSourceProbability = (scopeVariable$reachedSourceProbability + cv$probabilitySample45Value617);
															}
														}
													}
												}
											}
											double[] cv$temp$196$var38;
											{
												// Constructing a random variable input for use later.
												double[] var38 = m[traceTempVariable$var37$603_1];
												cv$temp$196$var38 = var38;
											}
											
											// The probability of reaching the consumer with this set of consumer arguments
											double cv$distributionProbability = (scopeVariable$reachedSourceProbability * 1.0);
											
											// Record the reached distribution.
											cv$reachedDistributionProbability = (cv$reachedDistributionProbability + cv$distributionProbability);
											
											// Add the current distribution to the distribution accumulator.
											DistributionSampling.addProbabilityDistributionCategorical(cv$accumulatedConsumerDistributions, cv$distributionProbability, cv$temp$196$var38);
										}
									}
								}
								
								// A local copy of the samples' distribution.
								double[] cv$sampleDistribution = distribution$sample45[((index$i$603_2 - 1) / 1)];
								
								// The overlap of the distributions so far.
								double cv$overlap = 0.0;
								
								// Calculate the overlap for each element in the distribution
								for(int cv$i = 0; cv$i < noStates; cv$i += 1) {
									// Normalise the values in the calculated distribution
									double cv$normalisedDistValue = (cv$accumulatedConsumerDistributions[cv$i] / cv$reachedDistributionProbability);
									
									// Corresponding value from the sample distribution
									double cv$sampleDistValue = cv$sampleDistribution[cv$i];
									
									// Calculate the overlap and store the result
									if((cv$sampleDistValue < cv$normalisedDistValue))
										cv$overlap = (cv$overlap + cv$sampleDistValue);
									
									// Calculate the overlap and store the result
									else
										cv$overlap = (cv$overlap + cv$normalisedDistValue);
								}
								
								// Scale and add the result to the combined results so far. A min is taken over the
								// reached distributions so that rounding cannot result in a value greater than one
								// as for a small probability this could give a negative value
								cv$accumulatedDistributionProbabilities = (cv$accumulatedDistributionProbabilities + Math.log(((cv$overlap * cv$reachedDistributionProbability) + (1.0 - Math.min(cv$reachedDistributionProbability, 1.0)))));
							}
						}
					}
				}
			}
			
			// Save the calculated index value into the array of index value probabilities
			cv$stateProbabilityLocal[cv$valuePos] = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// Set the calculated probabilities to be the distribution values, and normalize
		// 
		// Local copy of the probability array
		double[] cv$localProbability = distribution$sample45[((i$var34 - 1) / 1)];
		
		// The sum of all the probabilities in log space
		double cv$logSum = 0.0;
		
		// Sum all the values
		{
			// Initialise the max to the first element.
			double cv$lseMax = cv$stateProbabilityLocal[0];
			
			// Find max value.
			for(int cv$lseIndex = 1; cv$lseIndex < cv$stateProbabilityLocal.length; cv$lseIndex += 1) {
				double cv$lseElementValue = cv$stateProbabilityLocal[cv$lseIndex];
				if((cv$lseMax < cv$lseElementValue))
					cv$lseMax = cv$lseElementValue;
			}
			
			// If the maximum value is -infinity return -infinity.
			if((cv$lseMax == Double.NEGATIVE_INFINITY))
				cv$logSum = Double.NEGATIVE_INFINITY;
			
			// Sum the values in the array.
			else {
				// Initialise the sum of the array elements
				double cv$lseSum = 0.0;
				
				// Offset values, move to normal space, and sum.
				for(int cv$lseIndex = 0; cv$lseIndex < cv$stateProbabilityLocal.length; cv$lseIndex += 1)
					cv$lseSum = (cv$lseSum + Math.exp((cv$stateProbabilityLocal[cv$lseIndex] - cv$lseMax)));
				
				// Increment the value of the target, moving the value back into log space.
				cv$logSum = (cv$logSum + (Math.log(cv$lseSum) + cv$lseMax));
			}
		}
		
		// If all the sum is zero, just share the probability evenly.
		if((cv$logSum == Double.NEGATIVE_INFINITY)) {
			// Normalize log space values and move to normal space
			for(int cv$indexName = 0; cv$indexName < cv$stateProbabilityLocal.length; cv$indexName += 1)
				cv$localProbability[cv$indexName] = (1.0 / cv$stateProbabilityLocal.length);
		} else {
			// Normalize log space values and move to normal space
			for(int cv$indexName = 0; cv$indexName < cv$stateProbabilityLocal.length; cv$indexName += 1)
				cv$localProbability[cv$indexName] = Math.exp((cv$stateProbabilityLocal[cv$indexName] - cv$logSum));
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 58 drawn from Gaussian 48. Inference was performed using Metropolis-Hastings.
	private final void sample58(int var52) {
		// The original value of the sample
		double cv$originalValue = cpuMean[var52];
		
		// The probability of the random variable generating the originally sampled value
		double cv$originalProbability = 0.0;
		
		// Calculate a proposed variance.
		double cv$var = ((cv$originalValue * cv$originalValue) * (0.1 * 0.1));
		
		// Ensure the variance is at least 0.01
		if((cv$var < (0.1 * 0.1)))
			cv$var = (0.1 * 0.1);
		
		// The proposed new value for the sample
		double cv$proposedValue = ((Math.sqrt(cv$var) * DistributionSampling.sampleGaussian(RNG$)) + cv$originalValue);
		
		// The probability of the random variable generating the new sample value.
		double cv$proposedProbability = 0.0;
		for(int cv$valuePos = 0; cv$valuePos < 2; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			double cv$currentValue;
			if((cv$valuePos == 0))
				// Set the current value to the current state of the tree.
				cv$currentValue = cv$originalValue;
			else {
				cv$currentValue = cv$proposedValue;
				
				// Update Sample and intermediate values
				{
					// Write out the value of the sample to a temporary variable prior to updating the
					// intermediate variables.
					double var53 = cv$proposedValue;
					cpuMean[var52] = cv$currentValue;
				}
			}
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double cv$temp$0$var47;
				{
					cv$temp$0$var47 = 16.0;
				}
				double cv$temp$1$var46;
				{
					cv$temp$1$var46 = 8.6;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$currentValue - cv$temp$0$var47) / Math.sqrt(cv$temp$1$var46))) - (0.5 * Math.log(cv$temp$1$var46))));
				
				// Processing random variable 113.
				{
					// Looking for a path between Sample 58 and consumer Gaussian 113.
					{
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample35) {
								if((0 == i$var109)) {
									double traceTempVariable$var111$7_1 = cv$currentValue;
									if((var52 == st[i$var109])) {
										// Processing sample task 119 of consumer random variable null.
										{
											// Set an accumulator to sum the probabilities for each possible configuration of
											// inputs.
											double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
											
											// Set an accumulator to record the consumer distributions not seen. Initially set
											// to 1 as seen values will be deducted from this value.
											double cv$consumerDistributionProbabilityAccumulator = 1.0;
											{
												// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
												// the output of Sample task 58.
												if((0 == i$var109)) {
													for(int var84 = 0; var84 < noStates; var84 += 1) {
														if((var84 == st[i$var109])) {
															{
																{
																	double cv$temp$2$var111;
																	{
																		// Constructing a random variable input for use later.
																		double var111 = traceTempVariable$var111$7_1;
																		cv$temp$2$var111 = var111;
																	}
																	double cv$temp$3$var112;
																	{
																		// Constructing a random variable input for use later.
																		double var112 = cpuVar[st[i$var109]];
																		cv$temp$3$var112 = var112;
																	}
																	
																	// Record the probability of sample task 119 generating output with current configuration.
																	if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))) < cv$accumulatedConsumerProbabilities))
																		cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																	else {
																		// If the second value is -infinity.
																		if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																			cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112))));
																		else
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))));
																	}
																	
																	// Recorded the probability of reaching sample task 119 with the current configuration.
																	cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																}
															}
														}
													}
												}
												
												// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
												// the output of Sample task 58.
												if(fixedFlag$sample45) {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if((i$var34 == i$var109)) {
															for(int var84 = 0; var84 < noStates; var84 += 1) {
																if((var84 == st[i$var109])) {
																	{
																		{
																			double cv$temp$4$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = traceTempVariable$var111$7_1;
																				cv$temp$4$var111 = var111;
																			}
																			double cv$temp$5$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = cpuVar[st[i$var109]];
																				cv$temp$5$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												} else {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if(true) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$26 = 0; index$sample45$26 < noStates; index$sample45$26 += 1) {
																int distributionTempVariable$var40$28 = index$sample45$26;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value27 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$26]);
																int traceTempVariable$s$29_1 = distributionTempVariable$var40$28;
																if((i$var34 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$6$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = traceTempVariable$var111$7_1;
																						cv$temp$6$var111 = var111;
																					}
																					double cv$temp$7$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$29_1];
																						cv$temp$7$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value27);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// A check to ensure rounding of floating point values can never result in a negative
											// value.
											cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
											
											// Multiply (log space add) in the probability of the sample task to the overall probability
											// for this configuration of the source random variable.
											if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
												cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
											else {
												// If the second value is -infinity.
												if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
													cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
												else
													cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
											}
										}
									}
								}
							} else {
								if(true) {
									// Enumerating the possible outputs of Categorical 29.
									for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
										int distributionTempVariable$var30$5 = index$sample35$3;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
										int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
										if((0 == i$var109)) {
											double traceTempVariable$var111$8_1 = cv$currentValue;
											if((var52 == traceTempVariable$s$6_1)) {
												// Processing sample task 119 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 58.
														int traceTempVariable$s$32_1 = distributionTempVariable$var30$5;
														if((0 == i$var109)) {
															for(int var84 = 0; var84 < noStates; var84 += 1) {
																if((var84 == traceTempVariable$s$32_1)) {
																	{
																		{
																			double cv$temp$8$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = traceTempVariable$var111$8_1;
																				cv$temp$8$var111 = var111;
																			}
																			double cv$temp$9$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = cpuVar[traceTempVariable$s$32_1];
																				cv$temp$9$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																		}
																	}
																}
															}
														}
														if(!true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$33 = 0; index$sample35$33 < noStates; index$sample35$33 += 1) {
																int distributionTempVariable$var30$35 = index$sample35$33;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value34 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$33]);
																int traceTempVariable$s$36_1 = distributionTempVariable$var30$35;
																if((0 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$36_1)) {
																			{
																				{
																					double cv$temp$10$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = traceTempVariable$var111$8_1;
																						cv$temp$10$var111 = var111;
																					}
																					double cv$temp$11$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$36_1];
																						cv$temp$11$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value34);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 58.
														if(fixedFlag$sample45) {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if((i$var34 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$6_1)) {
																			{
																				{
																					double cv$temp$12$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = traceTempVariable$var111$8_1;
																						cv$temp$12$var111 = var111;
																					}
																					double cv$temp$13$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$6_1];
																						cv$temp$13$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																				}
																			}
																		}
																	}
																}
															}
														} else {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if(true) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
																		int distributionTempVariable$var40$43 = index$sample45$41;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value42 = (cv$probabilitySample35Value4 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$41]);
																		int traceTempVariable$s$44_1 = distributionTempVariable$var40$43;
																		if((i$var34 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$44_1)) {
																					{
																						{
																							double cv$temp$14$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = traceTempVariable$var111$8_1;
																								cv$temp$14$var111 = var111;
																							}
																							double cv$temp$15$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$44_1];
																								cv$temp$15$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value42);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample45) {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if((i$var34 == i$var109)) {
										double traceTempVariable$var111$16_1 = cv$currentValue;
										if((var52 == st[i$var109])) {
											// Processing sample task 119 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 58.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var84 = 0; var84 < noStates; var84 += 1) {
																if((var84 == st[i$var109])) {
																	{
																		{
																			double cv$temp$16$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = traceTempVariable$var111$16_1;
																				cv$temp$16$var111 = var111;
																			}
																			double cv$temp$17$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = cpuVar[st[i$var109]];
																				cv$temp$17$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$48 = 0; index$sample35$48 < noStates; index$sample35$48 += 1) {
																int distributionTempVariable$var30$50 = index$sample35$48;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value49 = (1.0 * distribution$sample35[index$sample35$48]);
																int traceTempVariable$s$51_1 = distributionTempVariable$var30$50;
																if((0 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$51_1)) {
																			{
																				{
																					double cv$temp$18$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = traceTempVariable$var111$16_1;
																						cv$temp$18$var111 = var111;
																					}
																					double cv$temp$19$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$51_1];
																						cv$temp$19$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value49);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 58.
													for(int index$i$54_1 = 1; index$i$54_1 < samples; index$i$54_1 += 1) {
														if((index$i$54_1 == i$var109)) {
															for(int var84 = 0; var84 < noStates; var84 += 1) {
																if((var84 == st[i$var109])) {
																	{
																		{
																			double cv$temp$20$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = traceTempVariable$var111$16_1;
																				cv$temp$20$var111 = var111;
																			}
																			double cv$temp$21$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = cpuVar[st[i$var109]];
																				cv$temp$21$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							} else {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if(true) {
										// Enumerating the possible outputs of Categorical 39.
										for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
											int distributionTempVariable$var40$14 = index$sample45$12;
											
											// Update the probability of sampling this value from the distribution value.
											double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$12]);
											int traceTempVariable$s$15_1 = distributionTempVariable$var40$14;
											if((i$var34 == i$var109)) {
												double traceTempVariable$var111$17_1 = cv$currentValue;
												if((var52 == traceTempVariable$s$15_1)) {
													// Processing sample task 119 of consumer random variable null.
													{
														// Set an accumulator to sum the probabilities for each possible configuration of
														// inputs.
														double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
														
														// Set an accumulator to record the consumer distributions not seen. Initially set
														// to 1 as seen values will be deducted from this value.
														double cv$consumerDistributionProbabilityAccumulator = 1.0;
														{
															// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
															// the output of Sample task 58.
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var84 = 0; var84 < noStates; var84 += 1) {
																		if((var84 == traceTempVariable$s$15_1)) {
																			{
																				{
																					double cv$temp$22$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = traceTempVariable$var111$17_1;
																						cv$temp$22$var111 = var111;
																					}
																					double cv$temp$23$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = cpuVar[traceTempVariable$s$15_1];
																						cv$temp$23$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$57 = 0; index$sample35$57 < noStates; index$sample35$57 += 1) {
																		int distributionTempVariable$var30$59 = index$sample35$57;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value58 = (cv$probabilitySample45Value13 * distribution$sample35[index$sample35$57]);
																		int traceTempVariable$s$60_1 = distributionTempVariable$var30$59;
																		if((0 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$60_1)) {
																					{
																						{
																							double cv$temp$24$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = traceTempVariable$var111$17_1;
																								cv$temp$24$var111 = var111;
																							}
																							double cv$temp$25$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$60_1];
																								cv$temp$25$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value58);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
															// the output of Sample task 58.
															int traceTempVariable$s$63_1 = distributionTempVariable$var40$14;
															if((i$var34 == i$var109)) {
																for(int var84 = 0; var84 < noStates; var84 += 1) {
																	if((var84 == traceTempVariable$s$63_1)) {
																		{
																			{
																				double cv$temp$26$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = traceTempVariable$var111$17_1;
																					cv$temp$26$var111 = var111;
																				}
																				double cv$temp$27$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = cpuVar[traceTempVariable$s$63_1];
																					cv$temp$27$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																			}
																		}
																	}
																}
															}
															for(int index$i$64 = 1; index$i$64 < samples; index$i$64 += 1) {
																if(!(index$i$64 == i$var34)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$65 = 0; index$sample45$65 < noStates; index$sample45$65 += 1) {
																		int distributionTempVariable$var40$67 = index$sample45$65;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value66 = (cv$probabilitySample45Value13 * distribution$sample45[((index$i$64 - 1) / 1)][index$sample45$65]);
																		int traceTempVariable$s$68_1 = distributionTempVariable$var40$67;
																		if((index$i$64 == i$var109)) {
																			for(int var84 = 0; var84 < noStates; var84 += 1) {
																				if((var84 == traceTempVariable$s$68_1)) {
																					{
																						{
																							double cv$temp$28$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = traceTempVariable$var111$17_1;
																								cv$temp$28$var111 = var111;
																							}
																							double cv$temp$29$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = cpuVar[traceTempVariable$s$68_1];
																								cv$temp$29$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value66);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// A check to ensure rounding of floating point values can never result in a negative
														// value.
														cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
														
														// Multiply (log space add) in the probability of the sample task to the overall probability
														// for this configuration of the source random variable.
														if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
															cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
														else {
															// If the second value is -infinity.
															if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
															else
																cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Save the probability of the original value.
			if((cv$valuePos == 0))
				cv$originalProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
			
			// Save the probability of the proposed value.
			else
				cv$proposedProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// The probability ration for the proposed value and the current value.
		double cv$ratio = (cv$proposedProbability - cv$originalProbability);
		
		// Test if the probability of the sample is sufficient to keep the value. This needs
		// to be less than or equal as otherwise if the proposed value is not possible and
		// the random value is 0 an impossible value will be accepted.
		if((((cv$proposedProbability - cv$originalProbability) <= Math.log((0.0 + ((1.0 - 0.0) * DistributionSampling.sampleUniform(RNG$))))) || Double.isNaN(cv$ratio))) {
			// If it is not revert the changes.
			// 
			// Set the sample value
			// Write out the value of the sample to a temporary variable prior to updating the
			// intermediate variables.
			double var53 = cv$originalValue;
			cpuMean[var52] = var53;
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 69 drawn from Gaussian 59. Inference was performed using Metropolis-Hastings.
	private final void sample69(int var63) {
		// The original value of the sample
		double cv$originalValue = memMean[var63];
		
		// The probability of the random variable generating the originally sampled value
		double cv$originalProbability = 0.0;
		
		// Calculate a proposed variance.
		double cv$var = ((cv$originalValue * cv$originalValue) * (0.1 * 0.1));
		
		// Ensure the variance is at least 0.01
		if((cv$var < (0.1 * 0.1)))
			cv$var = (0.1 * 0.1);
		
		// The proposed new value for the sample
		double cv$proposedValue = ((Math.sqrt(cv$var) * DistributionSampling.sampleGaussian(RNG$)) + cv$originalValue);
		
		// The probability of the random variable generating the new sample value.
		double cv$proposedProbability = 0.0;
		for(int cv$valuePos = 0; cv$valuePos < 2; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			double cv$currentValue;
			if((cv$valuePos == 0))
				// Set the current value to the current state of the tree.
				cv$currentValue = cv$originalValue;
			else {
				cv$currentValue = cv$proposedValue;
				
				// Update Sample and intermediate values
				{
					// Write out the value of the sample to a temporary variable prior to updating the
					// intermediate variables.
					double var64 = cv$proposedValue;
					memMean[var63] = cv$currentValue;
				}
			}
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double cv$temp$0$var57;
				{
					cv$temp$0$var57 = 94.0;
				}
				double cv$temp$1$var58;
				{
					cv$temp$1$var58 = 1.0;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$currentValue - cv$temp$0$var57) / Math.sqrt(cv$temp$1$var58))) - (0.5 * Math.log(cv$temp$1$var58))));
				
				// Processing random variable 118.
				{
					// Looking for a path between Sample 69 and consumer Gaussian 118.
					{
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample35) {
								if((0 == i$var109)) {
									double traceTempVariable$var116$7_1 = cv$currentValue;
									if((var63 == st[i$var109])) {
										// Processing sample task 124 of consumer random variable null.
										{
											// Set an accumulator to sum the probabilities for each possible configuration of
											// inputs.
											double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
											
											// Set an accumulator to record the consumer distributions not seen. Initially set
											// to 1 as seen values will be deducted from this value.
											double cv$consumerDistributionProbabilityAccumulator = 1.0;
											{
												// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
												// the output of Sample task 69.
												if((0 == i$var109)) {
													for(int var94 = 0; var94 < noStates; var94 += 1) {
														if((var94 == st[i$var109])) {
															{
																{
																	double cv$temp$2$var116;
																	{
																		// Constructing a random variable input for use later.
																		double var116 = traceTempVariable$var116$7_1;
																		cv$temp$2$var116 = var116;
																	}
																	double cv$temp$3$var117;
																	{
																		// Constructing a random variable input for use later.
																		double var117 = memVar[st[i$var109]];
																		cv$temp$3$var117 = var117;
																	}
																	
																	// Record the probability of sample task 124 generating output with current configuration.
																	if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))) < cv$accumulatedConsumerProbabilities))
																		cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																	else {
																		// If the second value is -infinity.
																		if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																			cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117))));
																		else
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$2$var116) / Math.sqrt(cv$temp$3$var117))) - (0.5 * Math.log(cv$temp$3$var117)))));
																	}
																	
																	// Recorded the probability of reaching sample task 124 with the current configuration.
																	cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																}
															}
														}
													}
												}
												
												// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
												// the output of Sample task 69.
												if(fixedFlag$sample45) {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if((i$var34 == i$var109)) {
															for(int var94 = 0; var94 < noStates; var94 += 1) {
																if((var94 == st[i$var109])) {
																	{
																		{
																			double cv$temp$4$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = traceTempVariable$var116$7_1;
																				cv$temp$4$var116 = var116;
																			}
																			double cv$temp$5$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = memVar[st[i$var109]];
																				cv$temp$5$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$4$var116) / Math.sqrt(cv$temp$5$var117))) - (0.5 * Math.log(cv$temp$5$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												} else {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if(true) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$26 = 0; index$sample45$26 < noStates; index$sample45$26 += 1) {
																int distributionTempVariable$var40$28 = index$sample45$26;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value27 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$26]);
																int traceTempVariable$s$29_1 = distributionTempVariable$var40$28;
																if((i$var34 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$6$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = traceTempVariable$var116$7_1;
																						cv$temp$6$var116 = var116;
																					}
																					double cv$temp$7$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$29_1];
																						cv$temp$7$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$6$var116) / Math.sqrt(cv$temp$7$var117))) - (0.5 * Math.log(cv$temp$7$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value27);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// A check to ensure rounding of floating point values can never result in a negative
											// value.
											cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
											
											// Multiply (log space add) in the probability of the sample task to the overall probability
											// for this configuration of the source random variable.
											if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
												cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
											else {
												// If the second value is -infinity.
												if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
													cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
												else
													cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
											}
										}
									}
								}
							} else {
								if(true) {
									// Enumerating the possible outputs of Categorical 29.
									for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
										int distributionTempVariable$var30$5 = index$sample35$3;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
										int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
										if((0 == i$var109)) {
											double traceTempVariable$var116$8_1 = cv$currentValue;
											if((var63 == traceTempVariable$s$6_1)) {
												// Processing sample task 124 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 69.
														int traceTempVariable$s$32_1 = distributionTempVariable$var30$5;
														if((0 == i$var109)) {
															for(int var94 = 0; var94 < noStates; var94 += 1) {
																if((var94 == traceTempVariable$s$32_1)) {
																	{
																		{
																			double cv$temp$8$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = traceTempVariable$var116$8_1;
																				cv$temp$8$var116 = var116;
																			}
																			double cv$temp$9$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = memVar[traceTempVariable$s$32_1];
																				cv$temp$9$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$8$var116) / Math.sqrt(cv$temp$9$var117))) - (0.5 * Math.log(cv$temp$9$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																		}
																	}
																}
															}
														}
														if(!true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$33 = 0; index$sample35$33 < noStates; index$sample35$33 += 1) {
																int distributionTempVariable$var30$35 = index$sample35$33;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value34 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$33]);
																int traceTempVariable$s$36_1 = distributionTempVariable$var30$35;
																if((0 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$36_1)) {
																			{
																				{
																					double cv$temp$10$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = traceTempVariable$var116$8_1;
																						cv$temp$10$var116 = var116;
																					}
																					double cv$temp$11$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$36_1];
																						cv$temp$11$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$10$var116) / Math.sqrt(cv$temp$11$var117))) - (0.5 * Math.log(cv$temp$11$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value34);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
														// the output of Sample task 69.
														if(fixedFlag$sample45) {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if((i$var34 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$6_1)) {
																			{
																				{
																					double cv$temp$12$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = traceTempVariable$var116$8_1;
																						cv$temp$12$var116 = var116;
																					}
																					double cv$temp$13$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$6_1];
																						cv$temp$13$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$12$var116) / Math.sqrt(cv$temp$13$var117))) - (0.5 * Math.log(cv$temp$13$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																				}
																			}
																		}
																	}
																}
															}
														} else {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if(true) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
																		int distributionTempVariable$var40$43 = index$sample45$41;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value42 = (cv$probabilitySample35Value4 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$41]);
																		int traceTempVariable$s$44_1 = distributionTempVariable$var40$43;
																		if((i$var34 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$44_1)) {
																					{
																						{
																							double cv$temp$14$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = traceTempVariable$var116$8_1;
																								cv$temp$14$var116 = var116;
																							}
																							double cv$temp$15$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$44_1];
																								cv$temp$15$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$14$var116) / Math.sqrt(cv$temp$15$var117))) - (0.5 * Math.log(cv$temp$15$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value42);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample45) {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if((i$var34 == i$var109)) {
										double traceTempVariable$var116$16_1 = cv$currentValue;
										if((var63 == st[i$var109])) {
											// Processing sample task 124 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 69.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var94 = 0; var94 < noStates; var94 += 1) {
																if((var94 == st[i$var109])) {
																	{
																		{
																			double cv$temp$16$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = traceTempVariable$var116$16_1;
																				cv$temp$16$var116 = var116;
																			}
																			double cv$temp$17$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = memVar[st[i$var109]];
																				cv$temp$17$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$16$var116) / Math.sqrt(cv$temp$17$var117))) - (0.5 * Math.log(cv$temp$17$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$48 = 0; index$sample35$48 < noStates; index$sample35$48 += 1) {
																int distributionTempVariable$var30$50 = index$sample35$48;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value49 = (1.0 * distribution$sample35[index$sample35$48]);
																int traceTempVariable$s$51_1 = distributionTempVariable$var30$50;
																if((0 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$51_1)) {
																			{
																				{
																					double cv$temp$18$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = traceTempVariable$var116$16_1;
																						cv$temp$18$var116 = var116;
																					}
																					double cv$temp$19$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$51_1];
																						cv$temp$19$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$18$var116) / Math.sqrt(cv$temp$19$var117))) - (0.5 * Math.log(cv$temp$19$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value49);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
													// the output of Sample task 69.
													for(int index$i$54_1 = 1; index$i$54_1 < samples; index$i$54_1 += 1) {
														if((index$i$54_1 == i$var109)) {
															for(int var94 = 0; var94 < noStates; var94 += 1) {
																if((var94 == st[i$var109])) {
																	{
																		{
																			double cv$temp$20$var116;
																			{
																				// Constructing a random variable input for use later.
																				double var116 = traceTempVariable$var116$16_1;
																				cv$temp$20$var116 = var116;
																			}
																			double cv$temp$21$var117;
																			{
																				// Constructing a random variable input for use later.
																				double var117 = memVar[st[i$var109]];
																				cv$temp$21$var117 = var117;
																			}
																			
																			// Record the probability of sample task 124 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$20$var116) / Math.sqrt(cv$temp$21$var117))) - (0.5 * Math.log(cv$temp$21$var117)))));
																			}
																			
																			// Recorded the probability of reaching sample task 124 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							} else {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if(true) {
										// Enumerating the possible outputs of Categorical 39.
										for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
											int distributionTempVariable$var40$14 = index$sample45$12;
											
											// Update the probability of sampling this value from the distribution value.
											double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$12]);
											int traceTempVariable$s$15_1 = distributionTempVariable$var40$14;
											if((i$var34 == i$var109)) {
												double traceTempVariable$var116$17_1 = cv$currentValue;
												if((var63 == traceTempVariable$s$15_1)) {
													// Processing sample task 124 of consumer random variable null.
													{
														// Set an accumulator to sum the probabilities for each possible configuration of
														// inputs.
														double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
														
														// Set an accumulator to record the consumer distributions not seen. Initially set
														// to 1 as seen values will be deducted from this value.
														double cv$consumerDistributionProbabilityAccumulator = 1.0;
														{
															// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
															// the output of Sample task 69.
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var94 = 0; var94 < noStates; var94 += 1) {
																		if((var94 == traceTempVariable$s$15_1)) {
																			{
																				{
																					double cv$temp$22$var116;
																					{
																						// Constructing a random variable input for use later.
																						double var116 = traceTempVariable$var116$17_1;
																						cv$temp$22$var116 = var116;
																					}
																					double cv$temp$23$var117;
																					{
																						// Constructing a random variable input for use later.
																						double var117 = memVar[traceTempVariable$s$15_1];
																						cv$temp$23$var117 = var117;
																					}
																					
																					// Record the probability of sample task 124 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$22$var116) / Math.sqrt(cv$temp$23$var117))) - (0.5 * Math.log(cv$temp$23$var117)))));
																					}
																					
																					// Recorded the probability of reaching sample task 124 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$57 = 0; index$sample35$57 < noStates; index$sample35$57 += 1) {
																		int distributionTempVariable$var30$59 = index$sample35$57;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value58 = (cv$probabilitySample45Value13 * distribution$sample35[index$sample35$57]);
																		int traceTempVariable$s$60_1 = distributionTempVariable$var30$59;
																		if((0 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$60_1)) {
																					{
																						{
																							double cv$temp$24$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = traceTempVariable$var116$17_1;
																								cv$temp$24$var116 = var116;
																							}
																							double cv$temp$25$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$60_1];
																								cv$temp$25$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))))) + 1)) + (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$24$var116) / Math.sqrt(cv$temp$25$var117))) - (0.5 * Math.log(cv$temp$25$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value58);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// Enumerating the possible arguments for the variable Gaussian 118 which is consuming
															// the output of Sample task 69.
															int traceTempVariable$s$63_1 = distributionTempVariable$var40$14;
															if((i$var34 == i$var109)) {
																for(int var94 = 0; var94 < noStates; var94 += 1) {
																	if((var94 == traceTempVariable$s$63_1)) {
																		{
																			{
																				double cv$temp$26$var116;
																				{
																					// Constructing a random variable input for use later.
																					double var116 = traceTempVariable$var116$17_1;
																					cv$temp$26$var116 = var116;
																				}
																				double cv$temp$27$var117;
																				{
																					// Constructing a random variable input for use later.
																					double var117 = memVar[traceTempVariable$s$63_1];
																					cv$temp$27$var117 = var117;
																				}
																				
																				// Record the probability of sample task 124 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$26$var116) / Math.sqrt(cv$temp$27$var117))) - (0.5 * Math.log(cv$temp$27$var117)))));
																				}
																				
																				// Recorded the probability of reaching sample task 124 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																			}
																		}
																	}
																}
															}
															for(int index$i$64 = 1; index$i$64 < samples; index$i$64 += 1) {
																if(!(index$i$64 == i$var34)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$65 = 0; index$sample45$65 < noStates; index$sample45$65 += 1) {
																		int distributionTempVariable$var40$67 = index$sample45$65;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value66 = (cv$probabilitySample45Value13 * distribution$sample45[((index$i$64 - 1) / 1)][index$sample45$65]);
																		int traceTempVariable$s$68_1 = distributionTempVariable$var40$67;
																		if((index$i$64 == i$var109)) {
																			for(int var94 = 0; var94 < noStates; var94 += 1) {
																				if((var94 == traceTempVariable$s$68_1)) {
																					{
																						{
																							double cv$temp$28$var116;
																							{
																								// Constructing a random variable input for use later.
																								double var116 = traceTempVariable$var116$17_1;
																								cv$temp$28$var116 = var116;
																							}
																							double cv$temp$29$var117;
																							{
																								// Constructing a random variable input for use later.
																								double var117 = memVar[traceTempVariable$s$68_1];
																								cv$temp$29$var117 = var117;
																							}
																							
																							// Record the probability of sample task 124 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))))) + 1)) + (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((mem[i$var109] - cv$temp$28$var116) / Math.sqrt(cv$temp$29$var117))) - (0.5 * Math.log(cv$temp$29$var117)))));
																							}
																							
																							// Recorded the probability of reaching sample task 124 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value66);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// A check to ensure rounding of floating point values can never result in a negative
														// value.
														cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
														
														// Multiply (log space add) in the probability of the sample task to the overall probability
														// for this configuration of the source random variable.
														if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
															cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
														else {
															// If the second value is -infinity.
															if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
															else
																cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Save the probability of the original value.
			if((cv$valuePos == 0))
				cv$originalProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
			
			// Save the probability of the proposed value.
			else
				cv$proposedProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// The probability ration for the proposed value and the current value.
		double cv$ratio = (cv$proposedProbability - cv$originalProbability);
		
		// Test if the probability of the sample is sufficient to keep the value. This needs
		// to be less than or equal as otherwise if the proposed value is not possible and
		// the random value is 0 an impossible value will be accepted.
		if((((cv$proposedProbability - cv$originalProbability) <= Math.log((0.0 + ((1.0 - 0.0) * DistributionSampling.sampleUniform(RNG$))))) || Double.isNaN(cv$ratio))) {
			// If it is not revert the changes.
			// 
			// Set the sample value
			// Write out the value of the sample to a temporary variable prior to updating the
			// intermediate variables.
			double var64 = cv$originalValue;
			memMean[var63] = var64;
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 80 drawn from Gaussian 70. Inference was performed using Metropolis-Hastings.
	private final void sample80(int var74) {
		// The original value of the sample
		double cv$originalValue = pageFaultsMean[var74];
		
		// The probability of the random variable generating the originally sampled value
		double cv$originalProbability = 0.0;
		
		// Calculate a proposed variance.
		double cv$var = ((cv$originalValue * cv$originalValue) * (0.1 * 0.1));
		
		// Ensure the variance is at least 0.01
		if((cv$var < (0.1 * 0.1)))
			cv$var = (0.1 * 0.1);
		
		// The proposed new value for the sample
		double cv$proposedValue = ((Math.sqrt(cv$var) * DistributionSampling.sampleGaussian(RNG$)) + cv$originalValue);
		
		// The probability of the random variable generating the new sample value.
		double cv$proposedProbability = 0.0;
		for(int cv$valuePos = 0; cv$valuePos < 2; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			double cv$currentValue;
			if((cv$valuePos == 0))
				// Set the current value to the current state of the tree.
				cv$currentValue = cv$originalValue;
			else {
				cv$currentValue = cv$proposedValue;
				
				// Update Sample and intermediate values
				{
					// Write out the value of the sample to a temporary variable prior to updating the
					// intermediate variables.
					double var75 = cv$proposedValue;
					pageFaultsMean[var74] = cv$currentValue;
				}
			}
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double cv$temp$0$var68;
				{
					cv$temp$0$var68 = 814.0;
				}
				double cv$temp$1$var69;
				{
					cv$temp$1$var69 = 335550.0;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cv$currentValue - cv$temp$0$var68) / Math.sqrt(cv$temp$1$var69))) - (0.5 * Math.log(cv$temp$1$var69))));
				
				// Processing random variable 123.
				{
					// Looking for a path between Sample 80 and consumer Gaussian 123.
					{
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample35) {
								if((0 == i$var109)) {
									double traceTempVariable$var121$7_1 = cv$currentValue;
									if((var74 == st[i$var109])) {
										// Processing sample task 129 of consumer random variable null.
										{
											// Set an accumulator to sum the probabilities for each possible configuration of
											// inputs.
											double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
											
											// Set an accumulator to record the consumer distributions not seen. Initially set
											// to 1 as seen values will be deducted from this value.
											double cv$consumerDistributionProbabilityAccumulator = 1.0;
											{
												// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
												// the output of Sample task 80.
												if((0 == i$var109)) {
													for(int var104 = 0; var104 < noStates; var104 += 1) {
														if((var104 == st[i$var109])) {
															{
																{
																	double cv$temp$2$var121;
																	{
																		// Constructing a random variable input for use later.
																		double var121 = traceTempVariable$var121$7_1;
																		cv$temp$2$var121 = var121;
																	}
																	double cv$temp$3$var122;
																	{
																		// Constructing a random variable input for use later.
																		double var122 = pageFaultsVar[st[i$var109]];
																		cv$temp$3$var122 = var122;
																	}
																	
																	// Record the probability of sample task 129 generating output with current configuration.
																	if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))) < cv$accumulatedConsumerProbabilities))
																		cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																	else {
																		// If the second value is -infinity.
																		if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																			cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122))));
																		else
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$2$var121) / Math.sqrt(cv$temp$3$var122))) - (0.5 * Math.log(cv$temp$3$var122)))));
																	}
																	
																	// Recorded the probability of reaching sample task 129 with the current configuration.
																	cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																}
															}
														}
													}
												}
												
												// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
												// the output of Sample task 80.
												if(fixedFlag$sample45) {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if((i$var34 == i$var109)) {
															for(int var104 = 0; var104 < noStates; var104 += 1) {
																if((var104 == st[i$var109])) {
																	{
																		{
																			double cv$temp$4$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = traceTempVariable$var121$7_1;
																				cv$temp$4$var121 = var121;
																			}
																			double cv$temp$5$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = pageFaultsVar[st[i$var109]];
																				cv$temp$5$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$4$var121) / Math.sqrt(cv$temp$5$var122))) - (0.5 * Math.log(cv$temp$5$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												} else {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if(true) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$26 = 0; index$sample45$26 < noStates; index$sample45$26 += 1) {
																int distributionTempVariable$var40$28 = index$sample45$26;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value27 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$26]);
																int traceTempVariable$s$29_1 = distributionTempVariable$var40$28;
																if((i$var34 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$6$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = traceTempVariable$var121$7_1;
																						cv$temp$6$var121 = var121;
																					}
																					double cv$temp$7$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$29_1];
																						cv$temp$7$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$6$var121) / Math.sqrt(cv$temp$7$var122))) - (0.5 * Math.log(cv$temp$7$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value27);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// A check to ensure rounding of floating point values can never result in a negative
											// value.
											cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
											
											// Multiply (log space add) in the probability of the sample task to the overall probability
											// for this configuration of the source random variable.
											if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
												cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
											else {
												// If the second value is -infinity.
												if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
													cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
												else
													cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
											}
										}
									}
								}
							} else {
								if(true) {
									// Enumerating the possible outputs of Categorical 29.
									for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
										int distributionTempVariable$var30$5 = index$sample35$3;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
										int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
										if((0 == i$var109)) {
											double traceTempVariable$var121$8_1 = cv$currentValue;
											if((var74 == traceTempVariable$s$6_1)) {
												// Processing sample task 129 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 80.
														int traceTempVariable$s$32_1 = distributionTempVariable$var30$5;
														if((0 == i$var109)) {
															for(int var104 = 0; var104 < noStates; var104 += 1) {
																if((var104 == traceTempVariable$s$32_1)) {
																	{
																		{
																			double cv$temp$8$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = traceTempVariable$var121$8_1;
																				cv$temp$8$var121 = var121;
																			}
																			double cv$temp$9$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = pageFaultsVar[traceTempVariable$s$32_1];
																				cv$temp$9$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$8$var121) / Math.sqrt(cv$temp$9$var122))) - (0.5 * Math.log(cv$temp$9$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																		}
																	}
																}
															}
														}
														if(!true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$33 = 0; index$sample35$33 < noStates; index$sample35$33 += 1) {
																int distributionTempVariable$var30$35 = index$sample35$33;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value34 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$33]);
																int traceTempVariable$s$36_1 = distributionTempVariable$var30$35;
																if((0 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$36_1)) {
																			{
																				{
																					double cv$temp$10$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = traceTempVariable$var121$8_1;
																						cv$temp$10$var121 = var121;
																					}
																					double cv$temp$11$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$36_1];
																						cv$temp$11$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$10$var121) / Math.sqrt(cv$temp$11$var122))) - (0.5 * Math.log(cv$temp$11$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value34);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
														// the output of Sample task 80.
														if(fixedFlag$sample45) {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if((i$var34 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$6_1)) {
																			{
																				{
																					double cv$temp$12$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = traceTempVariable$var121$8_1;
																						cv$temp$12$var121 = var121;
																					}
																					double cv$temp$13$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$6_1];
																						cv$temp$13$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$12$var121) / Math.sqrt(cv$temp$13$var122))) - (0.5 * Math.log(cv$temp$13$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																				}
																			}
																		}
																	}
																}
															}
														} else {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if(true) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
																		int distributionTempVariable$var40$43 = index$sample45$41;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value42 = (cv$probabilitySample35Value4 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$41]);
																		int traceTempVariable$s$44_1 = distributionTempVariable$var40$43;
																		if((i$var34 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$44_1)) {
																					{
																						{
																							double cv$temp$14$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = traceTempVariable$var121$8_1;
																								cv$temp$14$var121 = var121;
																							}
																							double cv$temp$15$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$44_1];
																								cv$temp$15$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$14$var121) / Math.sqrt(cv$temp$15$var122))) - (0.5 * Math.log(cv$temp$15$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value42);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample45) {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if((i$var34 == i$var109)) {
										double traceTempVariable$var121$16_1 = cv$currentValue;
										if((var74 == st[i$var109])) {
											// Processing sample task 129 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 80.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var104 = 0; var104 < noStates; var104 += 1) {
																if((var104 == st[i$var109])) {
																	{
																		{
																			double cv$temp$16$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = traceTempVariable$var121$16_1;
																				cv$temp$16$var121 = var121;
																			}
																			double cv$temp$17$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = pageFaultsVar[st[i$var109]];
																				cv$temp$17$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$16$var121) / Math.sqrt(cv$temp$17$var122))) - (0.5 * Math.log(cv$temp$17$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$48 = 0; index$sample35$48 < noStates; index$sample35$48 += 1) {
																int distributionTempVariable$var30$50 = index$sample35$48;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value49 = (1.0 * distribution$sample35[index$sample35$48]);
																int traceTempVariable$s$51_1 = distributionTempVariable$var30$50;
																if((0 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$51_1)) {
																			{
																				{
																					double cv$temp$18$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = traceTempVariable$var121$16_1;
																						cv$temp$18$var121 = var121;
																					}
																					double cv$temp$19$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$51_1];
																						cv$temp$19$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$18$var121) / Math.sqrt(cv$temp$19$var122))) - (0.5 * Math.log(cv$temp$19$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value49);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
													// the output of Sample task 80.
													for(int index$i$54_1 = 1; index$i$54_1 < samples; index$i$54_1 += 1) {
														if((index$i$54_1 == i$var109)) {
															for(int var104 = 0; var104 < noStates; var104 += 1) {
																if((var104 == st[i$var109])) {
																	{
																		{
																			double cv$temp$20$var121;
																			{
																				// Constructing a random variable input for use later.
																				double var121 = traceTempVariable$var121$16_1;
																				cv$temp$20$var121 = var121;
																			}
																			double cv$temp$21$var122;
																			{
																				// Constructing a random variable input for use later.
																				double var122 = pageFaultsVar[st[i$var109]];
																				cv$temp$21$var122 = var122;
																			}
																			
																			// Record the probability of sample task 129 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$20$var121) / Math.sqrt(cv$temp$21$var122))) - (0.5 * Math.log(cv$temp$21$var122)))));
																			}
																			
																			// Recorded the probability of reaching sample task 129 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							} else {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if(true) {
										// Enumerating the possible outputs of Categorical 39.
										for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
											int distributionTempVariable$var40$14 = index$sample45$12;
											
											// Update the probability of sampling this value from the distribution value.
											double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$12]);
											int traceTempVariable$s$15_1 = distributionTempVariable$var40$14;
											if((i$var34 == i$var109)) {
												double traceTempVariable$var121$17_1 = cv$currentValue;
												if((var74 == traceTempVariable$s$15_1)) {
													// Processing sample task 129 of consumer random variable null.
													{
														// Set an accumulator to sum the probabilities for each possible configuration of
														// inputs.
														double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
														
														// Set an accumulator to record the consumer distributions not seen. Initially set
														// to 1 as seen values will be deducted from this value.
														double cv$consumerDistributionProbabilityAccumulator = 1.0;
														{
															// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
															// the output of Sample task 80.
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var104 = 0; var104 < noStates; var104 += 1) {
																		if((var104 == traceTempVariable$s$15_1)) {
																			{
																				{
																					double cv$temp$22$var121;
																					{
																						// Constructing a random variable input for use later.
																						double var121 = traceTempVariable$var121$17_1;
																						cv$temp$22$var121 = var121;
																					}
																					double cv$temp$23$var122;
																					{
																						// Constructing a random variable input for use later.
																						double var122 = pageFaultsVar[traceTempVariable$s$15_1];
																						cv$temp$23$var122 = var122;
																					}
																					
																					// Record the probability of sample task 129 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$22$var121) / Math.sqrt(cv$temp$23$var122))) - (0.5 * Math.log(cv$temp$23$var122)))));
																					}
																					
																					// Recorded the probability of reaching sample task 129 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$57 = 0; index$sample35$57 < noStates; index$sample35$57 += 1) {
																		int distributionTempVariable$var30$59 = index$sample35$57;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value58 = (cv$probabilitySample45Value13 * distribution$sample35[index$sample35$57]);
																		int traceTempVariable$s$60_1 = distributionTempVariable$var30$59;
																		if((0 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$60_1)) {
																					{
																						{
																							double cv$temp$24$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = traceTempVariable$var121$17_1;
																								cv$temp$24$var121 = var121;
																							}
																							double cv$temp$25$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$60_1];
																								cv$temp$25$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))))) + 1)) + (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$24$var121) / Math.sqrt(cv$temp$25$var122))) - (0.5 * Math.log(cv$temp$25$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value58);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// Enumerating the possible arguments for the variable Gaussian 123 which is consuming
															// the output of Sample task 80.
															int traceTempVariable$s$63_1 = distributionTempVariable$var40$14;
															if((i$var34 == i$var109)) {
																for(int var104 = 0; var104 < noStates; var104 += 1) {
																	if((var104 == traceTempVariable$s$63_1)) {
																		{
																			{
																				double cv$temp$26$var121;
																				{
																					// Constructing a random variable input for use later.
																					double var121 = traceTempVariable$var121$17_1;
																					cv$temp$26$var121 = var121;
																				}
																				double cv$temp$27$var122;
																				{
																					// Constructing a random variable input for use later.
																					double var122 = pageFaultsVar[traceTempVariable$s$63_1];
																					cv$temp$27$var122 = var122;
																				}
																				
																				// Record the probability of sample task 129 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$26$var121) / Math.sqrt(cv$temp$27$var122))) - (0.5 * Math.log(cv$temp$27$var122)))));
																				}
																				
																				// Recorded the probability of reaching sample task 129 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																			}
																		}
																	}
																}
															}
															for(int index$i$64 = 1; index$i$64 < samples; index$i$64 += 1) {
																if(!(index$i$64 == i$var34)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$65 = 0; index$sample45$65 < noStates; index$sample45$65 += 1) {
																		int distributionTempVariable$var40$67 = index$sample45$65;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value66 = (cv$probabilitySample45Value13 * distribution$sample45[((index$i$64 - 1) / 1)][index$sample45$65]);
																		int traceTempVariable$s$68_1 = distributionTempVariable$var40$67;
																		if((index$i$64 == i$var109)) {
																			for(int var104 = 0; var104 < noStates; var104 += 1) {
																				if((var104 == traceTempVariable$s$68_1)) {
																					{
																						{
																							double cv$temp$28$var121;
																							{
																								// Constructing a random variable input for use later.
																								double var121 = traceTempVariable$var121$17_1;
																								cv$temp$28$var121 = var121;
																							}
																							double cv$temp$29$var122;
																							{
																								// Constructing a random variable input for use later.
																								double var122 = pageFaultsVar[traceTempVariable$s$68_1];
																								cv$temp$29$var122 = var122;
																							}
																							
																							// Record the probability of sample task 129 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))))) + 1)) + (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((pageFaults[i$var109] - cv$temp$28$var121) / Math.sqrt(cv$temp$29$var122))) - (0.5 * Math.log(cv$temp$29$var122)))));
																							}
																							
																							// Recorded the probability of reaching sample task 129 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value66);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// A check to ensure rounding of floating point values can never result in a negative
														// value.
														cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
														
														// Multiply (log space add) in the probability of the sample task to the overall probability
														// for this configuration of the source random variable.
														if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
															cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
														else {
															// If the second value is -infinity.
															if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
															else
																cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Save the probability of the original value.
			if((cv$valuePos == 0))
				cv$originalProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
			
			// Save the probability of the proposed value.
			else
				cv$proposedProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// The probability ration for the proposed value and the current value.
		double cv$ratio = (cv$proposedProbability - cv$originalProbability);
		
		// Test if the probability of the sample is sufficient to keep the value. This needs
		// to be less than or equal as otherwise if the proposed value is not possible and
		// the random value is 0 an impossible value will be accepted.
		if((((cv$proposedProbability - cv$originalProbability) <= Math.log((0.0 + ((1.0 - 0.0) * DistributionSampling.sampleUniform(RNG$))))) || Double.isNaN(cv$ratio))) {
			// If it is not revert the changes.
			// 
			// Set the sample value
			// Write out the value of the sample to a temporary variable prior to updating the
			// intermediate variables.
			double var75 = cv$originalValue;
			pageFaultsMean[var74] = var75;
		}
	}

	// Method to perform the inference steps to calculate new values for the samples generated
	// by sample task 90 drawn from InverseGamma 80. Inference was performed using Metropolis-Hastings.
	private final void sample90(int var84) {
		// The original value of the sample
		double cv$originalValue = cpuVar[var84];
		
		// The probability of the random variable generating the originally sampled value
		double cv$originalProbability = 0.0;
		
		// Calculate a proposed variance.
		double cv$var = ((cv$originalValue * cv$originalValue) * (0.1 * 0.1));
		
		// Ensure the variance is at least 0.01
		if((cv$var < (0.1 * 0.1)))
			cv$var = (0.1 * 0.1);
		
		// The proposed new value for the sample
		double cv$proposedValue = ((Math.sqrt(cv$var) * DistributionSampling.sampleGaussian(RNG$)) + cv$originalValue);
		
		// The probability of the random variable generating the new sample value.
		double cv$proposedProbability = 0.0;
		for(int cv$valuePos = 0; cv$valuePos < 2; cv$valuePos += 1) {
			// Initialize the summed probabilities to 0.
			double cv$stateProbabilityValue = Double.NEGATIVE_INFINITY;
			
			// Initialize a counter to track the reached distributions.
			double cv$reachedDistributionSourceRV = 0.0;
			
			// Initialize a log space accumulator to take the product of all the distribution
			// probabilities.
			double cv$accumulatedDistributionProbabilities = 0.0;
			
			// The value currently being tested
			double cv$currentValue;
			if((cv$valuePos == 0))
				// Set the current value to the current state of the tree.
				cv$currentValue = cv$originalValue;
			else {
				cv$currentValue = cv$proposedValue;
				
				// Update Sample and intermediate values
				{
					// Write out the value of the sample to a temporary variable prior to updating the
					// intermediate variables.
					double var85 = cv$proposedValue;
					cpuVar[var84] = cv$currentValue;
				}
			}
			{
				// Record the reached probability density.
				cv$reachedDistributionSourceRV = (cv$reachedDistributionSourceRV + 1.0);
				double cv$temp$0$var79;
				{
					cv$temp$0$var79 = 5.0;
				}
				double cv$temp$1$var78;
				{
					cv$temp$1$var78 = 0.5;
				}
				
				// An accumulator to allow the value for each distribution to be constructed before
				// it is added to the index probabilities.
				double cv$accumulatedProbabilities = (Math.log(1.0) + DistributionSampling.logProbabilityInverseGamma(cv$currentValue, cv$temp$0$var79, cv$temp$1$var78));
				
				// Processing random variable 113.
				{
					// Looking for a path between Sample 90 and consumer Gaussian 113.
					{
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample35) {
								if((0 == i$var109)) {
									double traceTempVariable$var112$7_1 = cv$currentValue;
									if((var84 == st[i$var109])) {
										// Processing sample task 119 of consumer random variable null.
										{
											// Set an accumulator to sum the probabilities for each possible configuration of
											// inputs.
											double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
											
											// Set an accumulator to record the consumer distributions not seen. Initially set
											// to 1 as seen values will be deducted from this value.
											double cv$consumerDistributionProbabilityAccumulator = 1.0;
											{
												// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
												// the output of Sample task 90.
												if((0 == i$var109)) {
													for(int var52 = 0; var52 < noStates; var52 += 1) {
														if((var52 == st[i$var109])) {
															{
																{
																	double cv$temp$2$var111;
																	{
																		// Constructing a random variable input for use later.
																		double var111 = cpuMean[st[i$var109]];
																		cv$temp$2$var111 = var111;
																	}
																	double cv$temp$3$var112;
																	{
																		// Constructing a random variable input for use later.
																		double var112 = traceTempVariable$var112$7_1;
																		cv$temp$3$var112 = var112;
																	}
																	
																	// Record the probability of sample task 119 generating output with current configuration.
																	if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))) < cv$accumulatedConsumerProbabilities))
																		cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																	else {
																		// If the second value is -infinity.
																		if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																			cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112))));
																		else
																			cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$2$var111) / Math.sqrt(cv$temp$3$var112))) - (0.5 * Math.log(cv$temp$3$var112)))));
																	}
																	
																	// Recorded the probability of reaching sample task 119 with the current configuration.
																	cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																}
															}
														}
													}
												}
												
												// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
												// the output of Sample task 90.
												if(fixedFlag$sample45) {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if((i$var34 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == st[i$var109])) {
																	{
																		{
																			double cv$temp$4$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = cpuMean[st[i$var109]];
																				cv$temp$4$var111 = var111;
																			}
																			double cv$temp$5$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = traceTempVariable$var112$7_1;
																				cv$temp$5$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$4$var111) / Math.sqrt(cv$temp$5$var112))) - (0.5 * Math.log(cv$temp$5$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												} else {
													for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
														if(true) {
															// Enumerating the possible outputs of Categorical 39.
															for(int index$sample45$26 = 0; index$sample45$26 < noStates; index$sample45$26 += 1) {
																int distributionTempVariable$var40$28 = index$sample45$26;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample45Value27 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$26]);
																int traceTempVariable$s$29_1 = distributionTempVariable$var40$28;
																if((i$var34 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$29_1)) {
																			{
																				{
																					double cv$temp$6$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$29_1];
																						cv$temp$6$var111 = var111;
																					}
																					double cv$temp$7$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = traceTempVariable$var112$7_1;
																						cv$temp$7$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value27) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$6$var111) / Math.sqrt(cv$temp$7$var112))) - (0.5 * Math.log(cv$temp$7$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value27);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											
											// A check to ensure rounding of floating point values can never result in a negative
											// value.
											cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
											
											// Multiply (log space add) in the probability of the sample task to the overall probability
											// for this configuration of the source random variable.
											if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
												cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
											else {
												// If the second value is -infinity.
												if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
													cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
												else
													cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
											}
										}
									}
								}
							} else {
								if(true) {
									// Enumerating the possible outputs of Categorical 29.
									for(int index$sample35$3 = 0; index$sample35$3 < noStates; index$sample35$3 += 1) {
										int distributionTempVariable$var30$5 = index$sample35$3;
										
										// Update the probability of sampling this value from the distribution value.
										double cv$probabilitySample35Value4 = (1.0 * distribution$sample35[index$sample35$3]);
										int traceTempVariable$s$6_1 = distributionTempVariable$var30$5;
										if((0 == i$var109)) {
											double traceTempVariable$var112$8_1 = cv$currentValue;
											if((var84 == traceTempVariable$s$6_1)) {
												// Processing sample task 119 of consumer random variable null.
												{
													// Set an accumulator to sum the probabilities for each possible configuration of
													// inputs.
													double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
													
													// Set an accumulator to record the consumer distributions not seen. Initially set
													// to 1 as seen values will be deducted from this value.
													double cv$consumerDistributionProbabilityAccumulator = 1.0;
													{
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 90.
														int traceTempVariable$s$32_1 = distributionTempVariable$var30$5;
														if((0 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == traceTempVariable$s$32_1)) {
																	{
																		{
																			double cv$temp$8$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = cpuMean[traceTempVariable$s$32_1];
																				cv$temp$8$var111 = var111;
																			}
																			double cv$temp$9$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = traceTempVariable$var112$8_1;
																				cv$temp$9$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$8$var111) / Math.sqrt(cv$temp$9$var112))) - (0.5 * Math.log(cv$temp$9$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																		}
																	}
																}
															}
														}
														if(!true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$33 = 0; index$sample35$33 < noStates; index$sample35$33 += 1) {
																int distributionTempVariable$var30$35 = index$sample35$33;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value34 = (cv$probabilitySample35Value4 * distribution$sample35[index$sample35$33]);
																int traceTempVariable$s$36_1 = distributionTempVariable$var30$35;
																if((0 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$36_1)) {
																			{
																				{
																					double cv$temp$10$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$36_1];
																						cv$temp$10$var111 = var111;
																					}
																					double cv$temp$11$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = traceTempVariable$var112$8_1;
																						cv$temp$11$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value34) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$10$var111) / Math.sqrt(cv$temp$11$var112))) - (0.5 * Math.log(cv$temp$11$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value34);
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
														// the output of Sample task 90.
														if(fixedFlag$sample45) {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if((i$var34 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$6_1)) {
																			{
																				{
																					double cv$temp$12$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$6_1];
																						cv$temp$12$var111 = var111;
																					}
																					double cv$temp$13$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = traceTempVariable$var112$8_1;
																						cv$temp$13$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value4) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$12$var111) / Math.sqrt(cv$temp$13$var112))) - (0.5 * Math.log(cv$temp$13$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value4);
																				}
																			}
																		}
																	}
																}
															}
														} else {
															for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
																if(true) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$41 = 0; index$sample45$41 < noStates; index$sample45$41 += 1) {
																		int distributionTempVariable$var40$43 = index$sample45$41;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value42 = (cv$probabilitySample35Value4 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$41]);
																		int traceTempVariable$s$44_1 = distributionTempVariable$var40$43;
																		if((i$var34 == i$var109)) {
																			for(int var52 = 0; var52 < noStates; var52 += 1) {
																				if((var52 == traceTempVariable$s$44_1)) {
																					{
																						{
																							double cv$temp$14$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$44_1];
																								cv$temp$14$var111 = var111;
																							}
																							double cv$temp$15$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = traceTempVariable$var112$8_1;
																								cv$temp$15$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value42) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$14$var111) / Math.sqrt(cv$temp$15$var112))) - (0.5 * Math.log(cv$temp$15$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value42);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// A check to ensure rounding of floating point values can never result in a negative
													// value.
													cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
													
													// Multiply (log space add) in the probability of the sample task to the overall probability
													// for this configuration of the source random variable.
													if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
														cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
													else {
														// If the second value is -infinity.
														if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
															cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
														else
															cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
													}
												}
											}
										}
									}
								}
							}
						}
						for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
							if(fixedFlag$sample45) {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if((i$var34 == i$var109)) {
										double traceTempVariable$var112$16_1 = cv$currentValue;
										if((var84 == st[i$var109])) {
											// Processing sample task 119 of consumer random variable null.
											{
												// Set an accumulator to sum the probabilities for each possible configuration of
												// inputs.
												double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
												
												// Set an accumulator to record the consumer distributions not seen. Initially set
												// to 1 as seen values will be deducted from this value.
												double cv$consumerDistributionProbabilityAccumulator = 1.0;
												{
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 90.
													if(fixedFlag$sample35) {
														if((0 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == st[i$var109])) {
																	{
																		{
																			double cv$temp$16$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = cpuMean[st[i$var109]];
																				cv$temp$16$var111 = var111;
																			}
																			double cv$temp$17$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = traceTempVariable$var112$16_1;
																				cv$temp$17$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$16$var111) / Math.sqrt(cv$temp$17$var112))) - (0.5 * Math.log(cv$temp$17$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													} else {
														if(true) {
															// Enumerating the possible outputs of Categorical 29.
															for(int index$sample35$48 = 0; index$sample35$48 < noStates; index$sample35$48 += 1) {
																int distributionTempVariable$var30$50 = index$sample35$48;
																
																// Update the probability of sampling this value from the distribution value.
																double cv$probabilitySample35Value49 = (1.0 * distribution$sample35[index$sample35$48]);
																int traceTempVariable$s$51_1 = distributionTempVariable$var30$50;
																if((0 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$51_1)) {
																			{
																				{
																					double cv$temp$18$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$51_1];
																						cv$temp$18$var111 = var111;
																					}
																					double cv$temp$19$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = traceTempVariable$var112$16_1;
																						cv$temp$19$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value49) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$18$var111) / Math.sqrt(cv$temp$19$var112))) - (0.5 * Math.log(cv$temp$19$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value49);
																				}
																			}
																		}
																	}
																}
															}
														}
													}
													
													// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
													// the output of Sample task 90.
													for(int index$i$54_1 = 1; index$i$54_1 < samples; index$i$54_1 += 1) {
														if((index$i$54_1 == i$var109)) {
															for(int var52 = 0; var52 < noStates; var52 += 1) {
																if((var52 == st[i$var109])) {
																	{
																		{
																			double cv$temp$20$var111;
																			{
																				// Constructing a random variable input for use later.
																				double var111 = cpuMean[st[i$var109]];
																				cv$temp$20$var111 = var111;
																			}
																			double cv$temp$21$var112;
																			{
																				// Constructing a random variable input for use later.
																				double var112 = traceTempVariable$var112$16_1;
																				cv$temp$21$var112 = var112;
																			}
																			
																			// Record the probability of sample task 119 generating output with current configuration.
																			if(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))) < cv$accumulatedConsumerProbabilities))
																				cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																			else {
																				// If the second value is -infinity.
																				if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																					cv$accumulatedConsumerProbabilities = (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112))));
																				else
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))))) + 1)) + (Math.log(1.0) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$20$var111) / Math.sqrt(cv$temp$21$var112))) - (0.5 * Math.log(cv$temp$21$var112)))));
																			}
																			
																			// Recorded the probability of reaching sample task 119 with the current configuration.
																			cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - 1.0);
																		}
																	}
																}
															}
														}
													}
												}
												
												// A check to ensure rounding of floating point values can never result in a negative
												// value.
												cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
												
												// Multiply (log space add) in the probability of the sample task to the overall probability
												// for this configuration of the source random variable.
												if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
													cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
												else {
													// If the second value is -infinity.
													if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
														cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
													else
														cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
												}
											}
										}
									}
								}
							} else {
								for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
									if(true) {
										// Enumerating the possible outputs of Categorical 39.
										for(int index$sample45$12 = 0; index$sample45$12 < noStates; index$sample45$12 += 1) {
											int distributionTempVariable$var40$14 = index$sample45$12;
											
											// Update the probability of sampling this value from the distribution value.
											double cv$probabilitySample45Value13 = (1.0 * distribution$sample45[((i$var34 - 1) / 1)][index$sample45$12]);
											int traceTempVariable$s$15_1 = distributionTempVariable$var40$14;
											if((i$var34 == i$var109)) {
												double traceTempVariable$var112$17_1 = cv$currentValue;
												if((var84 == traceTempVariable$s$15_1)) {
													// Processing sample task 119 of consumer random variable null.
													{
														// Set an accumulator to sum the probabilities for each possible configuration of
														// inputs.
														double cv$accumulatedConsumerProbabilities = Double.NEGATIVE_INFINITY;
														
														// Set an accumulator to record the consumer distributions not seen. Initially set
														// to 1 as seen values will be deducted from this value.
														double cv$consumerDistributionProbabilityAccumulator = 1.0;
														{
															// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
															// the output of Sample task 90.
															if(fixedFlag$sample35) {
																if((0 == i$var109)) {
																	for(int var52 = 0; var52 < noStates; var52 += 1) {
																		if((var52 == traceTempVariable$s$15_1)) {
																			{
																				{
																					double cv$temp$22$var111;
																					{
																						// Constructing a random variable input for use later.
																						double var111 = cpuMean[traceTempVariable$s$15_1];
																						cv$temp$22$var111 = var111;
																					}
																					double cv$temp$23$var112;
																					{
																						// Constructing a random variable input for use later.
																						double var112 = traceTempVariable$var112$17_1;
																						cv$temp$23$var112 = var112;
																					}
																					
																					// Record the probability of sample task 119 generating output with current configuration.
																					if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))) < cv$accumulatedConsumerProbabilities))
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																					else {
																						// If the second value is -infinity.
																						if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																							cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112))));
																						else
																							cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$22$var111) / Math.sqrt(cv$temp$23$var112))) - (0.5 * Math.log(cv$temp$23$var112)))));
																					}
																					
																					// Recorded the probability of reaching sample task 119 with the current configuration.
																					cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																				}
																			}
																		}
																	}
																}
															} else {
																if(true) {
																	// Enumerating the possible outputs of Categorical 29.
																	for(int index$sample35$57 = 0; index$sample35$57 < noStates; index$sample35$57 += 1) {
																		int distributionTempVariable$var30$59 = index$sample35$57;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample35Value58 = (cv$probabilitySample45Value13 * distribution$sample35[index$sample35$57]);
																		int traceTempVariable$s$60_1 = distributionTempVariable$var30$59;
																		if((0 == i$var109)) {
																			for(int var52 = 0; var52 < noStates; var52 += 1) {
																				if((var52 == traceTempVariable$s$60_1)) {
																					{
																						{
																							double cv$temp$24$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$60_1];
																								cv$temp$24$var111 = var111;
																							}
																							double cv$temp$25$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = traceTempVariable$var112$17_1;
																								cv$temp$25$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))))) + 1)) + (Math.log(cv$probabilitySample35Value58) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$24$var111) / Math.sqrt(cv$temp$25$var112))) - (0.5 * Math.log(cv$temp$25$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample35Value58);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
															
															// Enumerating the possible arguments for the variable Gaussian 113 which is consuming
															// the output of Sample task 90.
															int traceTempVariable$s$63_1 = distributionTempVariable$var40$14;
															if((i$var34 == i$var109)) {
																for(int var52 = 0; var52 < noStates; var52 += 1) {
																	if((var52 == traceTempVariable$s$63_1)) {
																		{
																			{
																				double cv$temp$26$var111;
																				{
																					// Constructing a random variable input for use later.
																					double var111 = cpuMean[traceTempVariable$s$63_1];
																					cv$temp$26$var111 = var111;
																				}
																				double cv$temp$27$var112;
																				{
																					// Constructing a random variable input for use later.
																					double var112 = traceTempVariable$var112$17_1;
																					cv$temp$27$var112 = var112;
																				}
																				
																				// Record the probability of sample task 119 generating output with current configuration.
																				if(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))) < cv$accumulatedConsumerProbabilities))
																					cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																				else {
																					// If the second value is -infinity.
																					if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																						cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112))));
																					else
																						cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value13) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$26$var111) / Math.sqrt(cv$temp$27$var112))) - (0.5 * Math.log(cv$temp$27$var112)))));
																				}
																				
																				// Recorded the probability of reaching sample task 119 with the current configuration.
																				cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value13);
																			}
																		}
																	}
																}
															}
															for(int index$i$64 = 1; index$i$64 < samples; index$i$64 += 1) {
																if(!(index$i$64 == i$var34)) {
																	// Enumerating the possible outputs of Categorical 39.
																	for(int index$sample45$65 = 0; index$sample45$65 < noStates; index$sample45$65 += 1) {
																		int distributionTempVariable$var40$67 = index$sample45$65;
																		
																		// Update the probability of sampling this value from the distribution value.
																		double cv$probabilitySample45Value66 = (cv$probabilitySample45Value13 * distribution$sample45[((index$i$64 - 1) / 1)][index$sample45$65]);
																		int traceTempVariable$s$68_1 = distributionTempVariable$var40$67;
																		if((index$i$64 == i$var109)) {
																			for(int var52 = 0; var52 < noStates; var52 += 1) {
																				if((var52 == traceTempVariable$s$68_1)) {
																					{
																						{
																							double cv$temp$28$var111;
																							{
																								// Constructing a random variable input for use later.
																								double var111 = cpuMean[traceTempVariable$s$68_1];
																								cv$temp$28$var111 = var111;
																							}
																							double cv$temp$29$var112;
																							{
																								// Constructing a random variable input for use later.
																								double var112 = traceTempVariable$var112$17_1;
																								cv$temp$29$var112 = var112;
																							}
																							
																							// Record the probability of sample task 119 generating output with current configuration.
																							if(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))) < cv$accumulatedConsumerProbabilities))
																								cv$accumulatedConsumerProbabilities = (Math.log((Math.exp(((Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities);
																							else {
																								// If the second value is -infinity.
																								if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																									cv$accumulatedConsumerProbabilities = (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112))));
																								else
																									cv$accumulatedConsumerProbabilities = (Math.log((Math.exp((cv$accumulatedConsumerProbabilities - (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))))) + 1)) + (Math.log(cv$probabilitySample45Value66) + (DistributionSampling.logProbabilityGaussian(((cpu[i$var109] - cv$temp$28$var111) / Math.sqrt(cv$temp$29$var112))) - (0.5 * Math.log(cv$temp$29$var112)))));
																							}
																							
																							// Recorded the probability of reaching sample task 119 with the current configuration.
																							cv$consumerDistributionProbabilityAccumulator = (cv$consumerDistributionProbabilityAccumulator - cv$probabilitySample45Value66);
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														
														// A check to ensure rounding of floating point values can never result in a negative
														// value.
														cv$consumerDistributionProbabilityAccumulator = Math.max(cv$consumerDistributionProbabilityAccumulator, 0.0);
														
														// Multiply (log space add) in the probability of the sample task to the overall probability
														// for this configuration of the source random variable.
														if((Math.log(cv$consumerDistributionProbabilityAccumulator) < cv$accumulatedConsumerProbabilities))
															cv$accumulatedProbabilities = ((Math.log((Math.exp((Math.log(cv$consumerDistributionProbabilityAccumulator) - cv$accumulatedConsumerProbabilities)) + 1)) + cv$accumulatedConsumerProbabilities) + cv$accumulatedProbabilities);
														else {
															// If the second value is -infinity.
															if((cv$accumulatedConsumerProbabilities == Double.NEGATIVE_INFINITY))
																cv$accumulatedProbabilities = (Math.log(cv$consumerDistributionProbabilityAccumulator) + cv$accumulatedProbabilities);
															else
																cv$accumulatedProbabilities = ((Math.log((Math.exp((cv$accumulatedConsumerProbabilities - Math.log(cv$consumerDistributionProbabilityAccumulator))) + 1)) + Math.log(cv$consumerDistributionProbabilityAccumulator)) + cv$accumulatedProbabilities);
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				
				// Add the values for the source and any standard consumers for this configuration
				// of arguments to the source.
				if((cv$accumulatedProbabilities < cv$stateProbabilityValue))
					cv$stateProbabilityValue = (Math.log((Math.exp((cv$accumulatedProbabilities - cv$stateProbabilityValue)) + 1)) + cv$stateProbabilityValue);
				else {
					// If the second value is -infinity.
					if((cv$stateProbabilityValue == Double.NEGATIVE_INFINITY))
						cv$stateProbabilityValue = cv$accumulatedProbabilities;
					else
						cv$stateProbabilityValue = (Math.log((Math.exp((cv$stateProbabilityValue - cv$accumulatedProbabilities)) + 1)) + cv$accumulatedProbabilities);
				}
			}
			
			// Save the probability of the original value.
			if((cv$valuePos == 0))
				cv$originalProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
			
			// Save the probability of the proposed value.
			else
				cv$proposedProbability = ((cv$stateProbabilityValue - Math.log(cv$reachedDistributionSourceRV)) + cv$accumulatedDistributionProbabilities);
		}
		
		// The probability ration for the proposed value and the current value.
		double cv$ratio = (cv$proposedProbability - cv$originalProbability);
		
		// Test if the probability of the sample is sufficient to keep the value. This needs
		// to be less than or equal as otherwise if the proposed value is not possible and
		// the random value is 0 an impossible value will be accepted.
		if((((cv$proposedProbability - cv$originalProbability) <= Math.log((0.0 + ((1.0 - 0.0) * DistributionSampling.sampleUniform(RNG$))))) || Double.isNaN(cv$ratio))) {
			// If it is not revert the changes.
			// 
			// Set the sample value
			// Write out the value of the sample to a temporary variable prior to updating the
			// intermediate variables.
			double var85 = cv$originalValue;
			cpuVar[var84] = var85;
		}
	}

	// Method to allocate space temporary variables used by the inference methods. Allocating
	// here prevents repeated allocation and deallocation, and makes the code more amenable
	// to GPU execution.
	@Override
	public final void allocateScratch() {
		// Allocate scratch space.
		// Constructor for cv$var22$countGlobal
		{
			// Calculate the longest array this random variable could produce and allocate an
			// array large enough to handle this.
			int cv$max = 0;
			for(int var21 = 0; var21 < noStates; var21 += 1)
				cv$max = Math.max(cv$max, noStates);
			
			// Allocation of cv$var22$countGlobal for single threaded execution
			cv$var22$countGlobal = new double[cv$max];
		}
		
		// Constructor for cv$var27$countGlobal
		{
			// Calculate the longest array this random variable could produce and allocate an
			// array large enough to handle this.
			int cv$max = 0;
			cv$max = Math.max(cv$max, noStates);
			
			// Allocation of cv$var27$countGlobal for single threaded execution
			cv$var27$countGlobal = new double[cv$max];
		}
		
		// Constructor for cv$distributionAccumulator$var39
		{
			// Variable to record the maximum value of Task Get 43. Initially set to the value
			// of putTask 26.
			int cv$var23$max = noStates;
			
			// Allocation of cv$distributionAccumulator$var39 for single threaded execution
			cv$distributionAccumulator$var39 = new double[cv$var23$max];
		}
		
		// Constructor for cv$var30$stateProbabilityGlobal
		{
			// Allocation of cv$var30$stateProbabilityGlobal for single threaded execution
			cv$var30$stateProbabilityGlobal = new double[noStates];
		}
		
		// Constructor for guard$sample35gaussian118$global
		{
			// Calculate the largest index of i that is possible and allocate an array to hold
			// the guard for each of these.
			int cv$max_i$var109 = 0;
			cv$max_i$var109 = Math.max(cv$max_i$var109, ((length$cpu_measured - 0) / 1));
			
			// Allocation of guard$sample35gaussian118$global for single threaded execution
			guard$sample35gaussian118$global = new boolean[cv$max_i$var109];
		}
		
		// Constructor for guard$sample35gaussian123$global
		{
			// Calculate the largest index of i that is possible and allocate an array to hold
			// the guard for each of these.
			int cv$max_i$var109 = 0;
			cv$max_i$var109 = Math.max(cv$max_i$var109, ((length$cpu_measured - 0) / 1));
			
			// Allocation of guard$sample35gaussian123$global for single threaded execution
			guard$sample35gaussian123$global = new boolean[cv$max_i$var109];
		}
		
		// Constructor for guard$sample35gaussian128$global
		{
			// Calculate the largest index of i that is possible and allocate an array to hold
			// the guard for each of these.
			int cv$max_i$var109 = 0;
			cv$max_i$var109 = Math.max(cv$max_i$var109, ((length$cpu_measured - 0) / 1));
			
			// Allocation of guard$sample35gaussian128$global for single threaded execution
			guard$sample35gaussian128$global = new boolean[cv$max_i$var109];
		}
		
		// Constructor for cv$var40$stateProbabilityGlobal
		{
			// Variable to record the maximum value of Task Get 43. Initially set to the value
			// of putTask 26.
			int cv$var23$max = noStates;
			
			// Allocation of cv$var40$stateProbabilityGlobal for single threaded execution
			cv$var40$stateProbabilityGlobal = new double[cv$var23$max];
		}
		
		// Constructor for guard$sample45gaussian118$global
		{
			// Calculate the largest index of i that is possible and allocate an array to hold
			// the guard for each of these.
			int cv$max_i$var109 = 0;
			cv$max_i$var109 = Math.max(cv$max_i$var109, ((length$cpu_measured - 0) / 1));
			
			// Allocation of guard$sample45gaussian118$global for single threaded execution
			guard$sample45gaussian118$global = new boolean[cv$max_i$var109];
		}
		
		// Constructor for guard$sample45gaussian123$global
		{
			// Calculate the largest index of i that is possible and allocate an array to hold
			// the guard for each of these.
			int cv$max_i$var109 = 0;
			cv$max_i$var109 = Math.max(cv$max_i$var109, ((length$cpu_measured - 0) / 1));
			
			// Allocation of guard$sample45gaussian123$global for single threaded execution
			guard$sample45gaussian123$global = new boolean[cv$max_i$var109];
		}
		
		// Constructor for guard$sample45gaussian128$global
		{
			// Calculate the largest index of i that is possible and allocate an array to hold
			// the guard for each of these.
			int cv$max_i$var109 = 0;
			cv$max_i$var109 = Math.max(cv$max_i$var109, ((length$cpu_measured - 0) / 1));
			
			// Allocation of guard$sample45gaussian128$global for single threaded execution
			guard$sample45gaussian128$global = new boolean[cv$max_i$var109];
		}
	}

	// Method to allocate space for model inputs and outputs.
	@Override
	public final void allocator() {
		// Constructor for v
		{
			v = new double[noStates];
		}
		
		// If m has not been set already allocate space.
		if(!setFlag$m) {
			// Constructor for m
			{
				m = new double[noStates][];
				for(int var21 = 0; var21 < noStates; var21 += 1)
					m[var21] = new double[noStates];
			}
		}
		
		// If st has not been set already allocate space.
		if(!setFlag$st) {
			// Constructor for st
			{
				st = new int[length$cpu_measured];
			}
		}
		
		// If initialStateDistribution has not been set already allocate space.
		if(!setFlag$initialStateDistribution) {
			// Constructor for initialStateDistribution
			{
				initialStateDistribution = new double[noStates];
			}
		}
		
		// If cpu has not been set already allocate space.
		if(!setFlag$cpu) {
			// Constructor for cpu
			{
				cpu = new double[length$cpu_measured];
			}
		}
		
		// If mem has not been set already allocate space.
		if(!setFlag$mem) {
			// Constructor for mem
			{
				mem = new double[length$cpu_measured];
			}
		}
		
		// If pageFaults has not been set already allocate space.
		if(!setFlag$pageFaults) {
			// Constructor for pageFaults
			{
				pageFaults = new double[length$cpu_measured];
			}
		}
		
		// If cpuMean has not been set already allocate space.
		if(!setFlag$cpuMean) {
			// Constructor for cpuMean
			{
				cpuMean = new double[noStates];
			}
		}
		
		// If memMean has not been set already allocate space.
		if(!setFlag$memMean) {
			// Constructor for memMean
			{
				memMean = new double[noStates];
			}
		}
		
		// If pageFaultsMean has not been set already allocate space.
		if(!setFlag$pageFaultsMean) {
			// Constructor for pageFaultsMean
			{
				pageFaultsMean = new double[noStates];
			}
		}
		
		// If cpuVar has not been set already allocate space.
		if(!setFlag$cpuVar) {
			// Constructor for cpuVar
			{
				cpuVar = new double[noStates];
			}
		}
		
		// If memVar has not been set already allocate space.
		if(!setFlag$memVar) {
			// Constructor for memVar
			{
				memVar = new double[noStates];
			}
		}
		
		// If pageFaultsVar has not been set already allocate space.
		if(!setFlag$pageFaultsVar) {
			// Constructor for pageFaultsVar
			{
				pageFaultsVar = new double[noStates];
			}
		}
		
		// Constructor for distribution$sample35
		{
			distribution$sample35 = new double[noStates];
		}
		
		// Constructor for distribution$sample45
		{
			distribution$sample45 = new double[((((length$cpu_measured - 1) - 1) / 1) + 1)][];
			for(int i$var34 = 1; i$var34 < length$cpu_measured; i$var34 += 1)
				distribution$sample45[((i$var34 - 1) / 1)] = new double[noStates];
		}
		
		// Constructor for logProbability$var39
		{
			logProbability$var39 = new double[((((length$cpu_measured - 1) - 1) / 1) + 1)];
		}
		
		// Constructor for logProbability$sample45
		{
			logProbability$sample45 = new double[((((length$cpu_measured - 1) - 1) / 1) + 1)];
		}
		
		// Constructor for logProbability$var113
		{
			logProbability$var113 = new double[((((length$cpu_measured - 1) - 0) / 1) + 1)];
		}
		
		// Constructor for logProbability$sample119
		{
			logProbability$sample119 = new double[((((length$cpu_measured - 1) - 0) / 1) + 1)];
		}
		
		// Constructor for logProbability$var118
		{
			logProbability$var118 = new double[((((length$cpu_measured - 1) - 0) / 1) + 1)];
		}
		
		// Constructor for logProbability$sample124
		{
			logProbability$sample124 = new double[((((length$cpu_measured - 1) - 0) / 1) + 1)];
		}
		
		// Constructor for logProbability$var123
		{
			logProbability$var123 = new double[((((length$cpu_measured - 1) - 0) / 1) + 1)];
		}
		
		// Constructor for logProbability$sample129
		{
			logProbability$sample129 = new double[((((length$cpu_measured - 1) - 0) / 1) + 1)];
		}
		
		// Allocate scratch space
		allocateScratch();
	}

	// Method to execute the model code conventionally.
	@Override
	public final void forwardGeneration() {
		for(int var21 = 0; var21 < noStates; var21 += 1) {
			double[] var22 = m[var21];
			if(!fixedFlag$sample25)
				DistributionSampling.sampleDirichlet(RNG$, v, var22);
		}
		if(!fixedFlag$sample32)
			DistributionSampling.sampleDirichlet(RNG$, v, initialStateDistribution);
		if(!fixedFlag$sample35)
			st[0] = DistributionSampling.sampleCategorical(RNG$, initialStateDistribution);
		for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
			if(!fixedFlag$sample45)
				st[i$var34] = DistributionSampling.sampleCategorical(RNG$, m[st[(i$var34 - 1)]]);
		}
		for(int var52 = 0; var52 < noStates; var52 += 1) {
			if(!fixedFlag$sample58)
				cpuMean[var52] = ((Math.sqrt(8.6) * DistributionSampling.sampleGaussian(RNG$)) + 16.0);
		}
		for(int var63 = 0; var63 < noStates; var63 += 1) {
			if(!fixedFlag$sample69)
				memMean[var63] = ((Math.sqrt(1.0) * DistributionSampling.sampleGaussian(RNG$)) + 94.0);
		}
		for(int var74 = 0; var74 < noStates; var74 += 1) {
			if(!fixedFlag$sample80)
				pageFaultsMean[var74] = ((Math.sqrt(335550.0) * DistributionSampling.sampleGaussian(RNG$)) + 814.0);
		}
		for(int var84 = 0; var84 < noStates; var84 += 1) {
			if(!fixedFlag$sample90)
				cpuVar[var84] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var94 = 0; var94 < noStates; var94 += 1) {
			if(!fixedFlag$sample100)
				memVar[var94] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var104 = 0; var104 < noStates; var104 += 1) {
			if(!fixedFlag$sample110)
				pageFaultsVar[var104] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int i$var109 = 0; i$var109 < samples; i$var109 += 1) {
			if(!fixedFlag$sample119)
				cpu[i$var109] = ((Math.sqrt(cpuVar[st[i$var109]]) * DistributionSampling.sampleGaussian(RNG$)) + cpuMean[st[i$var109]]);
			if(!fixedFlag$sample124)
				mem[i$var109] = ((Math.sqrt(memVar[st[i$var109]]) * DistributionSampling.sampleGaussian(RNG$)) + memMean[st[i$var109]]);
			if(!fixedFlag$sample129)
				pageFaults[i$var109] = ((Math.sqrt(pageFaultsVar[st[i$var109]]) * DistributionSampling.sampleGaussian(RNG$)) + pageFaultsMean[st[i$var109]]);
		}
	}

	// Method to execute the model code conventionally, excluding the elements that generate
	// observed values. Distributions are calculated and stored.
	@Override
	public final void forwardGenerationDistributionsNoOutputs() {
		for(int var21 = 0; var21 < noStates; var21 += 1) {
			double[] var22 = m[var21];
			if(!fixedFlag$sample25)
				DistributionSampling.sampleDirichlet(RNG$, v, var22);
		}
		if(!fixedFlag$sample32)
			DistributionSampling.sampleDirichlet(RNG$, v, initialStateDistribution);
		
		// Create local copy of variable probabilities.
		double[] cv$distribution$sample35 = distribution$sample35;
		for(int index$var29 = 0; index$var29 < noStates; index$var29 += 1) {
			// Probability for this value
			double cv$value = (((0.0 <= index$var29) && (index$var29 < initialStateDistribution.length))?initialStateDistribution[index$var29]:0.0);
			if(!fixedFlag$sample35)
				// Save the probability of each value
				cv$distribution$sample35[index$var29] = cv$value;
		}
		for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
			// Create local copy of variable probabilities.
			double[] cv$distribution$sample45 = distribution$sample45[((i$var34 - 1) / 1)];
			for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1) {
				if(!fixedFlag$sample45)
					// Zero the probability of each value
					cv$distribution$sample45[index$var39] = 0.0;
			}
			
			// Iterate through possible values for var39's arguments.
			// 
			// Enumerating the possible arguments for Categorical 39.
			if(fixedFlag$sample35) {
				if((0 == (i$var34 - 1))) {
					for(int var21 = 0; var21 < noStates; var21 += 1) {
						if((var21 == st[(i$var34 - 1)])) {
							{
								if(!fixedFlag$sample45) {
									double[] var38 = m[st[(i$var34 - 1)]];
									for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1)
										// Save the probability of each value
										cv$distribution$sample45[index$var39] = (cv$distribution$sample45[index$var39] + (1.0 * (((0.0 <= index$var39) && (index$var39 < var38.length))?var38[index$var39]:0.0)));
								}
							}
						}
					}
				}
			} else {
				if(true) {
					// Enumerating the possible outputs of Categorical 29.
					for(int index$sample35$2 = 0; index$sample35$2 < noStates; index$sample35$2 += 1) {
						int distributionTempVariable$var30$4 = index$sample35$2;
						
						// Update the probability of sampling this value from the distribution value.
						double cv$probabilitySample35Value3 = (1.0 * distribution$sample35[index$sample35$2]);
						int traceTempVariable$var37$5_1 = distributionTempVariable$var30$4;
						if((0 == (i$var34 - 1))) {
							for(int var21 = 0; var21 < noStates; var21 += 1) {
								if((var21 == traceTempVariable$var37$5_1)) {
									{
										if(!fixedFlag$sample45) {
											double[] var38 = m[traceTempVariable$var37$5_1];
											for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1)
												// Save the probability of each value
												cv$distribution$sample45[index$var39] = (cv$distribution$sample45[index$var39] + (cv$probabilitySample35Value3 * (((0.0 <= index$var39) && (index$var39 < var38.length))?var38[index$var39]:0.0)));
										}
									}
								}
							}
						}
					}
				}
			}
			
			// Enumerating the possible arguments for Categorical 39.
			if(fixedFlag$sample45) {
				for(int index$i$8_1 = 1; index$i$8_1 < samples; index$i$8_1 += 1) {
					if((index$i$8_1 == (i$var34 - 1))) {
						for(int var21 = 0; var21 < noStates; var21 += 1) {
							if((var21 == st[(i$var34 - 1)])) {
								{
									if(!fixedFlag$sample45) {
										double[] var38 = m[st[(i$var34 - 1)]];
										for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1)
											// Save the probability of each value
											cv$distribution$sample45[index$var39] = (cv$distribution$sample45[index$var39] + (1.0 * (((0.0 <= index$var39) && (index$var39 < var38.length))?var38[index$var39]:0.0)));
									}
								}
							}
						}
					}
				}
			} else {
				for(int index$i$9 = 1; index$i$9 < samples; index$i$9 += 1) {
					if(true) {
						// Enumerating the possible outputs of Categorical 39.
						for(int index$sample45$10 = 0; index$sample45$10 < noStates; index$sample45$10 += 1) {
							int distributionTempVariable$var40$12 = index$sample45$10;
							
							// Update the probability of sampling this value from the distribution value.
							double cv$probabilitySample45Value11 = (1.0 * distribution$sample45[((index$i$9 - 1) / 1)][index$sample45$10]);
							int traceTempVariable$var37$13_1 = distributionTempVariable$var40$12;
							if((index$i$9 == (i$var34 - 1))) {
								for(int var21 = 0; var21 < noStates; var21 += 1) {
									if((var21 == traceTempVariable$var37$13_1)) {
										{
											if(!fixedFlag$sample45) {
												double[] var38 = m[traceTempVariable$var37$13_1];
												for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1)
													// Save the probability of each value
													cv$distribution$sample45[index$var39] = (cv$distribution$sample45[index$var39] + (cv$probabilitySample45Value11 * (((0.0 <= index$var39) && (index$var39 < var38.length))?var38[index$var39]:0.0)));
											}
										}
									}
								}
							}
						}
					}
				}
			}
			
			// Sum the values in the array
			double cv$var39$sum = 0.0;
			for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1) {
				if(!fixedFlag$sample45)
					// sum the probability of each value
					cv$var39$sum = (cv$var39$sum + cv$distribution$sample45[index$var39]);
			}
			for(int index$var39 = 0; index$var39 < noStates; index$var39 += 1) {
				if(!fixedFlag$sample45)
					// Normalise the probability of each value
					cv$distribution$sample45[index$var39] = (cv$distribution$sample45[index$var39] / cv$var39$sum);
			}
		}
		for(int var52 = 0; var52 < noStates; var52 += 1) {
			if(!fixedFlag$sample58)
				cpuMean[var52] = ((Math.sqrt(8.6) * DistributionSampling.sampleGaussian(RNG$)) + 16.0);
		}
		for(int var63 = 0; var63 < noStates; var63 += 1) {
			if(!fixedFlag$sample69)
				memMean[var63] = ((Math.sqrt(1.0) * DistributionSampling.sampleGaussian(RNG$)) + 94.0);
		}
		for(int var74 = 0; var74 < noStates; var74 += 1) {
			if(!fixedFlag$sample80)
				pageFaultsMean[var74] = ((Math.sqrt(335550.0) * DistributionSampling.sampleGaussian(RNG$)) + 814.0);
		}
		for(int var84 = 0; var84 < noStates; var84 += 1) {
			if(!fixedFlag$sample90)
				cpuVar[var84] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var94 = 0; var94 < noStates; var94 += 1) {
			if(!fixedFlag$sample100)
				memVar[var94] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var104 = 0; var104 < noStates; var104 += 1) {
			if(!fixedFlag$sample110)
				pageFaultsVar[var104] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
	}

	// Method to execute the model code conventionally, excluding the elements that generate
	// observed values. Distributions are collapsed to single values.
	@Override
	public final void forwardGenerationValuesNoOutputs() {
		for(int var21 = 0; var21 < noStates; var21 += 1) {
			double[] var22 = m[var21];
			if(!fixedFlag$sample25)
				DistributionSampling.sampleDirichlet(RNG$, v, var22);
		}
		if(!fixedFlag$sample32)
			DistributionSampling.sampleDirichlet(RNG$, v, initialStateDistribution);
		if(!fixedFlag$sample35)
			st[0] = DistributionSampling.sampleCategorical(RNG$, initialStateDistribution);
		for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
			if(!fixedFlag$sample45)
				st[i$var34] = DistributionSampling.sampleCategorical(RNG$, m[st[(i$var34 - 1)]]);
		}
		for(int var52 = 0; var52 < noStates; var52 += 1) {
			if(!fixedFlag$sample58)
				cpuMean[var52] = ((Math.sqrt(8.6) * DistributionSampling.sampleGaussian(RNG$)) + 16.0);
		}
		for(int var63 = 0; var63 < noStates; var63 += 1) {
			if(!fixedFlag$sample69)
				memMean[var63] = ((Math.sqrt(1.0) * DistributionSampling.sampleGaussian(RNG$)) + 94.0);
		}
		for(int var74 = 0; var74 < noStates; var74 += 1) {
			if(!fixedFlag$sample80)
				pageFaultsMean[var74] = ((Math.sqrt(335550.0) * DistributionSampling.sampleGaussian(RNG$)) + 814.0);
		}
		for(int var84 = 0; var84 < noStates; var84 += 1) {
			if(!fixedFlag$sample90)
				cpuVar[var84] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var94 = 0; var94 < noStates; var94 += 1) {
			if(!fixedFlag$sample100)
				memVar[var94] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var104 = 0; var104 < noStates; var104 += 1) {
			if(!fixedFlag$sample110)
				pageFaultsVar[var104] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
	}

	// Method to execute one round of Gibbs sampling.
	@Override
	public final void gibbsRound() {
		// Infer the samples in chronological order.
		if(system$gibbsForward) {
			for(int var21 = 0; var21 < noStates; var21 += 1) {
				if(!fixedFlag$sample25)
					sample25(var21);
			}
			if(!fixedFlag$sample32)
				sample32();
			if(!fixedFlag$sample35)
				sample35();
			for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
				if(!fixedFlag$sample45)
					sample45(i$var34);
			}
			for(int var52 = 0; var52 < noStates; var52 += 1) {
				if(!fixedFlag$sample58)
					sample58(var52);
			}
			for(int var63 = 0; var63 < noStates; var63 += 1) {
				if(!fixedFlag$sample69)
					sample69(var63);
			}
			for(int var74 = 0; var74 < noStates; var74 += 1) {
				if(!fixedFlag$sample80)
					sample80(var74);
			}
			for(int var84 = 0; var84 < noStates; var84 += 1) {
				if(!fixedFlag$sample90)
					sample90(var84);
			}
			for(int var94 = 0; var94 < noStates; var94 += 1) {
				if(!fixedFlag$sample100)
					sample100(var94);
			}
			for(int var104 = 0; var104 < noStates; var104 += 1) {
				if(!fixedFlag$sample110)
					sample110(var104);
			}
		}
		// Infer the samples in reverse chronological order.
		else {
			for(int var104 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var104 >= ((0 - 1) + 1); var104 -= 1) {
				if(!fixedFlag$sample110)
					sample110(var104);
			}
			for(int var94 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var94 >= ((0 - 1) + 1); var94 -= 1) {
				if(!fixedFlag$sample100)
					sample100(var94);
			}
			for(int var84 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var84 >= ((0 - 1) + 1); var84 -= 1) {
				if(!fixedFlag$sample90)
					sample90(var84);
			}
			for(int var74 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var74 >= ((0 - 1) + 1); var74 -= 1) {
				if(!fixedFlag$sample80)
					sample80(var74);
			}
			for(int var63 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var63 >= ((0 - 1) + 1); var63 -= 1) {
				if(!fixedFlag$sample69)
					sample69(var63);
			}
			for(int var52 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var52 >= ((0 - 1) + 1); var52 -= 1) {
				if(!fixedFlag$sample58)
					sample58(var52);
			}
			for(int i$var34 = (samples - ((((samples - 1) - 1) % 1) + 1)); i$var34 >= ((1 - 1) + 1); i$var34 -= 1) {
				if(!fixedFlag$sample45)
					sample45(i$var34);
			}
			if(!fixedFlag$sample35)
				sample35();
			if(!fixedFlag$sample32)
				sample32();
			for(int var21 = (noStates - ((((noStates - 1) - 0) % 1) + 1)); var21 >= ((0 - 1) + 1); var21 -= 1) {
				if(!fixedFlag$sample25)
					sample25(var21);
			}
		}
		
		// Reverse the direction of execution for the next iteration
		system$gibbsForward = !system$gibbsForward;
	}

	// Method for initialising the model into a valid state before commencing inference
	// etc.
	@Override
	public final void initializeConstants() {
		for(int var14 = 0; var14 < noStates; var14 += 1)
			v[var14] = 0.1;
		samples = length$cpu_measured;
	}

	// A method to initialize all the probabilities in the model to 0/Log(1) ready for
	// the current probabilities to be calculated by calculating the probability of each
	// sample task, and its effect on the rest of the model.
	private final void initializeLogProbabilityFields() {
		// Set the probabilities of the random variable, and the model as a whole to ready
		// them to be reconstructed by the probability calls for each sample. Sample probabilities
		// are only reset for samples that are not fixed at a value that has already been
		// calculated.
		logProbability$$model = 0.0;
		logProbability$$evidence = 0.0;
		logProbability$var17 = 0.0;
		logProbability$m = 0.0;
		if(!fixedProbFlag$sample25)
			logProbability$var22 = 0.0;
		logProbability$var26 = 0.0;
		if(!fixedProbFlag$sample32)
			logProbability$initialStateDistribution = 0.0;
		logProbability$var29 = 0.0;
		logProbability$st = 0.0;
		if(!fixedProbFlag$sample35)
			logProbability$var30 = 0.0;
		for(int i$var34 = 1; i$var34 < samples; i$var34 += 1)
			logProbability$var39[((i$var34 - 1) / 1)] = 0.0;
		if(!fixedProbFlag$sample45) {
			for(int i$var34 = 1; i$var34 < samples; i$var34 += 1)
				logProbability$sample45[((i$var34 - 1) / 1)] = 0.0;
		}
		logProbability$var48 = 0.0;
		logProbability$cpuMean = 0.0;
		if(!fixedProbFlag$sample58)
			logProbability$var53 = 0.0;
		logProbability$var59 = 0.0;
		logProbability$memMean = 0.0;
		if(!fixedProbFlag$sample69)
			logProbability$var64 = 0.0;
		logProbability$var70 = 0.0;
		logProbability$pageFaultsMean = 0.0;
		if(!fixedProbFlag$sample80)
			logProbability$var75 = 0.0;
		logProbability$var80 = 0.0;
		logProbability$cpuVar = 0.0;
		if(!fixedProbFlag$sample90)
			logProbability$var85 = 0.0;
		logProbability$var90 = 0.0;
		logProbability$memVar = 0.0;
		if(!fixedProbFlag$sample100)
			logProbability$var95 = 0.0;
		logProbability$var100 = 0.0;
		logProbability$pageFaultsVar = 0.0;
		if(!fixedProbFlag$sample110)
			logProbability$var105 = 0.0;
		for(int i$var109 = 0; i$var109 < samples; i$var109 += 1)
			logProbability$var113[((i$var109 - 0) / 1)] = 0.0;
		logProbability$cpu = 0.0;
		if(!fixedProbFlag$sample119) {
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1)
				logProbability$sample119[((i$var109 - 0) / 1)] = 0.0;
		}
		for(int i$var109 = 0; i$var109 < samples; i$var109 += 1)
			logProbability$var118[((i$var109 - 0) / 1)] = 0.0;
		logProbability$mem = 0.0;
		if(!fixedProbFlag$sample124) {
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1)
				logProbability$sample124[((i$var109 - 0) / 1)] = 0.0;
		}
		for(int i$var109 = 0; i$var109 < samples; i$var109 += 1)
			logProbability$var123[((i$var109 - 0) / 1)] = 0.0;
		logProbability$pageFaults = 0.0;
		if(!fixedProbFlag$sample129) {
			for(int i$var109 = 0; i$var109 < samples; i$var109 += 1)
				logProbability$sample129[((i$var109 - 0) / 1)] = 0.0;
		}
	}

	// Method to generate a new random state for the model excluding any fixed values
	// and then calculate its probability.
	@Override
	public final void logEvidenceGeneration() {
		// Generate values for all the samples in the model that were not fixed or observed.
		forwardGenerationValuesNoOutputs();
		
		// Calculate the probability for the resulting model.
		logEvidenceProbabilities();
	}

	// Construct the evidence probabilities.
	private final void logEvidenceProbabilities() {
		// Reset all the non-fixed probabilities ready to calculate the new values.
		initializeLogProbabilityFields();
		
		// Call each method in turn to generate the new probability values.
		if(fixedFlag$sample25)
			logProbabilityValue$sample25();
		if(fixedFlag$sample32)
			logProbabilityValue$sample32();
		if(fixedFlag$sample58)
			logProbabilityValue$sample58();
		if(fixedFlag$sample69)
			logProbabilityValue$sample69();
		if(fixedFlag$sample80)
			logProbabilityValue$sample80();
		if(fixedFlag$sample90)
			logProbabilityValue$sample90();
		if(fixedFlag$sample100)
			logProbabilityValue$sample100();
		if(fixedFlag$sample110)
			logProbabilityValue$sample110();
		logProbabilityValue$sample119();
		logProbabilityValue$sample124();
		logProbabilityValue$sample129();
	}

	// Method to calculate the probabilities of all the samples in the model including
	// those generating fixed data. In the process probabilities for all the random variables
	// and for the model as a whole will be calculated. This model uses distributions
	// when possible.
	@Override
	public final void logModelProbabilitiesDist() {
		// Reset all the non-fixed probabilities ready to calculate the new values.
		initializeLogProbabilityFields();
		
		// Calculate the probabilities for each sample task in the model, generating probabilities
		// for the random variables and whole model in the process using distributions where
		// appropriate.
		// 
		// Calculate the probabilities for each sample task in the model, generating probabilities
		// for the random variables and whole model in the process using values only.
		logProbabilityValue$sample25();
		logProbabilityValue$sample32();
		logProbabilityDistribution$sample35();
		logProbabilityDistribution$sample45();
		logProbabilityValue$sample58();
		logProbabilityValue$sample69();
		logProbabilityValue$sample80();
		logProbabilityValue$sample90();
		logProbabilityValue$sample100();
		logProbabilityValue$sample110();
		logProbabilityDistribution$sample119();
		logProbabilityDistribution$sample124();
		logProbabilityDistribution$sample129();
	}

	// Method to calculate the probabilities of all the samples in the model including
	// those generating fixed data. In the process probabilities for all the random variables
	// and for the model as a whole will be calculated. This model only uses values.
	@Override
	public final void logModelProbabilitiesVal() {
		// Reset all the non-fixed probabilities ready to calculate the new values.
		initializeLogProbabilityFields();
		
		// Calculate the probabilities for each sample task in the model, generating probabilities
		// for the random variables and whole model in the process using distributions where
		// appropriate.
		// 
		// Calculate the probabilities for each sample task in the model, generating probabilities
		// for the random variables and whole model in the process using values only.
		logProbabilityValue$sample25();
		logProbabilityValue$sample32();
		logProbabilityValue$sample35();
		logProbabilityValue$sample45();
		logProbabilityValue$sample58();
		logProbabilityValue$sample69();
		logProbabilityValue$sample80();
		logProbabilityValue$sample90();
		logProbabilityValue$sample100();
		logProbabilityValue$sample110();
		logProbabilityValue$sample119();
		logProbabilityValue$sample124();
		logProbabilityValue$sample129();
	}

	// Method to generate a random state of the model including random outputs, and then
	// to calculate the probability of this random state.
	@Override
	public final void logProbabilityGeneration() {
		// Generate sample values for every call to sample in the model.
		for(int var21 = 0; var21 < noStates; var21 += 1) {
			double[] var22 = m[var21];
			if(!fixedFlag$sample25)
				DistributionSampling.sampleDirichlet(RNG$, v, var22);
		}
		if(!fixedFlag$sample32)
			DistributionSampling.sampleDirichlet(RNG$, v, initialStateDistribution);
		if(!fixedFlag$sample35)
			st[0] = DistributionSampling.sampleCategorical(RNG$, initialStateDistribution);
		for(int i$var34 = 1; i$var34 < samples; i$var34 += 1) {
			if(!fixedFlag$sample45)
				st[i$var34] = DistributionSampling.sampleCategorical(RNG$, m[st[(i$var34 - 1)]]);
		}
		for(int var52 = 0; var52 < noStates; var52 += 1) {
			if(!fixedFlag$sample58)
				cpuMean[var52] = ((Math.sqrt(8.6) * DistributionSampling.sampleGaussian(RNG$)) + 16.0);
		}
		for(int var63 = 0; var63 < noStates; var63 += 1) {
			if(!fixedFlag$sample69)
				memMean[var63] = ((Math.sqrt(1.0) * DistributionSampling.sampleGaussian(RNG$)) + 94.0);
		}
		for(int var74 = 0; var74 < noStates; var74 += 1) {
			if(!fixedFlag$sample80)
				pageFaultsMean[var74] = ((Math.sqrt(335550.0) * DistributionSampling.sampleGaussian(RNG$)) + 814.0);
		}
		for(int var84 = 0; var84 < noStates; var84 += 1) {
			if(!fixedFlag$sample90)
				cpuVar[var84] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var94 = 0; var94 < noStates; var94 += 1) {
			if(!fixedFlag$sample100)
				memVar[var94] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		for(int var104 = 0; var104 < noStates; var104 += 1) {
			if(!fixedFlag$sample110)
				pageFaultsVar[var104] = DistributionSampling.sampleInverseGamma(RNG$, 5.0, 0.5);
		}
		
		// Calculate the probabilities for every sample task in the model. These values are
		// then used to calculate the probabilities of random variables and the model as a
		// whole.
		logModelProbabilitiesVal();
	}

	// Method to propagate observed values back into the model.
	@Override
	public final void propogateObservedValues() {
		{
			// Deep copy between arrays
			double[] cv$source1 = pageFaults_measured;
			double[] cv$target1 = pageFaults;
			int cv$length1 = cv$target1.length;
			for(int cv$index1 = 0; cv$index1 < cv$length1; cv$index1 += 1)
				cv$target1[cv$index1] = cv$source1[cv$index1];
		}
		{
			// Deep copy between arrays
			double[] cv$source1 = mem_measured;
			double[] cv$target1 = mem;
			int cv$length1 = cv$target1.length;
			for(int cv$index1 = 0; cv$index1 < cv$length1; cv$index1 += 1)
				cv$target1[cv$index1] = cv$source1[cv$index1];
		}
		{
			// Deep copy between arrays
			double[] cv$source1 = cpu_measured;
			double[] cv$target1 = cpu;
			int cv$length1 = cv$target1.length;
			for(int cv$index1 = 0; cv$index1 < cv$length1; cv$index1 += 1)
				cv$target1[cv$index1] = cv$source1[cv$index1];
		}
	}

	// A method to set array values that depend on the output of a sample task, but are
	// not directly set by the sample task.
	@Override
	public final void setIntermediates() {}

	@Override
	public String modelCode() {
		return "package org.sandwood.compiler.tests.parser;\n\nmodel HMMMetrics(double[] cpu_measured, double[] mem_measured, double[] pageFaults_measured, int noStates) {\n    \n    // Construct vectors describing the probability of a move from 1 state to another.\n    double[] v = new double[noStates] <~ 0.1;\n    double[][] m = dirichlet(v).sample(noStates);\n    \n    // Determine how many samples the model will need to produce.\n    int samples = cpu_measured.length;\n    \n    // Allocate space for the state.\n    int[] st = new int[samples];\n\n    // Set the initial state by sampling from a categorical with learnt weightings.\n    double[] initialStateDistribution = dirichlet(v).sample();\n    st[0] = categorical(initialStateDistribution).sampleDistribution();\n\n    //Determine the remaining states based on the previous state.\n    for(int i:[1 .. samples))\n        st[i] = categorical(m[st[i-1]]).sampleDistribution();\n        \n    //Generate each metric.\n    double[] cpu = new double[samples];\n    double[] mem = new double[samples];\n    double[] pageFaults = new double[samples];\n    \n    double[] cpuMean = gaussian(16, 8.6).sample(noStates);\n    double[] memMean = gaussian(94, 1).sample(noStates);\n    double[] pageFaultsMean = gaussian(814, 335550).sample(noStates);\n    \n    double[] cpuVar = inverseGamma(5, 0.5).sample(noStates);\n    double[] memVar = inverseGamma(5, 0.5).sample(noStates);\n    double[] pageFaultsVar = inverseGamma(5, 0.5).sample(noStates);\n    \n    for(int i:[0 .. samples)) {\n        int s = st[i];\n        cpu[i] = gaussian(cpuMean[s], cpuVar[s]).sample();\n        mem[i] = gaussian(memMean[s], memVar[s]).sample();\n        pageFaults[i] = gaussian(pageFaultsMean[s], pageFaultsVar[s]).sample();\n    }\n\n    //Tie the values to the values we have measured.\n    cpu.observe(cpu_measured);\n    mem.observe(mem_measured);\n    pageFaults.observe(pageFaults_measured);\n}\n";
	}
}