/*
 * Sandwood
 *
 * Copyright (c) 2019-2025, Oracle and/or its affiliates
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/
 */

package org.sandwood.compiler.traces.guards;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.Stack;

import org.sandwood.compiler.compilation.CompilationContext;
import org.sandwood.compiler.dataflowGraph.scopes.BlockScope;
import org.sandwood.compiler.dataflowGraph.scopes.ElseScope;
import org.sandwood.compiler.dataflowGraph.scopes.GlobalScope;
import org.sandwood.compiler.dataflowGraph.scopes.IfScope;
import org.sandwood.compiler.dataflowGraph.scopes.ReductionScope;
import org.sandwood.compiler.dataflowGraph.scopes.ReductionScopeCopied;
import org.sandwood.compiler.dataflowGraph.scopes.Scope;
import org.sandwood.compiler.dataflowGraph.scopes.Scope.ScopeType;
import org.sandwood.compiler.dataflowGraph.tasks.DFType;
import org.sandwood.compiler.dataflowGraph.tasks.DataflowTask;
import org.sandwood.compiler.dataflowGraph.tasks.arrayTasks.GetTask;
import org.sandwood.compiler.dataflowGraph.tasks.arrayTasks.PutTask;
import org.sandwood.compiler.dataflowGraph.tasks.sandwoodOperators.ForTask;
import org.sandwood.compiler.dataflowGraph.tasks.sandwoodOperators.IfElseAssignmentTask;
import org.sandwood.compiler.dataflowGraph.tasks.sandwoodOperators.ReductionInput;
import org.sandwood.compiler.dataflowGraph.tasks.sandwoodOperators.ReductionReturnTask;
import org.sandwood.compiler.dataflowGraph.variables.Variable;
import org.sandwood.compiler.dataflowGraph.variables.VariableDescription;
import org.sandwood.compiler.dataflowGraph.variables.auxillary.DataflowTaskArgDesc;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.BooleanVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.IntVariable;
import org.sandwood.compiler.exceptions.CompilerException;
import org.sandwood.compiler.exceptions.MissingFeatureException;
import org.sandwood.compiler.names.VariableNames;
import org.sandwood.compiler.traces.Trace;
import org.sandwood.compiler.traces.TraceHandle;
import org.sandwood.compiler.traces.guards.ScopeDescription.Substitutions;
import org.sandwood.compiler.trees.Tree;
import org.sandwood.compiler.trees.irTree.IRTree;
import org.sandwood.compiler.trees.irTree.IRTreeReturn;
import org.sandwood.compiler.trees.irTree.IRTreeVoid;

public class TraceArrayRestrictions {

    /**
     * Class to record the scopes that we should add and remove when we reach this dataflow task;
     */
    private static class ScopeChanges {
        /**
         * Set containing the scopes to construct.
         */
        private final Set<ForTask> toConstruct = new HashSet<>();

        /**
         * A set of for loops whose indexes are used by this task.
         */
        private final Set<ForTask> toUse = new HashSet<>();

        /**
         * A set of for loops that are already constructed for the end point of the trace and should be added to the
         * substitutions at this time, so that this and future tasks make use of them.
         */
        private final Set<ForTask> toSubstitute = new HashSet<>();

        public void addConstructLoops(Collection<ForTask> scopes) {
            toConstruct.addAll(scopes);
        }

        public void addUseScopes(Collection<ForTask> scopes) {
            toUse.addAll(scopes);
        }

        public Set<ForTask> getConstructScopes() {
            return toConstruct;
        }

        public Set<ForTask> getUsedScopes() {
            return toUse;
        }

        public Set<ForTask> getSubstituteScopes() {
            return toSubstitute;
        }

        @Override
        public String toString() {
            return "To Construct: " + toConstruct + "\nTo Use: " + toUse + "\n";
        }
    }

    private static class RestrictionsData {
        /**
         * A map from a dataflow task to the set of scopes that need to be duplicated to correctly handle this task.
         */
        final Map<DataflowTask<?>, ScopeChanges> scopeData = new HashMap<>();

        /**
         * A local id used to keep variable names distinct.
         */
        int localID = 1;

        /**
         * A global id to keep all the id's generated by this instance distinct from the id's generated by other
         * instances.
         */
        final int globalID;

        /**
         * A list of scopes to construct once the trace is constructed
         */
        final List<ForTask> finalLoops = new ArrayList<>();

        /**
         * A set containing all the put tasks that are paired.
         */
        final Map<PutTask<?>, DataflowTask<?>> usedPuts = new HashMap<>();

        /**
         * The trace that this restriction is for.
         */
        final TraceHandle trace;

        /**
         * The preconstructed scopes for the start of the trace
         */
        final Map<ForTask, IntVariable> existingStartScopes;

        /**
         * The preconstructed scopes for the end of the trace;
         */
        final Map<ForTask, IntVariable> existingEndLoops;

        /**
         * Set of all the scopes that have already been constructed, so if created again will have to be duplicates.
         * This exists purely to make the generated code easier to read, we could just make all new scopes duplicates.
         */
        final Set<ForTask> existingScopes;

        /**
         * A set to record all put tasks that substitutions should be saved at.
         */
        final Set<PutTask<?>> storeSubstitutions = new HashSet<>();

        /**
         * A map from dataflow task to the set of variables that should be created when that task is reached.
         */
        final Map<DataflowTask<?>, Set<Variable<?>>> requiredVariables = new HashMap<>();

        /**
         * Should values that are constructed in this trace be passed down the trace.
         */
        final boolean passValues;

        /**
         *
         * @param trace
         * @param existingStartScopes
         * @param existingEndScopes
         * @param existingScopes
         * @param globalID
         */

        public RestrictionsData(TraceHandle trace, Map<ForTask, IntVariable> existingStartScopes,
                Map<ForTask, IntVariable> existingEndScopes, Set<ForTask> existingScopes, int globalID,
                boolean passValues) {
            this.trace = trace;
            this.existingStartScopes = Collections.unmodifiableMap(existingStartScopes);
            this.existingEndLoops = Collections.unmodifiableMap(existingEndScopes);
            this.existingScopes = new HashSet<>(existingScopes);
            this.globalID = globalID;
            this.passValues = passValues;
        }
    }

    /**
     *
     * @param trace               The trace that the restrictions should be built for
     * @param existingStartScopes A Mapping from the set of scopes that are already constructed for the first element in
     *                            the trace to the scope and index value used to represent this. The key values are
     *                            always scopes from the DAG, but because multiple instances of each scope maybe
     *                            constructed as restrictions are instantiated the corresponding value pairs may not be
     *                            the original scope values.
     * @param existingEndScopes   A Mapping from the set of scopes that are already constructed for the last element in
     *                            the trace to the scope and index value used to represent this. The key values are
     *                            always scopes from the DAG, but because multiple instances of each scope maybe
     *                            constructed as restrictions are instantiated the corresponding value pairs may not be
     *                            the original scope values.
     * @param target              The distribution description to build these constraints within.
     * @param globalID            An id from which this method can construct unique ids to ensure there are no name
     *                            conflicts.
     * @param passValues          A flag to mark if sampled values should be passed through so that if the trace is
     *                            valid the value at the start of it is available at the end.
     * @param position            The position within the distribution description that any new substitutions should be
     *                            placed in.
     * @param compilationCtx      The compilation context that holds the details of the compilation.
     *
     * @return A new distribution description that represents the original distribution with the constraints of the
     *         trace added.
     */
    public static ScopeDescription constructRestriction(TraceHandle trace,
            Map<ForTask, IntVariable> existingStartScopes, Map<ForTask, IntVariable> existingEndScopes,
            ScopeDescription target, int globalID, boolean passValues, int position,
            CompilationContext compilationCtx) {
        Set<TraceHandle> rawTraces = new HashSet<>();
        rawTraces.add(trace);
        return constructRestriction(trace, rawTraces, existingStartScopes, existingEndScopes, target, globalID,
                passValues, position, compilationCtx);
    }

    public static ScopeDescription constructRestriction(TraceHandle trace, Set<TraceHandle> rawTraces,
            Map<ForTask, IntVariable> existingStartScopes, Map<ForTask, IntVariable> existingEndScopes,
            ScopeDescription target, int globalID, boolean passValues, int position,
            CompilationContext compilationCtx) {
        RestrictionsData data = new RestrictionsData(trace, existingStartScopes, existingEndScopes,
                target.existingScopes, globalID, passValues);

        constructOpPairs(data);

        for(TraceHandle t:rawTraces)
            getRequiredVariables(data, t);

        if(position != 0) // No trace is set for zero as this is the initial scope constructor.
            getSubstitutionPoints(data, target.getTrace(position));

        getScopeRequirements(data);

        return constructRestrictionInternal(data, target, position, compilationCtx);
    }

    /**
     * A method for calculating which put tasks should result in an update to the overall substitutions of the scope
     * description when setting substitutions for back traces. In short only put tasks that appeared as part of the
     * original trace should be used for this. TODO this will fail if the constraint trace is simplified and the source
     * trace is not. By construction this should not occur, but add a test to ensure that thus never occurs.
     *
     * @param data
     * @param h
     */
    private static void getSubstitutionPoints(RestrictionsData data, TraceHandle h) {
        Trace sourceTrace = h.getTrace();
        Trace constraintTrace = data.trace.getTrace();
        // Remove the first element as it will always be recorded at the end, so does
        // not
        // need to be recorded here.
        // Break if the traces have diverged.
        DataflowTaskArgDesc d = constraintTrace.pop();
        if(!d.equals(sourceTrace.pop()))
            return;

        while(!constraintTrace.isEmpty()) {
            d = constraintTrace.pop();
            switch(d.task.getType()) {
                case GET:
                case IF_ASSIGNMENT:
                case REDUCE_INPUT:
                    if(sourceTrace.isEmpty() || !d.equals(sourceTrace.pop()))
                        return;
                    break;
                case PUT:
                    if(sourceTrace.isEmpty())
                        return;
                    else {
                        DataflowTaskArgDesc sd = sourceTrace.pop();
                        if(!d.task.equals(sd.task))
                            return;
                        data.storeSubstitutions.add((PutTask<?>) d.task);
                        if(d.argPos != sd.argPos)
                            return;
                    }
                    break;
                default:
                    if(sourceTrace.isEmpty() && d.equals(sourceTrace.peek()))
                        sourceTrace.pop();
            }
        }
    }

    // A method to generate all the pairings of ops that need to have their indexes
    // compared.
    private static void constructOpPairs(RestrictionsData data) {
        // Get a copy of the trace.
        Trace trace = data.trace.getTrace();
        // Construct a stack that will hold all the gets that access elements from an
        // array on our trace.
        // The top element in this stack will always pair with a put when it is
        // encountered added an element
        // to an array.
        Stack<DataflowTask<?>> consumers = new Stack<>();
        // While there are elements left in the trace.
        while(!trace.isEmpty()) {
            // Get an element
            DataflowTaskArgDesc d = trace.pop();
            // Determine its type.
            switch(d.task.getType()) {
                // if it is a get and the array it is accessing is
                // in the trace push the get onto the stack.
                case GET:
                    if(d.argPos == 0)
                        consumers.push(d.task);
                    break;
                // If it is a put and the put is not just being passed by (argPos!=0)
                // recover the corresponding get, construct a pairing and populate the
                // scope data.
                case PUT:
                    assert (d.argPos != 0);
                    if(!consumers.isEmpty())
                        data.usedPuts.put((PutTask<?>) d.task, consumers.pop());
                    break;
                case REDUCE_INPUT:
                    consumers.push(d.task);
                    break;
                default:
                    break;
            }
        }
    }

    private static void getScopeRequirements(RestrictionsData data) {
        TraceHandle traceHandle = data.trace;

        int size = traceHandle.size();

        Set<ForTask> existingStartLoops = new HashSet<>(data.existingStartScopes.keySet());
        {
            Set<ForTask> existingPutLoops = new HashSet<>(existingStartLoops);
            Set<ForTask> existingGetLoops = new HashSet<>(existingStartLoops);

            for(int i = 0; i < size; i++) {
                DataflowTaskArgDesc d = traceHandle.get(i);
                switch(d.task.getType()) {
                    case GET: {
                        if(d.argPos == 0) {
                            GetTask<?> gt = (GetTask<?>) d.task;

                            // Construct an object to hold the scopes for this task and add it to the map
                            ScopeChanges s = new ScopeChanges();
                            data.scopeData.put(gt, s);

                            // Calculated the scopes used by this index.
                            Set<ForTask> indexLoops = getRequiredLoops(gt.index);
                            indexLoops.addAll(getGuardScopes(gt.scope()));

                            // Add the required scopes to set of used scopes
                            s.addUseScopes(indexLoops);

                            // Remove all the loops that are already constructed.
                            indexLoops.removeAll(existingGetLoops);
                            s.addConstructLoops(indexLoops);

                            // remove no longer available start scopes.
                            Set<ForTask> newStartLoops = new HashSet<>();
                            for(ForTask ft:existingStartLoops)
                                if(existingGetLoops.contains(ft))
                                    newStartLoops.add(ft);
                            existingStartLoops = newStartLoops;

                            // update the set of put loops removing any that are
                            // not in the scope of the array as these could have
                            // changed since the last put.
                            Set<ForTask> newPutLoops = new HashSet<>();
                            Scope vScope = gt.array.scope();
                            while(GlobalScope.scope != vScope) {
                                if(existingPutLoops.contains(vScope))
                                    newPutLoops.add((ForTask) vScope);
                                vScope = vScope.getEnclosingScope();
                            }
                            existingPutLoops = newPutLoops;

                            // Update the running state
                            existingGetLoops.addAll(indexLoops);
                            existingPutLoops.addAll(indexLoops);
                        }
                        break;
                    }
                    case REDUCE_INPUT: {
                        ReductionInput<?> ri = (ReductionInput<?>) d.task;

                        // Construct an object to hold the scopes for this task and add it to the map
                        ScopeChanges s = new ScopeChanges();
                        data.scopeData.put(ri, s);

                        // Calculated the scopes used by this input.
                        Set<ForTask> boundLoops = getRequiredLoops(ri.start);
                        boundLoops.addAll(getRequiredLoops(ri.end));
                        boundLoops.addAll(getGuardScopes(ri.scope()));

                        // Add the required scopes to set of used scopes
                        s.addUseScopes(boundLoops);

                        // Remove all the loops that are already constructed.
                        boundLoops.removeAll(existingGetLoops);
                        s.addConstructLoops(boundLoops);

                        // remove no longer available start scopes.
                        Set<ForTask> newStartLoops = new HashSet<>();
                        for(ForTask ft:existingStartLoops)
                            if(existingGetLoops.contains(ft))
                                newStartLoops.add(ft);
                        existingStartLoops = newStartLoops;

                        // update the set of put loops removing any that are
                        // not in the scope of the array as these could have
                        // changed since the last put.
                        Set<ForTask> newPutLoops = new HashSet<>();
                        Scope vScope = ri.array.scope();
                        while(GlobalScope.scope != vScope) {
                            if(existingPutLoops.contains(vScope))
                                newPutLoops.add((ForTask) vScope);
                            vScope = vScope.getEnclosingScope();
                        }
                        existingPutLoops = newPutLoops;

                        // Update the running state
                        existingGetLoops.addAll(boundLoops);
                        existingPutLoops.addAll(boundLoops);
                        break;
                    }

                    case PUT: {
                        assert (d.argPos != 0);
                        PutTask<?> pt = (PutTask<?>) d.task;

                        // Moving between scopes only happens with a put get/reduce pairing, if there is no
                        // corresponding get or reduce the trace cannot move between scopes.
                        // The value will be the get task for a get and null for a reduction.
                        DataflowTask<?> t = data.usedPuts.get(pt);
                        if(t != null) {
                            // Construct an object to hold the scopes for this task and add it to the map
                            ScopeChanges s = new ScopeChanges();
                            data.scopeData.put(pt, s);

                            // Calculated the scopes used by this index.
                            Set<ForTask> indexLoops = getRequiredLoops(pt.index);
                            indexLoops.addAll(getGuardScopes(pt.scope()));

                            Set<ForTask> valueLoops;
                            if(data.passValues && !pt.value.getType().isArray()) {
                                valueLoops = getRequiredLoops(pt.value);
                                valueLoops.removeAll(indexLoops);
                            } else
                                valueLoops = Collections.emptySet();

                            // Add the required scopes to set of used scopes
                            s.addUseScopes(indexLoops);
                            s.addUseScopes(valueLoops);

                            // Remove existing loops leaving only the loops that need to be constructed.
                            indexLoops.removeAll(existingPutLoops);
                            valueLoops.removeAll(existingPutLoops);

                            s.addConstructLoops(indexLoops);
                            s.addConstructLoops(valueLoops);
                            existingPutLoops.addAll(indexLoops);
                            existingPutLoops.addAll(valueLoops);

                            // Remove from the current get scopes set all the scopes
                            // that the array is visible in as these scopes could
                            // have changed.
                            //
                            // The put task has to include all the scopes
                            // that could be used by the get task as the only way to
                            // get data out of a loop is to place it in an array.
                            Scope scope = pt.array.scope();
                            Set<ForTask> newGetLoops = new HashSet<>();
                            while(GlobalScope.scope != scope) {
                                if(existingGetLoops.contains(scope) || valueLoops.contains(scope))
                                    newGetLoops.add((ForTask) scope);
                                scope = scope.getEnclosingScope();
                            }
                            existingGetLoops = newGetLoops;
                        }
                        break;
                    }
                    case IF_ASSIGNMENT: {
                        IfElseAssignmentTask<?> ifElseTask = (IfElseAssignmentTask<?>) d.task;
                        ScopeChanges s = new ScopeChanges();
                        data.scopeData.put(ifElseTask, s);

                        Set<ForTask> guardLoops = getRequiredLoops(ifElseTask.guard);
                        guardLoops.addAll(getGuardScopes(ifElseTask.scope()));
                        s.addUseScopes(guardLoops);

                        guardLoops.removeAll(existingPutLoops);
                        s.addConstructLoops(guardLoops);
                        existingPutLoops.addAll(guardLoops);
                        existingGetLoops.addAll(guardLoops);

                        break;
                    }
                    default:
                        break;
                }
            }
        }

        // If we are moving to the fixed scopes, not away from them, the trace needs to
        // be evaluated in reverse to exclude the fixed scopes.
        Set<ForTask> existingEndLoops = new HashSet<>(data.existingEndLoops.keySet());

        // Get the set of scopes that should be constructed by the end.
        Set<ForTask> constructEndLoops = new HashSet<>();
        if(!traceHandle.isEmpty()) {
            Scope s = traceHandle.peek().task.scope();
            while(s != null) {
                if(s.getScopeType() == ScopeType.FOR && !existingEndLoops.contains(s))
                    constructEndLoops.add((ForTask) s);
                s = s.getEnclosingScope();
            }
        }

        for(int i = size - 1; i >= 0; i--) {
            DataflowTaskArgDesc d = traceHandle.get(i);
            switch(d.task.getType()) {
                case GET:
                case IF_ASSIGNMENT:
                case REDUCE_INPUT: {
                    ScopeChanges s = data.scopeData.get(d.task);
                    if(s != null) {
                        // Remove from the construction and substitution any end scopes that
                        // have already been constructed.
                        for(ForTask t:existingEndLoops) {
                            if(s.toUse.contains(t)) {
                                s.toConstruct.remove(t);
                                s.toSubstitute.add(t);
                            }
                        }

                        // Remove constructed scopes from the set that need to be constructed.
                        constructEndLoops.removeAll(s.getConstructScopes());
                    }
                    break;
                }
                case PUT: {
                    assert (d.argPos != 0);
                    PutTask<?> pt = (PutTask<?>) d.task;
                    // Moving between scopes only happens with a put get pairing, if there is no
                    // corresponding get the trace cannot move between scopes.
                    if(data.usedPuts.containsKey(pt)) {
                        // Calculate all the loops that are now out of scope as they may have changed.
                        // In practice this is the same as used scopes up to vScope because of the
                        // constraints on put indexes.
                        Set<ForTask> outOfScopeLoops = new HashSet<>();
                        Scope vScope = pt.array.scope();
                        Scope ptScope = pt.scope();
                        while(ptScope != vScope) {
                            if(ptScope.getScopeType() == ScopeType.FOR)
                                outOfScopeLoops.add((ForTask) ptScope);
                            ptScope = ptScope.getEnclosingScope();
                        }

                        // Remove any scopes that are constructed but are not out of scope
                        ScopeChanges s = data.scopeData.get(d.task);
                        while(vScope != GlobalScope.scope) {
                            if(s.toConstruct.contains(vScope))
                                constructEndLoops.remove(vScope);
                            vScope = vScope.getEnclosingScope();
                        }

                        // Remove scopes that are used in an earlier iteration, as the
                        // value of the scope may have changed, so a new scope should
                        // now be created in the earlier steps.
                        existingEndLoops.removeAll(outOfScopeLoops);
                        // Versions of these scopes constructed after this point
                        // are not necessarily in the correct iteration, so duplicates
                        // need to be constructed, and this is where we mark this.
                        for(ForTask t:outOfScopeLoops) {
                            if(constructEndLoops.contains(t)) {
                                constructEndLoops.remove(t);
                                data.finalLoops.add(t);
                            }
                        }
                    }
                    break;
                }
                default:
                    break;
            }
        }

        // Construct any end scopes that have not been constructed already.
        constructEndLoops.removeAll(existingStartLoops);
        data.finalLoops.addAll(constructEndLoops);
        Collections.sort(data.finalLoops);
    }

    private static Set<ForTask> getGuardScopes(Scope scope) {
        Set<ForTask> toReturn = new HashSet<>();
        while(scope != GlobalScope.scope) {
            switch(scope.getScopeType()) {
                case ELSE: {
                    ElseScope elseScope = (ElseScope) scope;
                    toReturn.addAll(getRequiredLoops(elseScope.ifScope.guard));
                    break;
                }
                case IF: {
                    IfScope ifScope = (IfScope) scope;
                    toReturn.addAll(getRequiredLoops(ifScope.guard));
                    break;
                }
                default:
                    break;
            }
            scope = scope.getEnclosingScope();
        }
        return toReturn;
    }

    /**
     * A method to get the set of variables that are required to be generated for each from the trace for the correct
     * evaluation of either the put tasks, or the code inserted in to the finally created scope.
     * 
     * @param data        The restrictionData object into which the results should be stored.
     * @param traceHandle The trace to examine.
     */
    private static void getRequiredVariables(RestrictionsData data, TraceHandle traceHandle) {
        Set<Variable<?>> requiredVariables = new HashSet<>();

        int size = traceHandle.size();
        for(int i = 0; i < size; i++) {
            DataflowTaskArgDesc d = traceHandle.get(i);
            switch(d.task.getType()) {
                case GET:
                    break;

                case PUT: {
                    PutTask<?> pt = (PutTask<?>) d.task;
                    if(data.usedPuts.containsKey(pt)) { // Data is read again
                        Set<Variable<?>> s = data.requiredVariables.get(pt);
                        if(s == null) {
                            data.requiredVariables.put(pt, requiredVariables);
                            requiredVariables = new HashSet<>();
                        } else {
                            s.addAll(requiredVariables);
                            requiredVariables.clear();
                        }
                    }
                    break;
                }
                default: {
                    if(data.passValues) {
                        Variable<?> v = d.task.getOutput();
                        if(v.isIntermediate() && !v.getType().isArray())
                            requiredVariables.add(v);
                    }
                    break;
                }
            }
        }

        // Save any remaining variables to be produced at the end of the trace.
        DataflowTask<?> t = traceHandle.peek().task;
        Set<Variable<?>> s = data.requiredVariables.get(t);
        if(s == null)
            data.requiredVariables.put(t, requiredVariables);
        else
            s.addAll(requiredVariables);
    }

    /**
     * Method to get the index scopes, updating the list of fixed at the same time.
     */
    private static Set<ForTask> getRequiredLoops(Variable<?> v) {
        // Construct a set to hold the results.
        Set<ForTask> toReturn = new HashSet<>();

        // Construct a stack to hold the values that need to be processed.
        Stack<Variable<?>> toProcess = new Stack<>();
        // Prime the stack with the index to process.
        toProcess.add(v);

        Set<Variable<?>> seen = new HashSet<>();

        // While there are values to process.
        while(!toProcess.isEmpty()) {
            v = toProcess.pop();
            if(!seen.contains(v)) {
                seen.add(v);
                // If the value is an intermediate get the scopes that will be needed to dereference it.
                if(v.isIntermediate()) {
                    Scope s = v.scope();
                    while(s != GlobalScope.scope) {
                        switch(s.getScopeType()) {
                            case FOR:
                                toReturn.add((ForTask) s);
                                break;
                            default:
                                break;
                        }
                        s = s.getEnclosingScope();
                    }
                } else {
                    // Get the value and recover its constructing dataflow task.
                    DataflowTask<?> d = v.getParent();
                    // Depending on the task type.
                    switch(d.getType()) {
                        case FOR:
                        case PAR_FOR: {
                            // If it is a for task add the for to the list of scopes.
                            ForTask f = (ForTask) d;
                            toReturn.add(f);
                            toProcess.addAll(d.getInputs());
                            break;
                        }
                        case PUT: {
                            PutTask<?> pt = (PutTask<?>) d;
                            toProcess.add(pt.array);
                            break;
                        }
                        case ARRAY_CONSTRUCTOR:
                        case SAMPLE: {
                            // If it is a sample or array constructor stop as the value
                            // will be calculated separately, but add any scopes that
                            // the variable is declared in as these will be needed
                            // to access the instance of the variable.
                            Scope s = d.scope();
                            while(s != GlobalScope.scope) {
                                switch(s.getScopeType()) {
                                    case FOR:
                                        toReturn.add((ForTask) s);
                                        break;
                                    default:
                                        break;
                                }
                                s = s.getEnclosingScope();
                            }
                            break;
                        }
                        case REDUCTION_RETURN: { // Skip over any scopes inside the reduction.
                            ReductionReturnTask<?> rrt = (ReductionReturnTask<?>) d;
                            ReductionScope<?> scope = rrt.getReductionScope();
                            toProcess.add(scope.array);
                            toProcess.add(scope.emptyValue);
                            toProcess.add(scope.start);
                            toProcess.add(scope.end);
                            break;
                        }
                        default: {
                            // For all other operations just add the inputs to the
                            // list of values to process.
                            toProcess.addAll(d.getInputs());
                            break;
                        }
                    }
                }
            }
        }
        return toReturn;
    }

    private static ScopeDescription constructRestrictionInternal(RestrictionsData data, ScopeDescription target,
            int position, CompilationContext compilationCtx) {

        target.applySubstitutions(position, compilationCtx);

        Map<Variable<?>, VariablePair<?>> varSubstitutions = new HashMap<>();

        TraceHandle traceHandle = data.trace;

        // Get a copy of the substitutions for the end point as they stand at the
        // moment.
        Substitutions originalSubstitutions = target.getSubstitutions(position);

        Map<ForTask, IntVariable> forScopeSubstitutions = new HashMap<>(data.existingStartScopes);
        Map<ReductionScope<?>, ReductionScopeCopied<?>> reductionScopeSubs = new HashMap<>();

        // A map from dataflow tasks to put task indexes that were calculated earlier.
        Map<DataflowTask<?>, IRTreeReturn<IntVariable>> putIndexes = new HashMap<>();

        Scope innerScope = target.innerScope;

        int size = traceHandle.size();
        for(int i = 0; i < size; i++) {
            DataflowTaskArgDesc d = traceHandle.get(i);
            switch(d.task.getType()) {
                case GET: {
                    if(d.argPos == 0) {
                        GetTask<?> gt = (GetTask<?>) d.task;

                        // Construct the environment
                        ScopeChanges s = data.scopeData.get(gt);
                        innerScope = constructEnvironment(gt, data, forScopeSubstitutions, reductionScopeSubs,
                                innerScope, compilationCtx);

                        // If there is a put to go with this get a guard will be needed
                        IRTreeReturn<IntVariable> putIndex = putIndexes.get(gt);
                        if(putIndex != null) {
                            // Construct the guard.
                            IRTreeReturn<IntVariable> getIndex = getForwardIR(gt.index, gt.scope(), innerScope,
                                    compilationCtx);
                            innerScope = new IfScope(innerScope, IRTree.eq(putIndex, getIndex));
                        }

                        target = target.insertScope(innerScope, compilationCtx);

                        removeSubstitutions(s, forScopeSubstitutions, reductionScopeSubs, compilationCtx);
                    }

                    break;
                }

                case PUT: {
                    PutTask<?> pt = (PutTask<?>) d.task;
                    DataflowTask<?> task = data.usedPuts.get(pt);
                    if(task != null) {
                        // Construct the value of the put index
                        ScopeChanges s = data.scopeData.get(pt);
                        innerScope = constructEnvironment(pt, data, forScopeSubstitutions, reductionScopeSubs,
                                innerScope, compilationCtx);

                        if(data.storeSubstitutions.contains(pt))
                            target = target.addSubstitutions(position, pt, constructSubstituions(originalSubstitutions,
                                    varSubstitutions, forScopeSubstitutions, reductionScopeSubs));

                        // Construct all the values that the put value will depend on. This is required
                        // in the case that the intermediate also depends on the values being updated,
                        // and so needs to be regenerated to include the substituted values.
                        if(data.passValues) {
                            // Make sure there is only one substitute created for the put task value.

                            PriorityQueue<Variable<?>> p = new PriorityQueue<>(data.requiredVariables.get(pt));
                            while(!p.isEmpty()) {
                                Variable<?> v = p.poll();
                                if(v != pt.value)
                                    constructVarSubstitution(v, pt.scope(), innerScope, data, varSubstitutions,
                                            compilationCtx);
                            }

                            if(!pt.value.getType().isArray()) {
                                IRTreeReturn<?> t = getForwardIR(pt.value, pt.scope(), innerScope, compilationCtx);
                                constructVarSubstitution(task.getOutput(), t, innerScope, data, varSubstitutions,
                                        compilationCtx);
                            }
                        }

                        // Construct the index for put task, this will be used in the guards later.
                        IRTreeReturn<IntVariable> putIndex = getForwardIR(pt.index, pt.scope(), innerScope,
                                compilationCtx);

                        // And construct a description of the index and the value paired with the
                        // corresponding get.
                        putIndexes.put(task, putIndex);

                        removeSubstitutions(s, forScopeSubstitutions, reductionScopeSubs, compilationCtx);
                    } else {
                        // No restrictions are required, but the status of the scopes at the point this
                        // is reached should be recorded.
                        if(data.storeSubstitutions.contains(pt))
                            target = target.addSubstitutions(position, pt, constructSubstituions(originalSubstitutions,
                                    varSubstitutions, forScopeSubstitutions, reductionScopeSubs));
                    }
                    break;
                }

                case REDUCE_INPUT: {
                    ReductionInput<?> ri = (ReductionInput<?>) d.task;

                    // Construct the environment
                    innerScope = constructEnvironment(ri, data, forScopeSubstitutions, reductionScopeSubs, innerScope,
                            compilationCtx);
                    IRTreeReturn<IntVariable> index = putIndexes.get(ri);
                    if(index != null) {
                        // Check that the put was in the range of the range of the reduction
                        IRTreeReturn<IntVariable> start = getForwardIR(ri.start, ri.start.scope(), innerScope,
                                compilationCtx);
                        IRTreeReturn<IntVariable> end = getForwardIR(ri.end, ri.end.scope(), innerScope,
                                compilationCtx);
                        IRTreeReturn<BooleanVariable> guard = IRTree.and(IRTree.lessThanEqual(start, index),
                                IRTree.lessThan(index, end));
                        innerScope = new IfScope(innerScope, guard);
                    }

                    // Isolate the reduction just in case. This is probably not required, but will
                    // be removed in optimisation.
                    innerScope = new BlockScope(innerScope, Tree.NoComment);

                    // Process the reduction
                    if(data.passValues) {
                        innerScope = processReductionInput(ri, index, innerScope, data, varSubstitutions,
                                compilationCtx);
                        ScopeChanges s = data.scopeData.get(ri);
                        removeSubstitutions(s, forScopeSubstitutions, reductionScopeSubs, compilationCtx);
                    } else {
                        /*
                         * If variables are not being passed the reduction is called as normal, but placed in the
                         * constructed scope.
                         */
                        ReductionScope<?> rs = ri.scope();
                        ReductionScopeCopied<?> newReductionScope = new ReductionScopeCopied<>(innerScope, rs);
                        ScopeChanges s = data.scopeData.get(ri);
                        removeSubstitutions(s, forScopeSubstitutions, reductionScopeSubs, compilationCtx);
                        reductionScopeSubs.put(rs, newReductionScope);

                    }

                    break;
                }

                case IF_ASSIGNMENT: {
                    IfElseAssignmentTask<?> ifElseAssignmentTask = (IfElseAssignmentTask<?>) d.task;

                    // Construct the environment
                    ScopeChanges s = data.scopeData.get(ifElseAssignmentTask);
                    innerScope = constructEnvironment(ifElseAssignmentTask, data, forScopeSubstitutions,
                            reductionScopeSubs, innerScope, compilationCtx);

                    // Construct the guard.
                    switch(d.argPos) {
                        case 0: {
                            break;
                        }

                        case 1:
                        case 2: {
                            IRTreeReturn<BooleanVariable> guard = getForwardIR(ifElseAssignmentTask.guard,
                                    ifElseAssignmentTask.scope(), innerScope, compilationCtx);
                            Variable<?> v;
                            if(d.argPos == 1)
                                v = ifElseAssignmentTask.ifValue;
                            else {
                                v = ifElseAssignmentTask.elseValue;
                                guard = IRTree.negateBoolean(guard);
                            }

                            innerScope = new IfScope(innerScope, guard);
                            IRTreeReturn<?> t = getForwardIR(v, ifElseAssignmentTask.scope(), innerScope,
                                    compilationCtx);
                            constructVarSubstitution(ifElseAssignmentTask.getOutput(), t, innerScope, data,
                                    varSubstitutions, compilationCtx);
                            break;
                        }

                        default:
                            throw new CompilerException("Unexpected argument position " + d.argPos);
                    }

                    target = target.insertScope(innerScope, compilationCtx);

                    removeSubstitutions(s, forScopeSubstitutions, reductionScopeSubs, compilationCtx);

                    break;
                }

                default:
                    break;
            }
        }

        innerScope = constructAdditionalScopes(data, forScopeSubstitutions, innerScope, compilationCtx);

        PriorityQueue<Variable<?>> p = new PriorityQueue<>(data.requiredVariables.get(data.trace.peek().task));
        Scope targetScope = data.trace.peek().task.scope();
        while(!p.isEmpty())
            constructVarSubstitution(p.poll(), targetScope, innerScope, data, varSubstitutions, compilationCtx);

        // Remove added variable substitutions.
        for(Variable<?> v:varSubstitutions.keySet())
            compilationCtx.removeSubstitute(v);

        target.removeSubstitutions(position, compilationCtx);

        Substitutions s = constructSubstituions(originalSubstitutions, varSubstitutions, forScopeSubstitutions,
                reductionScopeSubs);
        target = target.insertScope(innerScope, data.existingScopes, compilationCtx);
        target = target.addSubstitutions(position, s);

        return target;
    }

    private static <A extends Variable<A>> Scope processReductionInput(ReductionInput<A> ri,
            IRTreeReturn<IntVariable> putIndex, Scope innerScope, RestrictionsData data,
            Map<Variable<?>, VariablePair<?>> varSubstitutions, CompilationContext compilationCtx) {

        Variable<A> output = ri.getOutput();
        if(output.getType().isArray())
            throw new MissingFeatureException("Arrays cannot currently be substituted through reductions. This "
                    + "error is being caused because the compiler is trying to declare local variables to avoid altering "
                    + "the model state at this part of the code, but can only do this for scalar values.");
        /*
         * If values are being passed, the sum of the elements except the one being passed is first constructed, then
         * the passed value is included.
         */
        // For now remove the put task substitution
        Variable<A> putValue = compilationCtx.getSubstitute(output);
        compilationCtx.removeSubstitute(output);

        ReductionScope<A> rs = ri.scope();

        // Construct the value from the rest of the array.
        compilationCtx.addScopeSubstitute(rs.getEnclosingScope(), innerScope);
        Variable<A> maskedResult = rs.reduceArrayValue(ri, putIndex, compilationCtx);
        compilationCtx.removeScopeSubstitute(rs.getEnclosingScope());
        innerScope = maskedResult.scope();

        compilationCtx.addScopeSubstitute(rs, innerScope);
        compilationCtx.addSubstitute(output, putValue);
        compilationCtx.addSubstitute(rs.j, maskedResult);
        Variable<?> returnVar = rs.returnVar;
        constructVarSubstitution(returnVar, rs.getEnclosingScope(), innerScope, data, varSubstitutions, compilationCtx);

        compilationCtx.removeScopeSubstitute(rs);
        compilationCtx.removeSubstitute(rs.j);
        return innerScope;
    }

    private static Substitutions constructSubstituions(Substitutions originalSubstitutions,
            Map<Variable<?>, VariablePair<?>> varSubstitutions, Map<ForTask, IntVariable> forSubstitutions,
            Map<ReductionScope<?>, ReductionScopeCopied<?>> reductionSubstitutions) {
        HashMap<Variable<?>, VariablePair<?>> returnSubstitutions = new HashMap<>(
                originalSubstitutions.varSubstitutions);
        returnSubstitutions.putAll(varSubstitutions);
        for(ForTask t:forSubstitutions.keySet()) {
            IntVariable index = t.getIndex();
            returnSubstitutions.put(index, new VariablePair<>(index, forSubstitutions.get(t)));
        }

        return new Substitutions(returnSubstitutions, reductionSubstitutions);
    }

    /**
     * A function to add a newly constructed variable to the scope that holds the value of the variable constructed in
     * the current state of the compilationCtx, and add a substitution that will replace the provided variable with a
     * load of the newly constructed variable. This allows values to be cached as locally rather than written out to
     * globals where collisions in multithreaded code can occur.
     *
     * @param <A>              The type of the variable
     * @param v                Variable that will be substituted.
     * @param t                Tree providing the value to be used in the substitution
     * @param scope            The scope of the variable should be created in.
     * @param data             The data object providing the context.
     * @param varSubstitutions A set recording all the substitutions made.
     * @param compilationCtx   The compilation context of the function.
     */
    private static <A extends Variable<A>> void constructVarSubstitution(Variable<A> v, IRTreeReturn<?> t, Scope scope,
            RestrictionsData data, Map<Variable<?>, VariablePair<?>> varSubstitutions,
            CompilationContext compilationCtx) {
        if(!varSubstitutions.containsKey(v)) {
            VariableDescription<A> subName = VariableNames.traceTempName(v.getVarDesc().name, data.globalID,
                    data.localID++, v.getType());
            IRTreeVoid init = IRTree.initializeVariable(subName, (IRTreeReturn<A>) t, Tree.NoComment);
            compilationCtx.addTreeToScope(scope, init);
            Variable<A> replacement = Variable.namedVariable(subName, scope);
            compilationCtx.addSubstitute(v, replacement);
            varSubstitutions.put(v, new VariablePair<>(v, replacement));
        }
    }

    /**
     * A function to add a newly constructed variable to the scope that holds the value of the variable constructed in
     * the current state of the compilationCtx, and add a substitution that will replace the provided variable with a
     * load of the newly constructed variable. This allows values to be cached as locally rather than written out to
     * globals where collisions in multithreaded code can occur.
     *
     * @param <A>              The type of the variable
     * @param v                Variable that will be substituted.
     * @param scope            The scope of the variable should be created in.
     * @param data             The data object providing the context.
     * @param varSubstitutions A set recording all the substitutions made.
     * @param compilationCtx   The compilation context of the function.
     */
    private static <A extends Variable<A>> void constructVarSubstitution(Variable<A> v, Scope sourceScope,
            Scope targetScope, RestrictionsData data, Map<Variable<?>, VariablePair<?>> varSubstitutions,
            CompilationContext compilationCtx) {
        if(!varSubstitutions.containsKey(v)) {
            v.calculateIntermediate(true);
            IRTreeReturn<A> t = getForwardIR(v, sourceScope, targetScope, compilationCtx);
            v.calculateIntermediate(false);
            constructVarSubstitution(v, t, targetScope, data, varSubstitutions, compilationCtx);
        }
    }

    private static <A extends Variable<A>> IRTreeReturn<A> getForwardIR(Variable<A> v, Scope sourceScope,
            Scope targetScope, CompilationContext compilationCtx) {
        Scope s = sourceScope;
        while(s != null) {
            compilationCtx.addScopeSubstitute(s, GlobalScope.scope);
            s = s.getEnclosingScope();
        }

        s = targetScope;
        while(s != null) {
            compilationCtx.addScopeSubstitute(s, GlobalScope.scope);
            s = s.getEnclosingScope();
        }

        compilationCtx.pushScope();
        compilationCtx.pushInitializedArrays();

        IRTreeReturn<A> t = v.getForwardIR(compilationCtx);
        IRTreeVoid scopeTree = compilationCtx.getOutermostScopeTree();

        compilationCtx.popInitializedArrays();
        compilationCtx.popScope();

        s = targetScope;
        while(s != null) {
            compilationCtx.removeScopeSubstitute(s);
            s = s.getEnclosingScope();
        }

        s = sourceScope;
        while(s != null) {
            compilationCtx.removeScopeSubstitute(s);
            s = s.getEnclosingScope();
        }

        compilationCtx.addTreeToScope(targetScope, scopeTree);
        return t;
    }

    private static Scope constructEnvironment(DataflowTask<?> task, RestrictionsData data,
            Map<ForTask, IntVariable> forScopeSubs, Map<ReductionScope<?>, ReductionScopeCopied<?>> reductionScopeSubs,
            Scope outerScope, CompilationContext compilationCtx) {
        ScopeChanges s = data.scopeData.get(task);

        // Set all the current substitutions so they are there when the scopes are created.
        for(ForTask t:forScopeSubs.keySet()) {
            IntVariable index = forScopeSubs.get(t);
            compilationCtx.addSubstitute(t.getIndex(), index);
            compilationCtx.addScopeSubstitute(t, outerScope);
        }

        for(ReductionScope<?> rs:reductionScopeSubs.keySet())
            compilationCtx.addScopeSubstitute(rs, reductionScopeSubs.get(rs));

        // Construct any required Scopes
        Set<ForTask> constructScopes = s.getConstructScopes();
        PriorityQueue<ForTask> p = new PriorityQueue<>(constructScopes);
        Scope lastScope = GlobalScope.scope;
        while(!p.isEmpty()) {
            ForTask t = p.poll();

            // Add any required guards
            outerScope = addGuards(outerScope, t, lastScope, compilationCtx);

            ForTask newScope = ScopeUtils.constructForScope(outerScope, t, data.existingScopes.contains(t),
                    data.globalID + "_" + data.localID++, compilationCtx);
            data.existingScopes.add(t);

            // If we have replaced the old scope remove its substitution
            if(forScopeSubs.containsKey(t)) {
                compilationCtx.removeSubstitute(t.getIndex());
                compilationCtx.removeScopeSubstitute(t);
            }

            // Add in substitutes for the newly
            compilationCtx.addSubstitute(t.getIndex(), newScope.getIndex());
            compilationCtx.addScopeSubstitute(t, newScope);

            // Store the substitute for later
            forScopeSubs.put(t, newScope.getIndex());

            // and update the outer scope.
            outerScope = newScope;
        }

        // Construct any required Scopes
        p = new PriorityQueue<>(s.getSubstituteScopes());
        while(!p.isEmpty()) {
            ForTask t = p.poll();

            // Add any required guards
            outerScope = addGuards(outerScope, t, lastScope, compilationCtx);

            // If we have replaced the old scope remove its substitution
            if(forScopeSubs.containsKey(t)) {
                compilationCtx.removeSubstitute(t.getIndex());
                compilationCtx.removeScopeSubstitute(t);
            }

            // Add in substitutes for the newly
            IntVariable index = data.existingEndLoops.get(t);
            compilationCtx.addSubstitute(t.getIndex(), index);
            compilationCtx.addScopeSubstitute(t, outerScope);

            // Store the substitute for later
            forScopeSubs.put(t, index);
        }

        // Add any required guards
        outerScope = addGuards(outerScope, task.scope(), lastScope, compilationCtx);

        // Now the scopes are created remove the substitutions.
        for(ForTask t:forScopeSubs.keySet()) {
            compilationCtx.removeSubstitute(t.getIndex());
            compilationCtx.removeScopeSubstitute(t);
        }

        // Set any required substitutions for the guard
        for(ForTask t:s.getUsedScopes()) {
            IntVariable index = forScopeSubs.get(t);
            if(index != null) {
                compilationCtx.addSubstitute(t.getIndex(), index);
                compilationCtx.addScopeSubstitute(t, outerScope);
            }
        }

        return outerScope;
    }

    private static Scope addGuards(Scope outerScope, Scope taskScope, Scope lastScope,
            CompilationContext compilationCtx) {
        List<Scope> guardScopes = new ArrayList<>();
        while(taskScope != lastScope) {
            switch(taskScope.getScopeType()) {
                case ELSE:
                case IF:
                    guardScopes.add(taskScope);
                    break;
                default:
                    break;

            }
            taskScope = taskScope.getEnclosingScope();
        }

        int size = guardScopes.size();
        for(int i = size - 1; i >= 0; i--) {
            Scope scope = guardScopes.get(i);
            IRTreeReturn<BooleanVariable> guardTree;
            switch(scope.getScopeType()) {
                case IF:
                    guardTree = getForwardIR(((IfScope) scope).guard, taskScope, outerScope, compilationCtx);
                    break;
                case ELSE:
                    guardTree = IRTree.negateBoolean(
                            getForwardIR(((ElseScope) scope).ifScope.guard, taskScope, outerScope, compilationCtx));
                    break;
                default:
                    throw new CompilerException("This should be unreachable");
            }
            outerScope = new IfScope(outerScope, guardTree);
        }
        return outerScope;
    }

    private static void removeSubstitutions(ScopeChanges s, Map<ForTask, IntVariable> substitutions,
            Map<ReductionScope<?>, ReductionScopeCopied<?>> reductionScopeSubs, CompilationContext compilationCtx) {
        // Remove any required substitutions
        for(ForTask t:s.getUsedScopes()) {
            if(substitutions.containsKey(t)) {
                compilationCtx.removeSubstitute(t.getIndex());
                compilationCtx.removeScopeSubstitute(t);
            }
        }
        for(ReductionScope<?> rs:reductionScopeSubs.keySet())
            compilationCtx.removeScopeSubstitute(rs);
    }

    private static Scope constructAdditionalScopes(RestrictionsData data, Map<ForTask, IntVariable> substitutions,
            Scope outerScope, CompilationContext compilationCtx) {
        // Set all the current substitutions so they are there when the scopes are
        // created.
        for(ForTask t:substitutions.keySet()) {
            IntVariable index = substitutions.get(t);
            compilationCtx.addSubstitute(t.getIndex(), index);
            compilationCtx.addScopeSubstitute(t, outerScope);
        }

        for(ForTask t:data.finalLoops) {
            ForTask newScope = ScopeUtils.constructForScope(outerScope, t, data.existingScopes.contains(t),
                    data.globalID + "_" + data.localID++, compilationCtx);
            data.existingScopes.add(t);

            // If we have replaced the old scope remove its substitution
            if(substitutions.containsKey(t)) {
                compilationCtx.removeSubstitute(t.getIndex());
                compilationCtx.removeScopeSubstitute(t);
            }

            // Add in substitutes for the newly
            compilationCtx.addSubstitute(t.getIndex(), newScope.getIndex());
            compilationCtx.addScopeSubstitute(t, newScope);

            // Store the substitute for later
            substitutions.put(t, newScope.getIndex());
            outerScope = newScope;
        }

        // Now the scopes are created remove the substitutions.
        for(ForTask t:substitutions.keySet()) {
            compilationCtx.removeSubstitute(t.getIndex());
            compilationCtx.removeScopeSubstitute(t);
        }
        return outerScope;
    }

    public static boolean restrictionRequired(TraceHandle th) {
        int i = 0;
        int size = th.size();
        while(i < size) {
            DFType type = th.get(i++).task.getType();
            if(type == DFType.PUT)
                break;
            if(type == DFType.IF_ASSIGNMENT)
                return true;
        }

        while(i < size) {
            DFType type = th.get(i++).task.getType();
            if(type == DFType.GET)
                return true;
            if(type == DFType.IF_ASSIGNMENT)
                return true;
        }

        return false;
    }
}
