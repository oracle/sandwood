/*
 * Sandwood
 *
 * Copyright (c) 2019-2025, Oracle and/or its affiliates
 * 
 * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/
 */

package org.sandwood.compiler.compilation.inference;

import static org.sandwood.compiler.trees.irTree.IRTree.addDD;
import static org.sandwood.compiler.trees.irTree.IRTree.arrayGet;
import static org.sandwood.compiler.trees.irTree.IRTree.arrayPut;
import static org.sandwood.compiler.trees.irTree.IRTree.constant;
import static org.sandwood.compiler.trees.irTree.IRTree.divideDD;
import static org.sandwood.compiler.trees.irTree.IRTree.functionCall;
import static org.sandwood.compiler.trees.irTree.IRTree.functionCallReturn;
import static org.sandwood.compiler.trees.irTree.IRTree.ifElse;
import static org.sandwood.compiler.trees.irTree.IRTree.initializeUnsetVariable;
import static org.sandwood.compiler.trees.irTree.IRTree.initializeVariable;
import static org.sandwood.compiler.trees.irTree.IRTree.lessThan;
import static org.sandwood.compiler.trees.irTree.IRTree.load;
import static org.sandwood.compiler.trees.irTree.IRTree.log;
import static org.sandwood.compiler.trees.irTree.IRTree.max;
import static org.sandwood.compiler.trees.irTree.IRTree.min;
import static org.sandwood.compiler.trees.irTree.IRTree.multiplyDD;
import static org.sandwood.compiler.trees.irTree.IRTree.newArray;
import static org.sandwood.compiler.trees.irTree.IRTree.sequential;
import static org.sandwood.compiler.trees.irTree.IRTree.store;
import static org.sandwood.compiler.trees.irTree.IRTree.subtractDD;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.sandwood.compiler.compilation.CompilationContext;
import org.sandwood.compiler.compilation.FunctionType;
import org.sandwood.compiler.compilation.util.TreeUtils;
import org.sandwood.compiler.dataflowGraph.Sandwood;
import org.sandwood.compiler.dataflowGraph.scopes.GlobalScope;
import org.sandwood.compiler.dataflowGraph.scopes.Scope;
import org.sandwood.compiler.dataflowGraph.scopes.ScopeStack;
import org.sandwood.compiler.dataflowGraph.tasks.DataflowTask;
import org.sandwood.compiler.dataflowGraph.tasks.returnTasks.DistributionSampleTask;
import org.sandwood.compiler.dataflowGraph.tasks.returnTasks.SampleTask;
import org.sandwood.compiler.dataflowGraph.tasks.sandwoodOperators.ForTask;
import org.sandwood.compiler.dataflowGraph.variables.Variable;
import org.sandwood.compiler.dataflowGraph.variables.VariableDescription;
import org.sandwood.compiler.dataflowGraph.variables.VariableType;
import org.sandwood.compiler.dataflowGraph.variables.arrayVariable.ArrayVariable;
import org.sandwood.compiler.dataflowGraph.variables.randomVariables.DistributableRandomVariable;
import org.sandwood.compiler.dataflowGraph.variables.randomVariables.RandomVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.DoubleVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.IntVariable;
import org.sandwood.compiler.dataflowGraph.variables.scalarVariables.ScalarVariable;
import org.sandwood.compiler.exceptions.CompilerException;
import org.sandwood.compiler.names.VariableNames;
import org.sandwood.compiler.traces.guards.TreeBuilderInfo;
import org.sandwood.compiler.trees.Tree;
import org.sandwood.compiler.trees.irTree.IRLoad;
import org.sandwood.compiler.trees.irTree.IRTree;
import org.sandwood.compiler.trees.irTree.IRTreeReturn;
import org.sandwood.compiler.trees.irTree.IRTreeVoid;

/**
 * Class that implements the specific method bodies to allow inference to be performed by calculating the probabilities
 * of provided samples. The formulas for the probability of each value being are as follows:
 * <p>
 * The probabilities for the source RV generating the value, and each sample task from a consuming RV that produce a
 * fixed output our combined for efficiency reasons, but can be described for each part as.
 * <p>
 * Probability of the source generating the marginalized value = (Sum over possible distributed source arguments 'ds'
 * (P(source_value | ds) * p(ds))) / (Sum over possible distributed source arguments 'ds' P(ds))
 * <p>
 * This weights each possible value of the source RV relative to the probability of the arguments it was generated with.
 * The division normalises this so that the sum of all possible values will be 1.
 * <p>
 * The probability of a sample task generating the value v given the value generated by the source RV = 1 - ((Sum over
 * possible distributed source arguments 'ds' * (Sum over possible distributed consumer arguments 'dc' P(dc| ds) *
 * P(ds))) + (Sum over possible distributed source arguments 'ds' (Sum over possible distributed consumer arguments 'dc'
 * P(v | dc, ds) * P(dc | ds)* P(ds)))
 * <p>
 * The first 2 terms account for the situation where some of the outputs from the consumer do not occur in conjunction
 * with the source. Example of when this might happen include if the result from a distribution is used to index into an
 * array of values such that the path between the source and the consumer is only valid for some of the probability
 * space. In the cases when the consumer cannot be reached, its probability is set to 1, the identity value for
 * multiplication.
 * <p>
 * The probability of a sample task generating a distribution being produced by the output from the source. When
 * comparing distributions this is done by measuring the overlap between the distributions. This does have the issue of
 * what would happen if the probability of a value in one distribution was 0 and in the other it was non-zero, but for
 * now this seems the best comparison measure.
 * <p>
 * 1 - (Sum over possible distributed consumer arguments 'dc' ((Sum over possible distributed source arguments 'ds' P(ds
 * | dc) P(dc)))) + overlap(consumer sample task distribution, (Sum over possible distributed consumer arguments 'dc'
 * (distribution(consumer RV | dc) * p(dc) * (Sum over possible distributed source arguments 'ds' P(ds | dc)))
 * <p>
 * distribution is a function that provides a probability distribution for a given set of inputs. The summed
 * distributions are normalised to ensure that the resulting distribution sums to 1 before the overlap is calculated.
 * <p>
 * To prevent probabilities underflowing to zero the probabilities of proposed sample values are stored in log space.
 * The probabilities of specific configurations are stored in normal space for the time being, but this may be changed
 * later.
 *
 * @param <A>
 * @param <B>
 */
public abstract class InferenceGeneratorScalarProb<A extends ScalarVariable<A>, B extends RandomVariable<A, B>, FuncData extends InferenceGeneratorScalarProb.ScalarProbFunctionData<A, B>>
        extends InferenceGeneratorScalar<A, B, FuncData> {

    public abstract static class ScalarProbFunctionData<A extends ScalarVariable<A>, B extends RandomVariable<A, B>>
            extends ScalarFunctionData<A, B> {

        public final IntVariable noStates;

        public final IRTreeReturn<IntVariable> valuePos = load(valuePosName);

        // TODO remove this can make all argument creation in array tracing scoped.
        List<IRTreeReturn<?>> consumerRVArgs;

        protected ScalarProbFunctionData(SampleTask<A, B> sample, IntVariable noStates,
                CompilationContext compilationCtx) {
            super(sample, true, compilationCtx);

            this.noStates = noStates;
        }
    }

    private int id = 0;

    private final static VariableDescription<IntVariable> valuePosName = VariableNames.calcVarName("valuePos",
            VariableType.IntVariable, false);

    // Flags for the different variables that we will need to construct for this
    // function.
    private final static VariableDescription<DoubleVariable> statesProbabilityValue = VariableNames
            .calcVarName("stateProbabilityValue", VariableType.DoubleVariable, true);

    // Log space accumulator for all the consumer sample probabilities calculated
    // so far.
    private final static VariableDescription<DoubleVariable> consumerSampleProbabilitiesAccumulator = VariableNames
            .calcVarName("accumulatedConsumerProbabilities", VariableType.DoubleVariable, true);

    // Normal space accumulator for the probability of reaching each consumer.
    private final static VariableDescription<DoubleVariable> consumerSampleDistributionProbabilityAccumulator = VariableNames
            .calcVarName("consumerDistributionProbabilityAccumulator", VariableType.DoubleVariable, true);

    // Accumulator for all the consumer sample distributions calculated so far.
    private final static VariableDescription<ArrayVariable<DoubleVariable>> consumerSampleDistributionAccumulator = VariableNames
            .calcVarName("accumulatedConsumerDistributions", VariableType.arrayType(VariableType.DoubleVariable), true);

    // An accumulator for the combined distribution probabilities calculated so far.
    private final static VariableDescription<DoubleVariable> distributionProbabilityAccumulator = VariableNames
            .calcVarName("accumulatedDistributionProbabilities", VariableType.DoubleVariable, true);

    // An accumulator for the overall probabilities for a source sample paring to be
    // summed in before they are multiplied into the overall result.
    private final static VariableDescription<DoubleVariable> probabilitiesAccumulator = VariableNames
            .calcVarName("accumulatedProbabilities", VariableType.DoubleVariable, true);

    // The value of the probabilities not reached when exploring the distributions
    // for the random variable.
    private final static VariableDescription<DoubleVariable> reachedDistributionsSource = VariableNames
            .calcVarName("reachedDistributionSourceRV", VariableType.DoubleVariable, true);
    private final static VariableDescription<DoubleVariable> reachedDistributions = VariableNames
            .calcVarName("reachedDistributionProbability", VariableType.DoubleVariable, true);

    private final Map<DistributableRandomVariable<?, ?>, VariableDescription<ArrayVariable<DoubleVariable>>> globalDistributionScratchSpace = new HashMap<>();

    private VariableDescription<ArrayVariable<DoubleVariable>> getDistributionAccumulatorName(
            DistributableRandomVariable<?, ?> rv) {
        return VariableNames.calcVarName("distributionAccumulator", rv.getUniqueVarDesc().name.getName(),
                VariableType.arrayType(VariableType.DoubleVariable), true);
    }

    // The current value being considered
    private VariableDescription<A> currentValueName;

    private boolean canSetCurrent = false;

    @Override
    protected void constructFunctionVariables(CompilationContext compilationCtx, FuncData funcData) {
        constructFunctionVariablesProb(compilationCtx, funcData);

        currentValueName = VariableNames.calcVarName("currentValue", funcData.sampleDesc.output.getType(), true);

        compilationCtx.addSubstitute(funcData.sampleDesc.output, Variable.namedVariable(currentValueName));
    }

    protected abstract void constructFunctionVariablesProb(CompilationContext compilationCtx, FuncData funcData);

    protected IRTreeVoid setCurrentValue(IRTreeReturn<A> value, String comment) {
        if(!canSetCurrent)
            throw new CompilerException("Trying to change the value currently being inferred on during inference.");
        return store(currentValueName, value, comment);
    }

    protected IRTreeReturn<A> getCurrentValue() {
        return load(currentValueName);
    }

    @Override
    protected void getPerDistributedSampleStartIR(FuncData funcData, DistributionSampleTask<?, ?> s,
            TreeBuilderInfo info, CompilationContext compilationCtx) {
        DistributableRandomVariable<?, ?> disRV = s.randomVariable;
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(consumerSampleDistributionAccumulator,
                        loadGlobalField(globalDistributionScratchSpace.get(disRV), funcData, compilationCtx),
                        "A local array to hold the accumulated distributions of "
                                + "the sample tasks for each configuration of distributions."));

        VariableDescription<IntVariable> indexName = VariableNames.calcVarName("i", VariableType.IntVariable, true);
        IRTreeVoid body = arrayPut(load(consumerSampleDistributionAccumulator), load(indexName), constant(0.0),
                Tree.NoComment);
        IRTreeVoid loop = IRTree.forStmt(body, constant(0), disRV.getNoStates().getForwardIR(compilationCtx),
                constant(1), indexName, true, "Zero all the elements in the distribution accumulator");
        compilationCtx.addTreeToScope(GlobalScope.scope, loop);

        compilationCtx.addTreeToScope(GlobalScope.scope, initializeVariable(reachedDistributions, constant(0.0),
                "Zero an accumulator to track the probabilities reached."));
    }

    @Override
    protected void getPerDistributedSampleEndIR(FuncData funcData, DistributionSampleTask<?, ?> s, TreeBuilderInfo info,
            CompilationContext compilationCtx) {
        // Get a local copy of the sample distribution
        IRTreeReturn<ArrayVariable<DoubleVariable>> sampleDistribution = s.getProbabilitiesArray()
                .getForwardIR(compilationCtx);
        VariableDescription<ArrayVariable<DoubleVariable>> sampleDescriptionName = VariableNames
                .calcVarName("sampleDistribution", sampleDistribution.getOutputType(), true);
        compilationCtx.addTreeToScope(GlobalScope.scope, initializeVariable(sampleDescriptionName, sampleDistribution,
                "A local copy of the samples' distribution."));

        VariableDescription<DoubleVariable> overlapName = VariableNames.calcVarName("overlap",
                VariableType.DoubleVariable, true);
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(overlapName, constant(0.0), "The overlap of the distributions so far."));

        // Start constructing the body of the for loop
        IRTreeVoid[] bodyStmts = new IRTreeVoid[3];
        VariableDescription<IntVariable> indexName = VariableNames.calcVarName("i", VariableType.IntVariable, true);

        // Normalise the calculated distribution value.
        VariableDescription<DoubleVariable> normalisedName = VariableNames.calcVarName("normalisedDistValue",
                VariableType.DoubleVariable, true);
        bodyStmts[0] = initializeVariable(normalisedName,
                divideDD(arrayGet(load(consumerSampleDistributionAccumulator), load(indexName)),
                        load(reachedDistributions)),
                "Normalise the values in the calculated distribution");

        // Recover the sample distribution value for this position.
        VariableDescription<DoubleVariable> sampleValueName = VariableNames.calcVarName("sampleDistValue",
                VariableType.DoubleVariable, true);
        bodyStmts[1] = initializeVariable(sampleValueName, arrayGet(load(sampleDescriptionName), load(indexName)),
                "Corresponding value from the sample distribution");

        bodyStmts[2] = ifElse(lessThan(load(sampleValueName), load(normalisedName)),
                store(overlapName, addDD(load(overlapName), load(sampleValueName)), Tree.NoComment),
                "Calculate the overlap and store the result",
                store(overlapName, addDD(load(overlapName), load(normalisedName)), Tree.NoComment),
                "Calculate the overlap and store the result");

        // Place the body statements in a loop that will iterate for all the elements in
        // the distribution.
        IRTreeVoid body = sequential(bodyStmts, Tree.NoComment);
        IRTreeVoid loop = IRTree.forStmt(body, constant(0), s.randomVariable.getNoStates().getForwardIR(compilationCtx),
                constant(1), indexName, true, "Calculate the overlap for each element in the distribution");
        compilationCtx.addTreeToScope(GlobalScope.scope, loop);

        // Compute the ratio of the overlap that should be added with 1 being used
        // for the values that are unreachable.
        compilationCtx.addTreeToScope(GlobalScope.scope,
                store(distributionProbabilityAccumulator, addDD(load(distributionProbabilityAccumulator),
                        log(addDD(
                                multiplyDD(load(overlapName), load(reachedDistributions)),
                                subtractDD(constant(1.0), min(load(reachedDistributions), constant(1.0)))))),
                        "Scale and add the result to the combined results so far. A min is taken over the reached "
                                + "distributions so that rounding cannot result in a value greater than one as for a small "
                                + "probability this could give a negative value"));
    }

    @Override
    protected void getPerSampleStartIR(FuncData funcData, SampleTask<?, ?> s, TreeBuilderInfo info,
            CompilationContext compilationCtx) {
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(consumerSampleProbabilitiesAccumulator, constant(Double.NEGATIVE_INFINITY),
                        "Set an accumulator to sum the probabilities for each possible configuration " + "of inputs."));
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(consumerSampleDistributionProbabilityAccumulator, constant(1.0),
                        "Set an accumulator to record the consumer distributions not seen. Initially set "
                                + "to 1 as seen values will be deducted from this value."));
    }

    @Override
    protected void getPerSampleEndIR(FuncData funcData, TreeBuilderInfo info, CompilationContext compilationCtx) {
        compilationCtx.addTreeToScope(GlobalScope.scope,
                store(consumerSampleDistributionProbabilityAccumulator,
                        max(load(consumerSampleDistributionProbabilityAccumulator), constant(0.0)),
                        "A check to ensure rounding of floating point values can never result in a negative value."));
        compilationCtx.addTreeToScope(GlobalScope.scope, TreeUtils.lseAdd(load(consumerSampleProbabilitiesAccumulator),
                log(load(consumerSampleDistributionProbabilityAccumulator)), (IRTreeReturn<DoubleVariable> output) -> {
                    return IRTree.store(probabilitiesAccumulator, addDD(output, load(probabilitiesAccumulator)),
                            Tree.NoComment);
                }, "Multiply (log space add) in the probability of the sample task to the overall "
                        + "probability for this configuration of the source random variable."));
    }

    @Override
    protected void backTraceScopeStartIR(FuncData funcData, TreeBuilderInfo info, CompilationContext compilationCtx) {
        compilationCtx.addTreeToScope(GlobalScope.scope, initializeVariable(statesProbabilityValue,
                constant(Double.NEGATIVE_INFINITY), "Initialize the summed probabilities to 0."));
        compilationCtx.addTreeToScope(GlobalScope.scope, initializeVariable(reachedDistributionsSource, constant(0.0),
                "Initialize a counter to track the reached distributions."));
        compilationCtx.addTreeToScope(GlobalScope.scope, initializeVariable(distributionProbabilityAccumulator,
                constant(0.0),
                "Initialize a log space accumulator to take the product of all the distribution probabilities."));
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeUnsetVariable(currentValueName, "The value currently being tested"));

        canSetCurrent = true;
        setSampleValue(funcData, compilationCtx);
        canSetCurrent = false;
    }

    protected abstract void setSampleValue(FuncData funcData, CompilationContext compilationCtx);

    @Override
    protected void backTraceScopeEndIR(FuncData funcData, TreeBuilderInfo info, CompilationContext compilationCtx) {
        IRTreeReturn<DoubleVariable> value = addDD(
                subtractDD(load(statesProbabilityValue), log(load(reachedDistributionsSource))),
                load(distributionProbabilityAccumulator));

        saveBackTraceProbability(funcData, value, compilationCtx);
    }

    protected abstract void saveBackTraceProbability(FuncData funcData, IRTreeReturn<DoubleVariable> value,
            CompilationContext compilationCtx);

    @Override
    protected void getDistributionSampleIR(DistributionSampleTask<?, ?> s,
            IRTreeReturn<DoubleVariable> sourceProbability, FuncData funcData, TreeBuilderInfo info,
            CompilationContext compilationCtx) {
        VariableDescription<DoubleVariable> distributionProbability = VariableNames
                .calcVarName("distributionProbability", VariableType.DoubleVariable, true);
        compilationCtx.addTreeToScope(GlobalScope.scope,
                initializeVariable(distributionProbability, multiplyDD(sourceProbability, info.probability),
                        "The probability of reaching the consumer with this set of consumer arguments"));
        compilationCtx.addTreeToScope(GlobalScope.scope, store(reachedDistributions,
                addDD(load(reachedDistributions), load(distributionProbability)), "Record the reached distribution."));

        DistributableRandomVariable<?, ?> random = s.randomVariable;

        List<IRTreeReturn<?>> args = new ArrayList<>();
        args.add(load(consumerSampleDistributionAccumulator));
        args.add(load(distributionProbability));
        args.addAll(funcData.consumerRVArgs);

        compilationCtx.addTreeToScope(GlobalScope.scope, functionCall(FunctionType.ADD_DISTRIBUTION, random.getType(),
                "Add the current distribution to the distribution accumulator.", args));
    }

    @Override
    protected void getPerSourceConfigStartIR(FuncData funcData, TreeBuilderInfo info,
            CompilationContext compilationCtx) {
        IRTreeVoid updateReachable = store(reachedDistributionsSource,
                addDD(load(reachedDistributionsSource), info.probability), "Record the reached probability density.");
        compilationCtx.addTreeToScope(GlobalScope.scope, updateReachable);

        // Initialize an accumulator for the probabilities.
        IRTreeReturn<DoubleVariable> sampleProbability = getSourceValueProbability(funcData, compilationCtx);
        compilationCtx.addTreeToScope(GlobalScope.scope, initializeVariable(probabilitiesAccumulator,
                addDD(log(info.probability), sampleProbability),
                "An accumulator to allow the value for each distribution to be constructed before it is added to the index probabilities."));
    }

    private IRTreeReturn<DoubleVariable> getSourceValueProbability(FuncData funcData,
            CompilationContext compilationCtx) {
        List<IRTreeReturn<?>> args = constructArguments(funcData.sourceRandom, compilationCtx, getCurrentValue());
        IRTreeReturn<DoubleVariable> sampleProbability = functionCallReturn(FunctionType.LOG_PROBABILITY,
                VariableType.DoubleVariable, funcData.sourceRandom.getType(), args);
        return sampleProbability;
    }

    @Override
    protected void getPerSourceConfigEndIR(FuncData funcData, TreeBuilderInfo info, CompilationContext compilationCtx) {
        compilationCtx.addTreeToScope(GlobalScope.scope, TreeUtils.lseAdd(load(statesProbabilityValue),
                load(probabilitiesAccumulator), statesProbabilityValue,
                "Add the values for the source and any standard consumers for this configuration of arguments to the source."));
    }

    @Override
    protected void getConsumerRVInputIR(TreeBuilderInfo info, RandomVariable<?, ?> consumer, FuncData funcData,
            CompilationContext compilationCtx) {
        funcData.consumerRVArgs = constructArguments(consumer, compilationCtx);
    }

    protected List<IRTreeReturn<?>> constructArguments(RandomVariable<?, ?> random, CompilationContext compilationCtx,
            IRTreeReturn<?>... values) {
        List<Variable<?>> randomInputs = random.getParent().getInputs();
        int noInputs = randomInputs.size();
        int noValues = values.length;
        List<IRTreeReturn<?>> args = new ArrayList<>(noInputs + noValues);
        for(int i = 0; i < noValues; i++)
            args.add(values[i]);

        for(int i = 0; i < noInputs; i++)
            args.add(constructScopedArg(randomInputs.get(i), compilationCtx));
        return args;
    }

    private <C extends Variable<C>> IRLoad<C> constructScopedArg(Variable<C> v, CompilationContext compilationCtx) {
        VariableDescription<C> tempName = VariableNames.calcVarName("temp", Integer.toString(id++),
                v.getUniqueVarDesc().name.getName(), v.getType(), false);
        compilationCtx.addTreeToScope(GlobalScope.scope, initializeUnsetVariable(tempName, Tree.NoComment));
        compilationCtx.pushScope();
        IRTreeReturn<C> value = compilationCtx.getSubstitute(v).getForwardIR(compilationCtx);
        // A hack so that the variable name of the constructed value is saved to keep the optimised code cleaner. Just
        // the else branch will also generate correct code.
        VariableDescription<C> pName = v.getUniqueVarDesc();
        if(!v.isIntermediate() && !v.isSample() && !v.isDeterministic()
                && !compilationCtx.initialized(v)) {
            compilationCtx.addTreeToScope(v.getParent().scope(),
                    initializeVariable(pName, value, "Constructing a random variable input for use later."));
            compilationCtx.addInitialized(v);

            compilationCtx.addTreeToScope(GlobalScope.scope, IRTree.store(tempName, load(pName), Tree.NoComment));
        } else {
            compilationCtx.addTreeToScope(GlobalScope.scope, IRTree.store(tempName, value, Tree.NoComment));
        }
        IRTreeVoid s = IRTree.treeScope(compilationCtx.getOutermostScopeTree(), Tree.NoComment);
        compilationCtx.popScope();
        compilationCtx.addTreeToScope(GlobalScope.scope, s);
        return load(tempName);
    }

    @Override
    protected void finalize(FuncData funcData, CompilationContext compilationCtx) {
        compilationCtx.removeSubstitute(funcData.sampleDesc.output);
    }

    /**
     * Method to construct the for loop to iterate through each possible output of the random variable.
     * 
     * @param funcData The functionData.
     * @return The ForTask representing the loop.
     * 
     */
    @Override
    protected Scope getBackTraceScope(FuncData funcData) {
        // Push the scope onto the stack.
        ScopeStack.pushScope(GlobalScope.scope);

        ForTask loop = Sandwood.forLoop(Variable.intVariable(0), funcData.noStates, Variable.intVariable(1), true,
                (i) -> {
                    i.setAlias(valuePosName);
                    i.setUniqueVarDesc(valuePosName);
                });

        // Restore ScopeStack status.
        ScopeStack.popScope(GlobalScope.scope);
        return loop;
    }

    // No global state is required.
    @Override
    protected void allocateGlobalState(CompilationContext compilationCtx, FuncData funcData) {
        for(RandomVariable<?, ?> rv:funcData.getConsumingRVs()) {
            for(DataflowTask<?> d:rv.getConsumers()) {
                if(((SampleTask<?, ?>) d).isDistribution()) {
                    // TODO shrink the size of this by constructing a set of sizes, not an array for
                    // each random variable.
                    DistributableRandomVariable<?, ?> disRV = (DistributableRandomVariable<?, ?>) rv;
                    VariableDescription<ArrayVariable<DoubleVariable>> disAccumulatorName = getDistributionAccumulatorName(
                            disRV);
                    globalDistributionScratchSpace.put(disRV, disAccumulatorName);
                    allocateGlobalArray(compilationCtx, funcData, disRV, disAccumulatorName);
                    break;
                }
            }
        }

        allocateGlobalStateProb(funcData, compilationCtx);
    }

    protected abstract void allocateGlobalStateProb(FuncData funcData, CompilationContext compilationCtx);

    protected <C extends Variable<C>> void allocateGlobalArray(CompilationContext compilationCtx, FuncData funcData,
            DistributableRandomVariable<?, ?> rv, VariableDescription<ArrayVariable<C>> variableDescription) {
        // Allocate space for storing the results.
        compilationCtx.pushScope();
        // Because of the reuse of max this needs to be serial. We could overcome this
        // by taking a copy of the
        // value of max in a new in, but as I am not sure that parallel allocation is a
        // beneficial, for now we
        // will make this serial and skip any overhead.
        compilationCtx.pushIsSerial(true);

        IRTreeReturn<IntVariable> noStates = rv.getMaxNoStates(compilationCtx);

        // Allocate and store the largest value
        globalFieldAllocation(variableDescription, newArray(noStates, variableDescription.type), funcData,
                compilationCtx);
        // Get the allocator
        IRTreeVoid allocator = compilationCtx.getOutermostScopeTree();

        compilationCtx.popIsSerial();
        compilationCtx.popScope();

        createGlobalField(variableDescription, allocator, funcData, compilationCtx);
    }

    /**
     * Generate the probabilities for each of the sample values. Storing all the values that the sample tasks generates
     * so that they can be used again later with the proposed value once the model state has been updated.
     *
     * @param task           The sample task generating the observed variable
     * @param current        The value of the observed variable generated by the sample task.
     * @param funcData       The function data for this inference method generator.
     * @param info           Information about the current distribution description including the scope and probability
     *                       of the scope.
     * @param compilationCtx The compilation context for this compilation process.
     */

    @Override
    protected void getObservationToSampleIR(SampleTask<?, ?> task, IRTreeReturn<?> current, FuncData funcData,
            TreeBuilderInfo info, CompilationContext compilationCtx) {
        List<IRTreeReturn<?>> args = new ArrayList<>();
        args.add(current);
        args.addAll(funcData.consumerRVArgs);
        IRTreeReturn<DoubleVariable> sampleProbability = functionCallReturn(FunctionType.LOG_PROBABILITY,
                VariableType.DoubleVariable, task.randomVariable.getType(), args);

        // Construct a tree to generate the probability, and save it to the sample
        // accumulator.
        compilationCtx.addTreeToScope(task.scope(),
                TreeUtils.lseAdd(load(consumerSampleProbabilitiesAccumulator),
                        addDD(log(info.probability), sampleProbability), consumerSampleProbabilitiesAccumulator,
                        "Record the probability of sample task " + task.id()
                                + " generating output with current configuration."));

        IRTreeReturn<DoubleVariable> outputValue = subtractDD(load(consumerSampleDistributionProbabilityAccumulator),
                info.probability);
        IRTreeVoid sample = store(consumerSampleDistributionProbabilityAccumulator, outputValue,
                "Recorded the probability of reaching sample task " + task.id() + " with the current configuration.");
        compilationCtx.addTreeToScope(task.scope(), sample);
    }
}
